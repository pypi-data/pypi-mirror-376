import json
import typing
from dataclasses import dataclass, field
from enum import Enum
from typing import Union, Optional, List

from gen_ai_hub.orchestration.models.base import JSONSerializable
from gen_ai_hub.orchestration.models.multimodal_items import ContentPart, ImageItem, TextPart, ImageUrl, ImagePart

@dataclass
class FunctionCall:
    """
    The function that the model called.
    """
    name: Optional[str] = field(
        default=None,
        metadata={"description": "The name of the function to call."}
    )
    arguments: Optional[str] = field(
        default=None,
        metadata={
            "description": (
                "The arguments to call the function with, as generated by the "
                "model in JSON format. Note that the model does not always "
                "generate valid JSON, and may hallucinate parameters not "
                "defined by your function schema. Validate the arguments in "
                "your code before calling your function."
            )
        }
    )

    def parse_arguments(self) -> dict:
        """Attempts to parse the arguments string as JSON."""

        if self.arguments is None:
            return {}

        return json.loads(self.arguments)


@dataclass
class MessageToolCall:
    """
    Represents a tool call within a message, specifically a function call.
    """
    id: str = field(metadata={"description": "The ID of the tool call."})
    type: typing.Literal["function"] = field(
        metadata={
            "description": (
                "The type of the tool. Currently, only `function` is supported."
            )
        }
    )
    function: FunctionCall = field(
        metadata={"description": "The function that the model called."}
    )

    def to_dict(self):
        return {
            "id": self.id,
            "type": self.type,
            "function": {
                "name": self.function.name,
                "arguments": self.function.arguments,
            }
        }


class Role(str, Enum):
    """
    Enumerates supported roles in LLM-based conversations.

    This enum defines the standard roles used in interactions with Large Language Models (LLMs).
    These roles are generally used to structure the input and distinguish between different parts of the conversation.

    Values:
        USER: Represents the human user's input in the conversation.
        SYSTEM: Represents system-level instructions or context setting for the LLM.
        ASSISTANT: Represents the LLM's responses in the conversation.
        TOOL: Represents a tool or function that the LLM can call.
        DEVELOPER: Represents the developer's input or instructions in the conversation.
    """

    USER = "user"
    SYSTEM = "system"
    ASSISTANT = "assistant"
    TOOL = "tool"
    DEVELOPER = "developer"

@dataclass
class Message(JSONSerializable):
    """
    Represents a single message in a prompt or conversation template.

    This base class defines the structure for all types of messages in a prompt,
    including content and role.

    Args:
        role: The role of the entity sending the message.
        content: The message content, which may be plain text or a sequence of text and images.
    """

    role: Union[Role, str]
    content: Union[str, List[ContentPart]]
    refusal: Optional[str] = None
    tool_calls: Optional[List[MessageToolCall]] = None

    def to_dict(self):
        base = {
            "role": self.role,
            "content": self.content if isinstance(self.content, str) else [item.to_dict() for item in self.content],
        }

        if self.refusal is not None:
            base["refusal"] = self.refusal

        if self.tool_calls:
            base["tool_calls"] = [tool_call.to_dict() for tool_call in self.tool_calls]

        return base


class SystemMessage(Message):
    """
    Represents a system message in a prompt or conversation template.

    System messages typically provide context or instructions to the AI model.

    Args:
        content: The text content of the system message.
    """

    def __init__(self, content: str):
        super().__init__(role=Role.SYSTEM, content=content)


class UserMessage(Message):
    """
    Represents a user message in a prompt or conversation template.

    User messages typically contain queries or inputs from the user.

    Args:
        content: The message content, which may be plain text or a sequence of text and images.
    """

    def __init__(self, content: Union[str, List[Union[str, ImageItem]]]):

        mapped_content = []

        if isinstance(content, str):
            mapped_content = content
        elif isinstance(content, list):
            for item in content:
                if isinstance(item, str):
                    mapped_content.append(TextPart(text=item))
                elif isinstance(item, ImageItem):
                    mapped_content.append(ImagePart(image_url=ImageUrl(url=item.url, detail=item.detail)))
                else:
                    raise TypeError("User message content list must contain only str or ImageItem")

        super().__init__(role=Role.USER, content=mapped_content)


class AssistantMessage(Message):
    """
    Represents an assistant message in a prompt or conversation template.

    Assistant messages typically contain responses or outputs from the AI model.

    Args:
        content: The text content of the assistant message.
        refusal: A string indicating refusal reason.
        tool_calls: A list of tool call objects.
    """

    def __init__(
            self,
            content: str,
            refusal: Optional[str] = None,
            tool_calls: Optional[List[MessageToolCall]] = None,
    ):
        super().__init__(role=Role.ASSISTANT, content=content, refusal=refusal, tool_calls=tool_calls)


class ToolMessage(Message):
    def __init__(self, content: str, tool_call_id: str):
        super().__init__(role=Role.TOOL, content=content)
        self.tool_call_id = tool_call_id

    def to_dict(self):
        base = super().to_dict()
        base["tool_call_id"] = self.tool_call_id
        return base
