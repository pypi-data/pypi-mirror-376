# Secret organization in the secret manager tree:
# datasurface/{{ecosystem_name}}/{{platform_name}}/merge/credentials
# datasurface/{{ecosystem_name}}/

import boto3
from typing import Union, Tuple
from kubernetes.client import models as k8s
import json
import re


class AwsSecretManager(SecretManager):

    def __init__(self, namespace: str):
        self.namespace = namespace
        self.secrets_client = boto3.client('secretsmanager')

    def isNameAllowed(self, credential_name: str) -> bool:
        """
        Check if the credential name is legal for AWS Secrets Manager.
        
        AWS Secrets Manager naming requirements:
        - Length: 1-512 characters
        - Allowed characters: ASCII letters (a-z, A-Z), numbers (0-9), 
          and special characters: / _ + = . @ -
        - Should not end with hyphen followed by 6 characters (AWS appends this pattern)
        """
        if not credential_name or len(credential_name) < 1 or len(credential_name) > 512:
            return False
        
        # Check for allowed characters: ASCII letters, numbers, and / _ + = . @ -
        if not re.match(r'^[a-zA-Z0-9/_+=.@-]+$', credential_name):
            return False
        
        # Check if name ends with hyphen followed by exactly 6 characters (AWS pattern)
        if re.match(r'.*-[a-zA-Z0-9]{6}$', credential_name):
            return False
        
        return True

    def generateLegalName(self, credential_name: str) -> str:
        """
        Generate a legal name for AWS Secrets Manager from any input string.
        
        Transforms the input to comply with AWS Secrets Manager naming requirements:
        - Keeps allowed characters: a-z, A-Z, 0-9, / _ + = . @ -
        - Replaces spaces with hyphens
        - Removes or replaces invalid characters
        - Ensures length is within 1-512 characters
        - Avoids ending with hyphen + 6 characters pattern
        """
        if not credential_name:
            return "default-secret"
        
        # Replace spaces with hyphens
        name = credential_name.replace(' ', '-')
        
        # Keep only allowed characters: a-z, A-Z, 0-9, / _ + = . @ -
        name = re.sub(r'[^a-zA-Z0-9/_+=.@-]', '', name)
        
        # Collapse multiple consecutive hyphens into single hyphen
        name = re.sub(r'-+', '-', name)
        
        # Remove leading/trailing hyphens
        name = name.strip('-')
        
        # Ensure we have something left
        if not name:
            name = "default-secret"
        
        # Truncate if too long (leave room to avoid AWS pattern)
        if len(name) > 500:  # Leave some buffer
            name = name[:500].rstrip('-')
        
        # Avoid ending with hyphen + 6 characters (AWS appends this pattern)
        if re.match(r'.*-[a-zA-Z0-9]{6}$', name):
            name = name + "-custom"
        
        return name

    def getUserPassword(self, credential_name: str) -> Tuple[Union[k8s.V1EnvVarSource, str], Union[k8s.V1EnvVarSource, str]]:
        actual_credential_name = self.generateLegalName(credential_name)
        merge_response = self.secrets_client.get_secret_value(SecretId='datasurface/{{ecosystem_name}}/{{actual_credential_name}}/credentials')
        if not merge_response:
            raise Exception(f"Secret {credential_name}({actual_credential_name}) not found")
        merge_creds = json.loads(merge_response['SecretString'])
        user: str = merge_creds.get('USER', '')
        password: str = merge_creds.get('PASSWORD', '')
        return user, password
       
    def getPATSecret(self, credential_name: str) -> Union[k8s.V1EnvVarSource, str]:
        actual_credential_name = self.generateLegalName(credential_name)
        git_response = self.secrets_client.get_secret_value(SecretId='datasurface/{{ecosystem_name}}/{{actual_credential_name}}/credentials')
        if not git_response:
            raise Exception(f"Secret {credential_name}({actual_credential_name}) not found")
        git_creds = json.loads(git_response['SecretString'])
        token: str = git_creds.get('token', '')
        return token

    def getApiKey(self, credential_name: str) -> Tuple[Union[k8s.V1EnvVarSource, str], Union[k8s.V1EnvVarSource, str]]:
        # If secret is not found then raise an Exception
        actual_credential_name = self.generateLegalName(credential_name)
        api_response = self.secrets_client.get_secret_value(SecretId='datasurface/{{ecosystem_name}}/{{actual_credential_name}}/credentials')
        if not api_response:
            raise Exception(f"Secret {credential_name}({actual_credential_name}) not found")
        api_creds = json.loads(api_response['SecretString'])
        api_key: str = api_creds.get('api_key', '')
        api_secret: str = api_creds.get('api_secret', '')
        return api_key, api_secret

secret_manager = AwsSecretManager(namespace='{{ namespace_name }}')


