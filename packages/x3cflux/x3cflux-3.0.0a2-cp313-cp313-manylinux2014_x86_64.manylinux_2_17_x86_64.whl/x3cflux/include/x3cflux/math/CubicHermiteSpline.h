// This work is derived from the cubic hermite spline interpolator
// implemented in the boost math library (since v1.73).
//
// Copyright Nick Thompson, 2020
// Use, modification and distribution are subject to the
// Boost Software License, Version 1.0.
//
// Boost Software License - Version 1.0 - August 17th, 2003
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef X3CFLUX_CUBICHERMITESPLINE_H
#define X3CFLUX_CUBICHERMITESPLINE_H

#include "MathError.h"
#include "NumericTypes.h"
#include <util/Logging.h>
#include <vector>

namespace x3cflux {

/// \brief Hermite spline interpolator with cubic degree polynomials
/// \tparam FunctionValueType type of function value (Eigen vector or matrix)
template <typename FunctionValueType> class CubicHermiteSpline {
  public:
    using FunctionValue = FunctionValueType;
    using Scalar = typename FunctionValue::Scalar;
    using ElementValue = std::conditional_t<std::is_same<FunctionValue, Matrix<Scalar>>::value, Vector<Scalar>, Scalar>;

  private:
    std::vector<Real> places_;
    std::vector<FunctionValue> functionValues_;
    std::vector<FunctionValue> derivativeValues_;

  public:
    CubicHermiteSpline() = default;

    /// Create cubic hermite spline interpolation.
    /// \param places function evaluation places in ascending order
    /// \param functionValues function values at evaluation places
    /// \param derivativeValues function derivatives at evaluation places
    CubicHermiteSpline(std::vector<Real> places, const std::vector<FunctionValue> &functionValues,
                       const std::vector<FunctionValue> &derivativeValues)
        : places_(std::move(places)), functionValues_(functionValues), derivativeValues_(derivativeValues) {
        X3CFLUX_CHECK(places_.size() == functionValues_.size() and places_.size() == derivativeValues_.size());

        X3CFLUX_CHECK(std::is_sorted(places_.begin(), places_.end()));
    }

    /// \return function evaluation places
    const std::vector<Real> &getPlaces() const { return places_; }

    /// \return function values at evaluation places
    const std::vector<FunctionValue> &getFunctionValues() const { return functionValues_; }

    /// \return function derivatives at evaluation places
    const std::vector<FunctionValue> &getDerivativeValues() const { return derivativeValues_; }

    /// Interpolate function in a given place.
    /// \param place evaluation place
    /// \return interpolated function value
    FunctionValue operator()(Real place) const { return evaluate(place); }

    /// Interpolate element function in a given place.
    /// \param place evaluation place
    /// \param elemIndex index of element
    /// \return interpolated element function value
    ElementValue operator()(Real place, Index elemIndex) const { return evaluateElement(place, elemIndex); }

    /// Interpolate function in a given place.
    /// \param place evaluation place
    /// \return interpolated function value
    FunctionValue evaluate(Real place) const {
        if (places_.front() > place) {
            auto x0 = places_[0], x1 = places_[1];
            const auto &y0 = functionValues_[0], &y1 = functionValues_[1];
            const auto &dy0 = derivativeValues_[0], &dy1 = derivativeValues_[1];
            return computeCubicSpline(y0, y1, dy0, dy1, place, x0, x1);
        }

        for (std::size_t i = 1; i < places_.size() - 1; ++i) {
            auto x0 = places_[i - 1], x1 = places_[i];

            if (x0 <= place and x1 > place) {
                const auto &y0 = functionValues_[i - 1], &y1 = functionValues_[i];
                const auto &dy0 = derivativeValues_[i - 1], &dy1 = derivativeValues_[i];
                return computeCubicSpline(y0, y1, dy0, dy1, place, x0, x1);
            }
        }

        auto x0 = places_[places_.size() - 2], x1 = places_.back();
        const auto &y0 = functionValues_[places_.size() - 2], &y1 = functionValues_.back();
        const auto &dy0 = derivativeValues_[places_.size() - 2], &dy1 = derivativeValues_.back();
        return computeCubicSpline(y0, y1, dy0, dy1, place, x0, x1);
    }

    /// Interpolate element function in a given place.
    /// \param place evaluation place
    /// \param elemIndex index of element
    /// \return interpolated element function value
    ElementValue evaluateElement(Real place, Index elemIndex) const {
        if (places_.front() > place) {
            auto x0 = places_[0], x1 = places_[1];
            const auto &y0 = get(functionValues_[0], elemIndex), &y1 = get(functionValues_[1], elemIndex);
            const auto &dy0 = get(derivativeValues_[0], elemIndex), &dy1 = get(derivativeValues_[1], elemIndex);
            return computeCubicSpline(y0, y1, dy0, dy1, place, x0, x1);
        }

        for (std::size_t i = 1; i < places_.size() - 1; ++i) {
            auto x0 = places_[i - 1], x1 = places_[i];

            if (x0 <= place and x1 > place) {
                const auto &y0 = get(functionValues_[i - 1], elemIndex), &y1 = get(functionValues_[i], elemIndex);
                const auto &dy0 = get(derivativeValues_[i - 1], elemIndex), &dy1 = get(derivativeValues_[i], elemIndex);
                return computeCubicSpline(y0, y1, dy0, dy1, place, x0, x1);
            }
        }

        auto x0 = places_[places_.size() - 2], x1 = places_.back();
        const auto &y0 = get(functionValues_[places_.size() - 2], elemIndex),
                   &y1 = get(functionValues_.back(), elemIndex);
        const auto &dy0 = get(derivativeValues_[places_.size() - 2], elemIndex),
                   &dy1 = get(derivativeValues_.back(), elemIndex);
        return computeCubicSpline(y0, y1, dy0, dy1, place, x0, x1);
    }

    /// Interpolate derivative of function in a given place.
    /// \param place evaluation place
    /// \return interpolated derivative value
    FunctionValue evaluateDerivative(Real place) const {
        if (places_.front() > place) {
            auto x0 = places_[0], x1 = places_[1];
            const auto &y0 = functionValues_[0], &y1 = functionValues_[1];
            const auto &dy0 = derivativeValues_[0], &dy1 = derivativeValues_[1];
            return computeCubicSplineDerivative(y0, y1, dy0, dy1, place, x0, x1);
        }

        for (std::size_t i = 1; i < places_.size() - 1; ++i) {
            auto x0 = places_[i - 1], x1 = places_[i];

            if (x0 <= place and x1 > place) {
                const auto &y0 = functionValues_[i - 1], &y1 = functionValues_[i];
                const auto &dy0 = derivativeValues_[i - 1], &dy1 = derivativeValues_[i];
                return computeCubicSplineDerivative(y0, y1, dy0, dy1, place, x0, x1);
            }
        }

        auto x0 = places_[places_.size() - 2], x1 = places_.back();
        const auto &y0 = functionValues_[places_.size() - 2], &y1 = functionValues_.back();
        const auto &dy0 = derivativeValues_[places_.size() - 2], &dy1 = derivativeValues_.back();
        return computeCubicSplineDerivative(y0, y1, dy0, dy1, place, x0, x1);
    }

    /// \return domain of interpolation
    std::pair<Real, Real> getDomain() const { return std::make_pair(places_.front(), places_.back()); }

  private:
    template <typename ValueType>
    static ValueType computeCubicSpline(const ValueType &y0, const ValueType &y1, const ValueType &dy0,
                                        const ValueType &dy1, Real place, Real x0, Real x1) {
        auto dx = x1 - x0;
        auto t = (place - x0) / dx;

        return (1 - t) * (1 - t) * (y0 * (1 + 2 * t) + dy0 * (place - x0)) +
               t * t * (y1 * (3 - 2 * t) + dx * dy1 * (t - 1));
    }

    template <typename ValueType>
    static ValueType computeCubicSplineDerivative(const ValueType &y0, const ValueType &y1, const ValueType &dy0,
                                                  const ValueType &dy1, Real place, Real x0, Real x1) {
        auto dx = x1 - x0;

        auto a0 = (y1 - y0 - dy0 * dx) / (dx * dx);
        auto a1 = (dy1 - dy0) / (2 * dx);
        auto b1 = 3 * a0 - 2 * a1;
        auto b0 = 2 * (a1 - a0) / dx;

        return dy0 + 2 * b0 * (place - x0) + 3 * b1 * (place - x0) * (place - x0);
    }

    static Real get(const RealVector &value, Index elemIndex) { return value(elemIndex); }

    static RealVector get(const RealMatrix &value, Index elemIndex) { return value.row(elemIndex); }
};

} // namespace x3cflux

#endif // X3CFLUX_CUBICHERMITESPLINE_H
