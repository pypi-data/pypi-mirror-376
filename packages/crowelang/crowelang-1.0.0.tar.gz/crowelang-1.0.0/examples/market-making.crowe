// CroweLang Example: Market Making Strategy
// Basic market making with inventory management

import "ibkr" as broker;
import { EMA, StdDev, VWAP } from "crowelang/indicators";

strategy MarketMaker {
  params {
    spread_bps: float = 5.0;          // 5 basis points
    max_inventory: float = 10000.0;   // Max position size
    order_size: float = 100.0;        // Base order size
    skew_factor: float = 0.5;         // Inventory skew multiplier
    quote_ttl: int = 1000;            // Quote time-to-live in ms
    min_profit_bps: float = 2.0;      // Minimum profit per trade
  }
  
  indicators {
    mid_price = (best_bid + best_ask) / 2;
    fair_value = EMA(mid_price, 10);
    volatility = StdDev(mid_price, 20) * sqrt(252 * 24 * 60); // Annualized
    inventory_ratio = position / max_inventory;
  }
  
  signals {
    quote_stale = time_since_last_quote > quote_ttl;
    inventory_full = abs(position) > max_inventory * 0.8;
    high_volatility = volatility > historical_volatility * 2.0;
    wide_spread = (best_ask - best_bid) > spread_bps * 2 * mid_price / 10000;
  }
  
  rules {
    when (quote_stale or market_moved or inventory_changed) {
      cancel_all_quotes();
      place_new_quotes();
    }
    
    when (inventory_full) {
      // Reduce quote sizes when inventory is full
      adjust_quote_sizes(inventory_ratio);
    }
    
    when (high_volatility) {
      // Widen spreads during high volatility
      increase_spreads(volatility_multiplier);
    }
    
    when (wide_spread and not inventory_full) {
      // Tighten spreads to compete when market is wide
      place_aggressive_quotes();
    }
  }
  
  risk {
    max_position = max_inventory;
    max_daily_loss = 5000.0;
    max_order_rate = 100; // orders per second
    greek_limits {
      max_delta = 0.1;
      max_gamma = 0.05;
      max_vega = 0.02;
    }
  }
  
  events {
    on_book(book: OrderBook) {
      // Update fair value based on order book
      weighted_mid = calculate_weighted_mid(book);
      update_fair_value(weighted_mid);
      
      // Check if we should requote
      if (abs(mid_price - last_quoted_mid) > requote_threshold) {
        requote();
      }
    }
    
    on_fill(fill: Fill) {
      log("MM Fill: ${fill.side} ${fill.quantity} @ ${fill.price}");
      
      // Update inventory
      if (fill.side == BUY) {
        position += fill.quantity;
      } else {
        position -= fill.quantity;
      }
      
      // Immediate requote after fill
      requote_after_fill();
      
      // Check if we need to hedge
      if (abs(position) > hedge_threshold) {
        hedge_position();
      }
    }
    
    on_tick(tick: Tick) {
      // Update last trade price for fair value
      if (tick.size > min_trade_size) {
        last_trade_price = tick.price;
        last_trade_time = tick.timestamp;
      }
    }
  }
}

// Market microstructure analysis
microstructure OrderFlow {
  imbalance = (bid_volume - ask_volume) / (bid_volume + ask_volume);
  toxicity = adverse_selection_cost / total_volume;
  
  detect {
    sweep = large_order_detection(threshold = 10 * avg_order_size);
    iceberg = hidden_order_detection(book_history);
    spoofing = cancelled_order_ratio > 0.9;
    momentum = price_acceleration > momentum_threshold;
  }
  
  quote {
    bid_price = fair_value - half_spread - inventory_skew;
    ask_price = fair_value + half_spread + inventory_skew;
    bid_size = base_size * size_multiplier(inventory_ratio);
    ask_size = base_size * size_multiplier(-inventory_ratio);
  }
  
  hedging {
    when (abs(inventory) > max_inventory * 0.5) {
      hedge_ratio = min(1.0, abs(inventory) / max_inventory);
      hedge_with_futures(inventory * hedge_ratio);
    }
    
    when (inventory_age > max_inventory_age) {
      liquidate_stale_inventory();
    }
  }
}

// Supporting functions for market making
indicator InventorySkew(inventory: float, max_inv: float, skew: float) -> float {
  ratio = inventory / max_inv;
  return ratio * skew * mid_price / 10000; // Convert to price units
}

indicator OptimalSpread(volatility: float, inventory: float, adverse_selection: float) -> float {
  base_spread = volatility * sqrt(quote_ttl / (252 * 24 * 60 * 60 * 1000));
  inventory_penalty = abs(inventory) / max_inventory * 0.001;
  adverse_selection_buffer = adverse_selection * 1.5;
  
  return max(min_spread, base_spread + inventory_penalty + adverse_selection_buffer);
}

// Risk management for market making
data RiskLimits {
  max_position: float;
  max_notional: float;
  max_daily_volume: float;
  max_order_rate: float;
  
  constraints {
    position_limit = abs(position) < max_position;
    notional_limit = abs(position * mid_price) < max_notional;
    volume_limit = daily_volume < max_daily_volume;
    rate_limit = order_rate < max_order_rate;
  }
}

// Performance metrics specific to market making
portfolio MarketMakerMetrics {
  positions: Map<string, Position>;
  cash: float;
  unrealized_pnl: float;
  realized_pnl: float;
  
  metrics {
    inventory_turnover = daily_volume / avg_inventory;
    capture_ratio = realized_spread / theoretical_spread;
    adverse_selection_cost = sum(fill_price - mid_price_at_fill);
    quote_hit_ratio = filled_quotes / total_quotes;
    profitability = realized_pnl / capital_deployed;
    sharpe_ratio = mean_daily_pnl / std_daily_pnl * sqrt(252);
  }
}

// Backtest configuration for market making
backtest MarketMakingTest {
  data_source = "ibkr_tick";
  start_date = "2023-01-01";
  end_date = "2023-03-31";
  initial_capital = 500000;
  
  universe = ["SPY"];  // Start with liquid ETF
  frequency = TICK;    // Need tick data for market making
  
  costs {
    commission = 0.0001;     // 1 bp for market making
    exchange_fees = 0.0003;  // Exchange fees for liquidity provision
    clearing_fees = 0.0001;  // Clearing fees
  }
  
  market_simulation {
    latency = 50;           // 50 microseconds to exchange
    fill_probability = 0.95; // 95% fill rate for at-bid/offer
    adverse_selection = 0.0002; // 2 bps adverse selection
  }
  
  output {
    metrics = true;
    inventory_chart = true;
    pnl_attribution = true;
    risk_report = true;
    microstructure_analysis = true;
  }
}