from ipywidgets import (
    Widget, DOMWidget, widget_serialization, register
)
from ipywidgets.widgets.trait_types import TypedTuple
from traitlets import (
    Unicode, Int, CInt, Instance, ForwardDeclaredInstance, This, Enum,
    Tuple, List, Dict, Float, CFloat, Bool, Union, Any,
)
from ..basewidget import BaseWidget


class Map(BaseWidget):
    """ 
:warning: **Autogenerated class**

**Map.**

Map is mainly used in the visualization of geographic area data, which can be used with [visualMap](#visualMap) component to visualize the data such as population distribution density in different areas.

Series of same [map type](#series-map.map) will show in one map. At this point, the configuration of the first series will be used for the map configuration.
    """

    def __init__(self, **kwargs):

        super().__init__(**kwargs)  
    
    _model_name = Unicode("MapModel").tag(sync=True)
    
    type = Unicode("map", allow_none=True, ).tag(sync=True)
    
    id = Unicode(None, allow_none=True, help="""Component ID, not specified by default. If specified, it can be used to refer the component in option or API.""").tag(sync=True)
    
    name = Unicode(None, allow_none=True, help="""Series name used for displaying in [tooltip](#tooltip) and filtering with [legend](#legend), or updating data and configuration with `setOption`.""").tag(sync=True)
    
    colorBy = Unicode(None, allow_none=True, help="""Since `v5.2.0`

The policy to take color from [option.color](#color). Valid values:

* `'series'`: assigns the colors in the palette by series, so that all data in the same series are in the same color;
* `'data'`: assigns colors in the palette according to data items, with each data item using a different color.""").tag(sync=True)
    
    map = Unicode(None, allow_none=True, help="""Map name registered in [registerMap](api.html#echarts.registerMap).

**Use geoJSON**

```
$.get('map/china_geo.json', function (geoJson) {
    echarts.registerMap('china', {geoJSON: geoJson});
    var chart = echarts.init(document.getElementById('main'));
    chart.setOption({
        series: [{
            type: 'map',
            map: 'china',
            ...
        }]
    });
});
```

See also [USA Population Estimates](https://echarts.apache.org/examples/en/editor.html?c=map-usa).

The demo above shows that ECharts can uses [geoJSON](http://geojson.org/) format as map outline. You can use third-party [geoJSON](http://geojson.org/) data (like [maps](https://github.com/echarts-maps)) and register them into ECharts.

**Use SVG**

```
$.get('map/topographic_map.svg', function (svg) {
    echarts.registerMap('topo', {svg: svg});
    var chart = echarts.init(document.getElementById('main'));
    chart.setOption({
        series: [{
            type: 'map',
            map: 'topo',
            ...
        }]
    });
});
```

See also [Beef Cuts](https://echarts.apache.org/examples/en/editor.html?c=geo-beef-cuts).

The demo above shows that SVG format can be used in ECharts. See more info in [SVG Base Map](https://echarts.apache.org/handbook/en/how-to/component-types/geo/svg-base-map).""").tag(sync=True)
    
    projection = Dict(default_value=None, allow_none=True, help="""Since `v5.3.0`

For custom map projection, at least two methods `project`, `unproject` should be provided to calculate the coordinates after projection and before projection respectively.

For example, for the Mercator projection.

```
series: {
    type: 'map',
    projection: {
        project: (point) => [point[0] / 180 * Math.PI, -Math.log(Math.tan((Math.PI / 2 + point[1] / 180 * Math.PI) / 2))],
        unproject: (point) => [point[0] * 180 / Math.PI, 2 * 180 / Math.PI * Math.atan(Math.exp(point[1])) - 90]
    }
}
```

In addition to our own implementation of the projection formula, we can also use exists projection implementations provided by third-party libraries such as [d3-geo](https://github.com/d3/d3-geo).

```
const projection = d3.geoConicEqualArea();
// ...
series: {
    type: 'map',
    projection: {
        project: (point) => projection(point),
        unproject: (point) => projection.invert(point)
    }
}
```

Note: Custom projections are only useful when using `GeoJSON` as a data source.""").tag(sync=True)
    
    center = Any(None, allow_none=True, help="""`center` specifies which point on the source map should be placed at the center of the viewport (i.e., typically, the center of the canvas).

`center` is typically used in control or fetch the position of source map when [roamming](#series-map.roam) is performed. When roaming, the values in `center` and [zoom](#series-map.zoom) will be modified correspondingly.

Notice: the values in `center` are based on the original layout coordinates, rather than the viewport (canvas) coordinates. If you intend to adjust the position and size of source map by viewport coordinates, use [series-map.left](#series-map.left) / [.right](#series-map.right) / [.top](#series-map.top) / [.bottom](#series-map.bottom) / [.width](#series-map.width) / [.height](#series-map.height) or [series-map.layoutCenter](#series-map.layoutCenter) / [layoutSize](#series-map.layoutSize).

`center` is in longitude and latitude by default. Use the projected coordinates if [proejction](#series-map.projection) is set.

Example:

```
// Place this [lng, lat] at the center of the viewport (canvas).
center: [115.97, 29.71]
```

```
projection: {
    projection: (pt) => project(pt)
},
center: project([115.97, 29.71])
```

A percentage string can also be used in `center`, like `'30%'`, based on the bounding rect(determined min/max latitude/longitude, or min/max projected coordinates if [proejction](#series-map.projection) is set). You can use `'0%'` to place the top or left of bounding rect to the center of the viewport (typically, canvas), or use `'100%'` to place the right or bottom to the center of the viewport, or use `'50%'` to place the entire source map at the the center of the viewport.
For example:

```
center: [115, '30%']
// Place the top of source map to the center of the viewport (canvas)
center: [115, '0%']
// Place the left of source map to the center of the viewport (canvas)
center: ['0%', 13]
// Place the bottom of source map to the center of the viewport (canvas)
center: [115, '100%']
// Place the right of source map to the center of the viewport (canvas)
center: ['100%', 13]
// Place source map at center of the viewport (canvas)
center: ['50%', '50%']
```

> The percentage string is introduced since `v5.3.3`. It is initially based on canvas width/height. But that is not reasonable, and then changed to be based on the bounding rect since `v6.0.0`.

**See [geo roam indicator example](https://echarts.apache.org/examples/en/editor.html?c=doc-example/geo-roam-indicator&edit=1&reset=1)** to understand the concept.""").tag(sync=True)
    
    zoom = Float(None, allow_none=True, help="""Zoom rate of current viewport.

The value less than `1` indicates zooming out, while the value greater than `1` indicates zooming in.

When [roaming](#series-map.roam), the values in [center](#series-map.center) and `zoom` will be modified correspondingly.

**See [geo roam indicator example](https://echarts.apache.org/examples/en/editor.html?c=doc-example/geo-roam-indicator&edit=1&reset=1)** to understand the concept.""").tag(sync=True)
    
    scaleLimit = Dict(default_value=None, allow_none=True, help="""Limit of [zooming](#series-map.roam), with `min` and `max`.

The value less than `1` indicates zooming out, while the value greater than `1` indicates zooming in.""").tag(sync=True)
    
    roam = Union([Bool(default_value=None, allow_none=True),Unicode(default_value=None, allow_none=True),], default_value=None, allow_none=True, help="""Whether to enable mouse or touch roam (move and zoom). Optional values are:

* `false`: roam is disabled.
* `'scale'` or `'zoom'`: zoom only.
* `'move'` or `'pan'`: move (translation) only.
* `true`: both zoom and move (translation) are available.

When roaming, the values in [center](#series-map.center) and [zoom](#series-map.zoom) will be modified correspondingly.""").tag(sync=True)
    
    roamTrigger = Unicode(None, allow_none=True, help="""Since `v6.0.0`

[Roaming](#series-map.roam) can be triggered by mouse dragging or mouse wheel.

Options:

* `'selfRect'`:

  The roaming can only be triggered on the bounding rect of the graphic elements.
* `'global'`:

  If `clip: true`, the roaming can only be triggered at any position within the clipped area. Otherwise it can be triggered in canvas globally.

**See [geo roam indicator example](https://echarts.apache.org/examples/en/editor.html?c=doc-example/geo-roam-indicator&edit=1&reset=1)** to understand the concept.""").tag(sync=True)
    
    aspectScale = Float(None, allow_none=True, help="""Used to scale aspect of geo. It will be ignored if [proejction](#series-map.projection) is set.

The final calculated `pixelWidth` and `pixelHeight` of the map will satisfy `pixelWidth / pixelHeight = lngSpan / latSpan * aspectScale` (assume [proejction](#series-map.projection) is not specified, and [preserveAspect](#series-map.preserveAspect) is truthy).

If no [proejction](#series-map.projection) is applied, the latitudes and longitudes in GeoJSON are linearly mapped to pixel coordinates diarectly. `aspectScale` offers a simple way to visually compensates for the distortion caused by the fact that the longitudinal spacing shrinks as latitude increases. For example, an `aspectScale` can be roughly calculated as `aspectScale = Math.cos(center_latitude * Maht.PI / 180)`, which is similar to a sinusoidal projection.

See [example](https://echarts.apache.org/examples/en/editor.html?c=geo-graph&edit=1&reset=1).""").tag(sync=True)
    
    boundingCoords = Any(None, allow_none=True, help="""Two dimension array. Define coord of left-top, right-bottom in layout box.

```
// A complete world map
map: 'world',
left: 0, top: 0, right: 0, bottom: 0,
boundingCoords: [
    // [lng, lat] of left-top corner
    [-180, 90],
    // [lng, lat] of right-bottom corner
    [180, -90]
],
```""").tag(sync=True)
    
    nameMap = Dict(default_value=None, allow_none=True, help="""Name mapping for customized areas. For example:

```
{
    'China' : '中国'
}
```""").tag(sync=True)
    
    nameProperty = Unicode(None, allow_none=True, help="""Since `v4.8.0`

customized property key for GeoJSON feature. By default, 'name' is used as primary key to identify GeoJSON feature.
For example:

```
{
    nameProperty: 'NAME', // key to connect following data point to GeoJSON region {"type":"Feature","id":"01","properties":{"NAME":"Alabama"}, "geometry": { ... }}
    data:[
        {name: 'Alabama', value: 4822023},
        {name: 'Alaska', value: 731449},
    ]
}
```""").tag(sync=True)
    
    selectedMode = Union([Bool(default_value=None, allow_none=True),Unicode(default_value=None, allow_none=True),], default_value=None, allow_none=True, help="""Selected mode decides whether multiple selecting is supported. By default, `false` is used for disabling selection. Its value can also be `'single'` for selecting single area, or `'multiple'` for selecting multiple areas.""").tag(sync=True)
    
    label = Dict(default_value=None, allow_none=True, help="""Text label of , to explain some data information about graphic item like value, name and so on. `label` is placed under `itemStyle` in ECharts 2.x. In ECharts 3, to make the configuration structure flatter, `label`is taken to be at the same level with `itemStyle`, and has `emphasis` as `itemStyle` does.""").tag(sync=True)
    
    itemStyle = Dict(default_value=None, allow_none=True, help="""Graphic style of Map Area Border, `emphasis` is the style when it is highlighted, like being hovered by mouse, or highlighted via legend connect.""").tag(sync=True)
    
    emphasis = Dict(default_value=None, allow_none=True, help="""Map area style in highlighted state.""").tag(sync=True)
    
    select = Dict(default_value=None, allow_none=True, help="""Map area style in selected state.""").tag(sync=True)
    
    zlevel = Float(None, allow_none=True, help="""`zlevel` value of all graphical elements in .

`zlevel` is used to make layers with Canvas. Graphical elements with different `zlevel` values will be placed in different Canvases, which is a common optimization technique. We can put those frequently changed elements (like those with animations) to a separate `zlevel`. Notice that too many Canvases will increase memory cost, and should be used carefully on mobile phones to avoid crash.

Canvases with bigger `zlevel` will be placed on Canvases with smaller `zlevel`.""").tag(sync=True)
    
    z = Float(None, allow_none=True, help="""`z` value of all graphical elements in , which controls order of drawing graphical components. Components with smaller `z` values may be overwritten by those with larger `z` values.

`z` has a lower priority to `zlevel`, and will not create new Canvas.""").tag(sync=True)
    
    left = Union([Unicode(default_value=None, allow_none=True),Float(default_value=None, allow_none=True),], default_value=None, allow_none=True, help="""Distance between map series and the left side of the container.

`left` can be a pixel value like `20`; it can also be a percentage value relative to the container width like `'20%'`; and it can also be `'left'`, `'center'`, or `'right'`.

If the `left` value is set to be `'left'`, `'center'`, or `'right'`, then the component will be aligned automatically based on position.

> Note: If the graphic elements are unexpectedly distorted, see [preserveAspect](#series-map.preserveAspect).

> Note: There are two rectangular layout approaches for series-map. You can use either one:
>
> * [series-map.left](#series-map.left) / [.right](#series-map.right) / [.top](#series-map.top) / [.bottom](#series-map.bottom) / [.width](#series-map.width) / [.height](#series-map.height)
> * [series-map.layoutCenter](#series-map.layoutCenter) / [.layoutSize](#series-map.layoutSize)""").tag(sync=True)
    
    top = Union([Unicode(default_value=None, allow_none=True),Float(default_value=None, allow_none=True),], default_value=None, allow_none=True, help="""Distance between map series and the top side of the container.

`top` can be a pixel value like `20`; it can also be a percentage value relative to the container height like `'20%'`; and it can also be `'top'`, `'middle'`, or `'bottom'`.

If the `top` value is set to be `'top'`, `'middle'`, or `'bottom'`, then the component will be aligned automatically based on position.

> Note: If the graphic elements are unexpectedly distorted, see [preserveAspect](#series-map.preserveAspect).

> Note: There are two rectangular layout approaches for series-map. You can use either one:
>
> * [series-map.left](#series-map.left) / [.right](#series-map.right) / [.top](#series-map.top) / [.bottom](#series-map.bottom) / [.width](#series-map.width) / [.height](#series-map.height)
> * [series-map.layoutCenter](#series-map.layoutCenter) / [.layoutSize](#series-map.layoutSize)""").tag(sync=True)
    
    right = Union([Unicode(default_value=None, allow_none=True),Float(default_value=None, allow_none=True),], default_value=None, allow_none=True, help="""Distance between map series and the right side of the container.

`right` can be a pixel value like `20`; it can also be a percentage value relative to the container width like `'20%'`.

Adaptive by default.

> Note: If the graphic elements are unexpectedly distorted, see [preserveAspect](#series-map.preserveAspect).

> Note: There are two rectangular layout approaches for series-map. You can use either one:
>
> * [series-map.left](#series-map.left) / [.right](#series-map.right) / [.top](#series-map.top) / [.bottom](#series-map.bottom) / [.width](#series-map.width) / [.height](#series-map.height)
> * [series-map.layoutCenter](#series-map.layoutCenter) / [.layoutSize](#series-map.layoutSize)""").tag(sync=True)
    
    bottom = Union([Unicode(default_value=None, allow_none=True),Float(default_value=None, allow_none=True),], default_value=None, allow_none=True, help="""Distance between map series and the bottom side of the container.

`bottom` can be a pixel value like `20`; it can also be a percentage value relative to the container height like `'20%'`.

Adaptive by default.

> Note: If the graphic elements are unexpectedly distorted, see [preserveAspect](#series-map.preserveAspect).

> Note: There are two rectangular layout approaches for series-map. You can use either one:
>
> * [series-map.left](#series-map.left) / [.right](#series-map.right) / [.top](#series-map.top) / [.bottom](#series-map.bottom) / [.width](#series-map.width) / [.height](#series-map.height)
> * [series-map.layoutCenter](#series-map.layoutCenter) / [.layoutSize](#series-map.layoutSize)""").tag(sync=True)
    
    width = Union([Unicode(default_value=None, allow_none=True),Float(default_value=None, allow_none=True),], default_value=None, allow_none=True, help="""Width of map series. Adaptive by default.

`width` can be a pixel value like `20`; it can also be a percentage value relative to the container width like `'20%'`.

> Note: If the graphic elements are unexpectedly distorted, see [preserveAspect](#series-map.preserveAspect).""").tag(sync=True)
    
    height = Union([Unicode(default_value=None, allow_none=True),Float(default_value=None, allow_none=True),], default_value=None, allow_none=True, help="""Height of map series. Adaptive by default.

`height` can be a pixel value like `20`; it can also be a percentage value relative to the container height like `'20%'`.

> Note: If the graphic elements are unexpectedly distorted, see [preserveAspect](#series-map.preserveAspect).""").tag(sync=True)
    
    layoutCenter = Any(None, allow_none=True, help="""`layoutCenter` and `layoutSize` can specify the rectangular area allocated to map series, where `layoutCenter` defines the center position of the area, and `layoutSize` defines the size of the area. For example:

```
layoutCenter: ['30%', '30%'],
// If width-height ratio is larger than 1, then width is set to be 100.
// Otherwise, height is set to be 100.
// This makes sure that it will not exceed the area of 100x100
layoutSize: 100
```

After setting these two values, `left/right/top/bottom/width/height` becomes invalid.

> Note: There are two rectangular layout approaches for series-map. You can use either one:
>
> * [series-map.left](#series-map.left) / [.right](#series-map.right) / [.top](#series-map.top) / [.bottom](#series-map.bottom) / [.width](#series-map.width) / [.height](#series-map.height)
> * [series-map.layoutCenter](#series-map.layoutCenter) / [.layoutSize](#series-map.layoutSize)""").tag(sync=True)
    
    layoutSize = Union([Float(default_value=None, allow_none=True),Unicode(default_value=None, allow_none=True),], default_value=None, allow_none=True, help="""Size of map, see [layoutCenter](series-map.layoutCenter) for more information. Percentage relative to container width/height, and absolute pixel values are supported.

> Note: There are two rectangular layout approaches for series-map. You can use either one:
>
> * [series-map.left](#series-map.left) / [.right](#series-map.right) / [.top](#series-map.top) / [.bottom](#series-map.bottom) / [.width](#series-map.width) / [.height](#series-map.height)
> * [series-map.layoutCenter](#series-map.layoutCenter) / [.layoutSize](#series-map.layoutSize)""").tag(sync=True)
    
    preserveAspect = Union([Bool(default_value=None, allow_none=True),Unicode(default_value=None, allow_none=True),], default_value=None, allow_none=True, help="""Since `v6.0.0`

`aspect ratio` here refers to `width / height`.

"preserve aspect" refers whether to preserve the `aspect ratio` of the original bounding rect of the content to be rendered.

A `rectangular area` allocated to `map series` is determined by [series-map.left](#series-map.left) / [.right](#series-map.right) / [.top](#series-map.top) / [.bottom](#series-map.bottom) / [.width](#series-map.width) / [.height](#series-map.height) / [.aspectScale](#series-map.aspectScale).

But the `aspect ratio` of this rectangle may not match that of the content's original bounding rect, which may cause distortion.

Options of `preserveAspect`:

* `null`/`undefined`/`false` (default): The original `aspect ratio` of the content will not be preserved, but stretched to fill the `map series rectangular area`, which may cause distortion.
* `'contain'`/`true`: The original `aspect ratio` of the content is preserved; the bounding rect of the content are fully contained by the `map series rectangular area`, and scaled up as much as possible to meet the `map series rectangular area`. [preserveAspectAlign](#series-map.preserveAspectAlign) and [preserveAspectVerticalAlign](#series-map.preserveAspectVerticalAlign) can be used to adjust the position in this case.
* `'cover'`: The original `aspect ratio` of the content is preserved; the bounding rect of the content covers the `map series rectangular area`, and scaled down as much as possible to meet the `map series rectangular area`. [preserveAspectAlign](#series-map.preserveAspectAlign) and [preserveAspectVerticalAlign](#series-map.preserveAspectVerticalAlign) can be used to adjust the position in this case.

Notice: When using [layoutCenter](#series-map.layoutCenter) and [layoutSize](#series-map.layoutSize), the `aspect radio` is always preserved, regardless of this `preserveAspect`.

**See [geo roam indicator example](https://echarts.apache.org/examples/en/editor.html?c=doc-example/geo-roam-indicator&edit=1&reset=1)** to understand the concept.""").tag(sync=True)
    
    preserveAspectAlign = Unicode(None, allow_none=True, help="""Since `v6.0.0`

Options: `'left'` | `'right'` | `'center'`.

See [preserveAspect](#series-map.preserveAspect).

**See [geo roam indicator example](https://echarts.apache.org/examples/en/editor.html?c=doc-example/geo-roam-indicator&edit=1&reset=1)** to understand the concept.""").tag(sync=True)
    
    preserveAspectVerticalAlign = Unicode(None, allow_none=True, help="""Since `v6.0.0`

Options: `'top'` | `'bottom'` | `'middle'`.

See [preserveAspect](#series-map.preserveAspect).

**See [geo roam indicator example](https://echarts.apache.org/examples/en/editor.html?c=doc-example/geo-roam-indicator&edit=1&reset=1)** to understand the concept.""").tag(sync=True)
    
    clip = Bool(None, allow_none=True, help="""Since `v6.0.0`

A `rectangular area` allocated to `map series` is determined by [series-map.left](#series-map.left) / [.right](#series-map.right) / [.top](#series-map.top) / [.bottom](#series-map.bottom) / [.width](#series-map.width) / [.height](#series-map.height) / [.aspectScale](#series-map.aspectScale).

`clip` specifies whether to hide the outside part of the map with respect to the allocated rect.

**See example:** [geo roam indicator](https://echarts.apache.org/examples/en/editor.html?c=doc-example/geo-roam-indicator&edit=1&reset=1).""").tag(sync=True)
    
    coordinateSystem = Unicode(None, allow_none=True, help="""Specifies another coordinate system component on which this `series-map` is laid out.

Options:

* `'geo'`

  Lay out based on a [geographic coordinate system](#geo). When multiple geographic coordinate systems exist within an ECharts instance, the corresponding system should be specified using [geoIndex](#series-map.geoIndex) or [geoId](#series-map.geoId).

**Support for series and component layout on coordinate systems:**

The leftmost column lists the series and components that will be laid out (coordinate systems themselves are also components), and the topmost row lists the coordinate systems that can be laid out on.

|  | no coord sys | [grid](#grid) (cartesian2d) | [polar](#polar) | [geo](#geo) | [singleAxis](#singleAxis) | [radar](#radar) | [parallel](#parallel) | [calendar](#calendar) | [matrix](#matrix) |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| [grid](#grid) (cartesian2d) | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ | ✅ |
| [polar](#polar) | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ | ✅ |
| [geo](#geo) | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ | ✅ |
| [singleAxis](#singleAxis) | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ | ✅ |
| [calendar](#calendar) | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ |
| [matrix](#matrix) | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ |
| [series-line](#series-line) | ❌ | ✅ | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ (✅ if via another coord sys like [grid](#grid)) | ❌ (✅ if via another coord sys like [grid](#grid)) |
| [series-bar](#series-bar) | ❌ | ✅ | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ (✅ if via another coord sys like [grid](#grid)) | ❌ (✅ if via another coord sys like [grid](#grid)) |
| [series-pie](#series-pie) | ✅ | ✅ | ✅ | ✅ | ✅ | ❌ | ❌ | ✅ | ✅ |
| [series-scatter](#series-scatter) | ❌ | ✅ | ✅ | ✅ | ✅ | ❌ | ❌ | ✅ | ✅ |
| [series-effectScatter](#series-effectScatter) | ❌ | ✅ | ✅ | ✅ | ✅ | ❌ | ❌ | ✅ | ✅ |
| [series-radar](#series-radar) | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ | ❌ | ❌ (✅ if via [radar](#radar) coord sys) | ❌ (✅ if via [radar](#radar) coord sys) |
| [series-tree](#series-tree) | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ | ✅ |
| [series-treemap](#series-treemap) | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ | ✅ |
| [series-sunburst](#series-sunburst) | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ | ✅ |
| [series-boxplot](#series-boxplot) | ❌ | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ (✅ if via another coord sys like [grid](#grid)) | ❌ (✅ if via another coord sys like [grid](#grid)) |
| [series-candlestick](#series-candlestick) | ❌ | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ (✅ if via another coord sys like [grid](#grid)) | ❌ (✅ if via another coord sys like [grid](#grid)) |
| [series-heatmap](#series-heatmap) | ❌ | ✅ | ❌ | ✅ | ❌ | ❌ | ❌ | ✅ | ✅ |
| [series-map](#series-map) | ✅ (create a geo coord sys exclusively) | ❌ | ❌ | ✅ | ❌ | ❌ | ❌ | ✅ | ✅ |
| [series-parallel](#series-parallel) | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ | ❌ (✅ if via [parallel](#parallel) coord sys) | ❌ (✅ if via [parallel](#parallel) coord sys) |
| [series-lines](#series-lines) | ❌ | ✅ | ✅ | ✅ | ✅ | ❌ | ❌ | ❌ (✅ if via another coord sys like [geo](#geo)) | ❌ (✅ if via another coord sys like [geo](#geo)) |
| [series-graph](#series-graph) | ✅ (create a "view" coord sys exclusively) | ✅ | ✅ | ✅ | ❌ | ❌ | ❌ | ✅ | ✅ |
| [series-sankey](#series-sankey) | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ | ✅ |
| [series-funnel](#series-funnel) | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ | ✅ |
| [series-gauge](#series-gauge) | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ | ✅ |
| [series-pictorialBar](#series-pictorialBar) | ❌ | ✅ | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ (✅ if via another coord sys like [grid](#grid)) | ❌ (✅ if via another coord sys like [grid](#grid)) |
| [series-themeRiver](#series-themeRiver) | ❌ | ❌ | ❌ | ❌ | ✅ | ❌ | ❌ | ❌ (✅ if via another coord sys like [singleAxis](#singleAxis)) | ❌ (✅ if via another coord sys like [singleAxis](#singleAxis)) |
| [series-chord](#series-chord) | ✅ | ✅ | ✅ | ✅ | ✅ | ❌ | ❌ | ✅ | ✅ |
| [title](#title) | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ | ✅ |
| [legend](#legend) | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ | ✅ |
| [dataZoom](#dataZoom) | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ | ✅ |
| [visualMap](#visualMap) | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ | ✅ |
| [toolbox](#toolbox) | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ | ✅ |
| [timeline](#timeline) | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ | ✅ |
| [thumbnail](#thumbnail) | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ | ✅ |

See also [series-map.coordinateSystemUsage](#series-map.coordinateSystemUsage).""").tag(sync=True)
    
    coordinateSystemUsage = Unicode(None, allow_none=True, help="""Since `v6.0.0`

Specify how to lay out this `series-map` based on the specified [coordinateSystem](#series-map.coordinateSystem).

In most cases, there is no need to specify `coordinateSystemUsage`, unless the default behavior is unexpected.

Options:

* `'data'`:

  Each data item of a series (e.g., each `series.data[i]`) is laid out separately based on the specified coordinate system. Currently no non-series component supports `coordinateSystemUsage: 'data'`.
* `'box'`: **(Not applicable in [series-map](#series-map))**

  The entire series or component is laid out as a whole based on the specified coordinate system - that is, the overall bounding rect or basic anchor point is calculated relative to the system.

  + For example, a [grid component](#grid) can be laid out in a [matrix coordinate system](#matrix) or a [calendar coordinate system](#calendar), where its layout rectangle is calculated by the specified [series-map.coords](#series-map.coords) in that system. See example [sparkline in matrix](https://echarts.apache.org/examples/en/editor.html?c=matrix-sparkline&edit=1&reset=1).
  + For example, a [pie series](#series-pie) or a [chord series](#series-chord) can be laid out in a [geo coordinate system](#geo) or a [cartesian2d coordinate system](#grid), where the center is calculated by the specified [series-pie.coords](#series-pie.coords) or [series-pie.center](#series-pie.center) in that system. See example [pie in geo](https://echarts.apache.org/examples/en/editor.html?c=map-iceland-pie&edit=1&reset=1).

Only a few series support both `coordinateSystemUsage: 'data'` and `coordinateSystemUsage: 'box'`, such as [series-graph](#series-graph), [series-map](#series-map). For examle, in [this example (coordinateSystemUsage: 'data')](https://echarts.apache.org/examples/en/editor.html?c=matrix-graph&edit=1&reset=1), each node of a graph series is laid out on a matrix coordinate system, while in [this example (coordinateSystemUsage: 'box')](https://echarts.apache.org/examples/en/editor.html?c=doc-example/matrix-graph-box&edit=1&reset=1), the entire graph series is laid out within a matrix cell.

Most series only support `coordinateSystemUsage: 'data'` - such as [series-line](#series-line), [series-bar](#series-bar), [series-scatter](#series-scatter), etc. Meanwhile, some series only support `coordinateSystemUsage: 'box'` - such as [series-pie](#series-pie) ([example: pie in geo](https://echarts.apache.org/examples/en/editor.html?c=map-iceland-pie&edit=1&reset=1)), [series-tree](#series-pie), [series-treemap](#series-treemap), [series-sankey](#series-sankey), etc.

See also [series-map.coordinateSystem](#series-map.coordinateSystem).""").tag(sync=True)
    
    coord = Union([Any(default_value=None, allow_none=True),Float(default_value=None, allow_none=True),Unicode(default_value=None, allow_none=True),], default_value=None, allow_none=True, help="""Since `v6.0.0`

When [coordinateSystemUsage](#series-map.coordinateSystemUsage) is `'box'`, `coord` is used as the input to the coordinate system and calculate the layout rectangle or anchor point.

Examples: [sparkline in matrix](https://echarts.apache.org/examples/en/editor.html?c=matrix-sparkline&edit=1&reset=1), [grpah in matrix](https://echarts.apache.org/examples/en/editor.html?c=doc-example/matrix-graph-box&edit=1&reset=1).

> Note: when [coordinateSystemUsage](#series-map.coordinateSystemUsage) is `'data'`, the input of coordinate system is `series.data[i]` rather than this `coord`.

The format this `coord` is defined by each coordinate system, and it's the same as the second parameter of [chart.convertToPixel](api.html#echartsInstance.convertToPixel).""").tag(sync=True)
    
    geoIndex = Float(None, allow_none=True, help="""The index of the [geographic coordinate system](#geo) to base on. When mutiple `geographic` exist within an ECharts instance, use this to specify the corresponding `geographic`.

When `geoIndex` and `geoId` is not specified, map series creates an exclusive `geo` component for itself. `geoIndex` or `geoId` can be used to specify an outer [geo component](#geo), which can be shared with other series like [pie](#series-pie). Moreover, the region color of the outer [geo component](#geo) can be controlled by the map series (via [visualMap](#visualMap)).

When `geoIndex` or `geoId` is specified, [series-map.map](#series-map.map) other style configurations like [series-map.itemStyle](#series-map.itemStyle) will not work, but corresponding configurations in [geo component](#geo) will be used.

**See example**: [geo-choropleth-scatter](https://echarts.apache.org/examples/en/editor.html?c=geo-choropleth-scatter&reset=1&edit=1)""").tag(sync=True)
    
    geoId = Float(None, allow_none=True, help="""The id of the [geographic coordinate system](#geo) to base on. When mutiple `geographic` exist within an ECharts instance, use this to specify the corresponding `geographic`.

When `geoIndex` and `geoId` is not specified, map series creates an exclusive `geo` component for itself. `geoIndex` or `geoId` can be used to specify an outer [geo component](#geo), which can be shared with other series like [pie](#series-pie). Moreover, the region color of the outer [geo component](#geo) can be controlled by the map series (via [visualMap](#visualMap)).

When `geoIndex` or `geoId` specified, [series-map.map](#series-map.map) other style configurations like [series-map.itemStyle](#series-map.itemStyle) will not work, but corresponding configurations in [geo component](#geo) will be used.

**See example**: [geo-choropleth-scatter](https://echarts.apache.org/examples/en/editor.html?c=geo-choropleth-scatter&reset=1&edit=1)""").tag(sync=True)
    
    mapValueCalculation = Unicode(None, allow_none=True, help="""Value of multiple series with the same [map type](#series-map.map) can use this option to get a statistical value.

Supported statistical methods:

* `'sum'`
* `'average'`
* `'max'`
* `'min'`""").tag(sync=True)
    
    showLegendSymbol = Bool(None, allow_none=True, help="""Show the symbol in related area (dot of series symbol). Available when [legend](#legend) component exists.""").tag(sync=True)
    
    seriesLayoutBy = Unicode(None, allow_none=True, help="""When [dataset](#dataset) is used, `seriesLayoutBy` specifies whether the column or the row of `dataset` is mapped to the series, namely, the series is "layout" on columns or rows. Optional values:

* 'column': by default, the columns of `dataset` are mapped the series. In this case, each column represents a dimension.
* 'row'：the rows of `dataset` are mapped to the series. In this case, each row represents a dimension.

Check this [example](https://echarts.apache.org/examples/en/editor.html?c=dataset-series-layout-by).""").tag(sync=True)
    
    datasetIndex = Float(None, allow_none=True, help="""If [series.data](#series.data) is not specified, and [dataset](#dataset) exists, the series will use `dataset`. `datasetIndex` specifies which dataset will be used.""").tag(sync=True)
    
    dataGroupId = Unicode(None, allow_none=True, help="""A group ID assigned to all data items in the series.

This option has a lower priority than `groupId`, which means when `groupId` is specified for a certain data item the `dataGroupId` will be simply ignored for that data item. For more information, please see `series.data.groupId`.""").tag(sync=True)
    
    labelLayout = Union([Any(default_value=None, allow_none=True),Any(default_value=None, allow_none=True),], default_value=None, allow_none=True, help="""Since `v5.0.0`

Unified layout configuration of labels.

It provide a chance to adjust the labels' `(x, y)` position, alignment based on the original layout each series provides.

This option can be a callback with following parameters.

```
// corresponding index of data
dataIndex: number
// corresponding type of data. Only available in graph, in which it can be 'node' or 'edge'
dataType?: string
// corresponding index of series
seriesIndex: number
// Displayed text of label.
text: string
// Bounding rectangle of label.
labelRect: {x: number, y: number, width: number, height: number}
// Horizontal alignment of label.
align: 'left' | 'center' | 'right'
// Vertical alignment of label.
verticalAlign: 'top' | 'middle' | 'bottom'
// Bounding rectangle of the element corresponding to.
rect: {x: number, y: number, width: number, height: number}
// Default points array of labelLine. Currently only provided in pie and funnel series.
// It's null in other series.
labelLinePoints?: number[][]
```

**Example:**

Align the labels on the right. Left 10px margin to the edge.

```
labelLayout(params) {
    return {
        x: params.rect.x + 10,
        y: params.rect.y + params.rect.height / 2,
        verticalAlign: 'middle',
        align: 'left'
    }
}
```

Set the text size based on the size of element bounding rectangle.

```
labelLayout(params) {
    return {
        fontSize: Math.max(params.rect.width / 10, 5)
    };
}
```""").tag(sync=True)
    
    labelLine = Dict(default_value=None, allow_none=True, help="""Since `v5.0.0`

Configuration of label guide line.""").tag(sync=True)
    
    data = Any(None, allow_none=True, help="""Data array of map series, which can be a single data value, like:

```
[12, 34, 56, 10, 23]
```

Or, if need extra dimensions for components like [visualMap](#visualMap) to map to graphic attributes like color, it can also be in the form of array. For example:

```
[[12, 14], [34, 50], [56, 30], [10, 15], [23, 10]]
```

In this case, we can assign the second value in each array item to [visualMap](#visualMap) component.

More likely, we need to assign name to each data item, in which case each item should be an object:

```
[{
    // name of date item
    name: 'data1',
    // value of date item is 8
    value: 10
}, {
    name: 'data2',
    value: 20
}]
```

Each data item can be further customized:

```
[{
    name: 'data1',
    value: 10
}, {
    // name of data item
    name: 'data2',
    value : 56,
    // user-defined label format that only useful for this data item
    label: {},
    // user-defined special itemStyle that only useful for this data item
    itemStyle:{}
}]
```""").tag(sync=True)
    
    markPoint = Dict(default_value=None, allow_none=True, help="""Mark point in a chart.""").tag(sync=True)
    
    markLine = Dict(default_value=None, allow_none=True, help="""Use a line in the chart to illustrate.""").tag(sync=True)
    
    markArea = Dict(default_value=None, allow_none=True, help="""Used to mark an area in chart. For example, mark a time interval.""").tag(sync=True)
    
    silent = Bool(None, allow_none=True, help="""Whether to ignore mouse events. Default value is false, for triggering and responding to mouse events.""").tag(sync=True)
    
    universalTransition = Dict(default_value=None, allow_none=True, help="""Since `v5.2.0`

Configuration related to universal transition animation.

Universal Transition provides the ability to morph between any series. With this feature enabled, each time `setOption`, transitions between series with the same `id` will be automatically associated with each other.

One-to-many or many-to-one animations such as drill-down, aggregation, etc. can also be achieved by specifying data items' `groupId` and `childGroupId`.

This can be enabled directly by configuring `universalTransition: true` in the series. It is also possible to provide an object for more detailed configuration.""").tag(sync=True)
    
    tooltip = Dict(default_value=None, allow_none=True, help="""tooltip settings in this series.""").tag(sync=True)
    
        
