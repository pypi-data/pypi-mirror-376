from __future__ import annotations

import re
from typing import Any


def is_minified_code(content: str, *, threshold: float = 0.1) -> bool:
    lines = content.split("\n")
    non_empty = [line for line in lines if line.strip()]
    if not non_empty:
        return False
    avg_len = sum(len(line) for line in non_empty) / len(non_empty)
    specials = sum(1 for line in non_empty if any(ch in line for ch in ["{", "}", ";"]))
    ratio = specials / len(non_empty)
    return avg_len > 200 and ratio > threshold


def is_generated_code(content: str, *, patterns: list[str] | None = None) -> bool:
    patterns = patterns or ["auto-generated", "do not edit", "generated by"]
    lower = content.lower()
    return any(pat in lower for pat in patterns)


def is_mostly_comments(content: str) -> bool:
    lines = content.split("\n")
    if not lines:
        return False
    comment_lines = [
        line for line in lines if line.strip().startswith(("#", "//", "/*", "--"))
    ]
    return len(comment_lines) / len(lines) > 0.6


def has_meaningful_names(content: str) -> bool:
    bad_names = ["tmp", "foo", "bar", "baz", "var", "data", "x", "y", "z"]
    text = content.lower()
    return not any(re.search(rf"\b{re.escape(n)}\b", text) for n in bad_names)


def determine_learning_level(complexity: int) -> str:
    if complexity < 2:
        return "beginner"
    if complexity < 6:
        return "intermediate"
    return "advanced"


def identify_programming_concepts(content: str) -> list[str]:
    concepts: list[str] = []
    lower = content.lower()
    for k in ["recursion", "memoization", "concurrency", "polymorphism", "inheritance"]:
        if k in lower:
            concepts.append(k)
    return concepts


def extract_element_context(content: str, element_type: str) -> dict[str, Any]:
    context: dict[str, Any] = {"element_type": element_type}
    if element_type in ["function", "method"]:
        context["has_return_statement"] = "return" in content
        context["param_count_estimate"] = (
            content.split("(", 1)[-1].split(")")[0].count(",") + 1
            if "(" in content and ")" in content
            else 0
        )
    elif element_type == "class":
        context["has_init"] = "__init__" in content
        context["method_count_estimate"] = content.count("def ")
    return context
