<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>SECS++ Rubik's Cube Solver</title>


<script src="https://cdn.tailwindcss.com"></script>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">

<style>

body {
  font-family: 'Orbitron', sans-serif;
  background-color: #0b1a13;
  color: #b2ffb2;
  margin: 0;
  padding: 0;
  min-height: 100vh;
}


.container-bg {
  background-color: #1a2d1d;
  box-shadow: 0 0 20px rgba(178,255,178,0.2);
}


.input-glow {
  border-color: #007f4a;
  box-shadow: 0 0 10px #00a37b;
  background-color: #082e1d;
  color: #ffffff;
}
.btn-base {
  transition: all 0.25s ease-in-out;
  border-radius: 9999px;
  text-shadow: 0 0 5px #000;
}
.btn-scramble {
  background: linear-gradient(45deg, #00ff00, #00ff8c);
  box-shadow: 0 0 15px #00ff00;
}
.btn-solve {
  background: linear-gradient(45deg, #00ffff, #00ff80);
  box-shadow: 0 0 15px #00ffff;
}
.btn-reset {
  background-color: #007f4a;
  box-shadow: 0 0 10px #00a37b;
}
.btn-base:hover {
  transform: scale(1.03);
  box-shadow: 0 0 20px #00ffff, 0 0 30px #00ff00;
}


.cube-face {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  grid-template-rows: repeat(3, 1fr);
  gap: 4px;
  width: 96px;
  height: 96px;
  perspective: 600px;
  padding: 6px;
  border-radius: 6px;
}


.sticker {
  width: 100%;
  height: 100%;
  border-radius: 4px;
  transition: transform 0.15s ease-in-out;
  box-shadow: inset 0 0 5px rgba(0,0,0,0.25);
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:10px;
  color:#000;
  font-weight:700;
}


.face-U { background-color: #ffb700; } 
.face-D { background-color: #f0f0f0; } 
.face-F { background-color: #0077ff; } 
.face-B { background-color: #ff3333; } 
.face-L { background-color: #00ff7f; } 
.face-R { background-color: #ff9100; } 


.message-box {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%,-50%);
  background-color: #1a2d1d;
  border: 2px solid #00ff00;
  padding: 1rem;
  border-radius: 0.5rem;
  box-shadow: 0 0 20px rgba(0,255,0,0.5);
  z-index: 1000;
}
.message-box-overlay {
  position: fixed;
  top:0; left:0; width:100%; height:100%;
  background-color: rgba(0,0,0,0.6);
  z-index: 999;
}
.loading-spinner {
  border: 4px solid rgba(255,255,255,0.1);
  border-top: 4px solid #00ff7f;
  border-radius: 50%;
  width: 28px;
  height: 28px;
  animation: spin 1s linear infinite;
}
@keyframes spin { 0%{transform:rotate(0)} 100%{transform:rotate(360deg)} }
</style>
</head>
<body class="p-8 flex flex-col items-center">

<div id="app" class="container-bg p-8 rounded-xl shadow-lg w-full max-w-3xl text-center">
  <h1 class="text-4xl font-bold mb-2 text-emerald-400">SECS++ Solver</h1>
  <p class="text-sm text-gray-400 mb-6">A Rubik's Cube solver with a custom A* search algorithm (visualizer).</p>


  <div id="cube-container" class="grid grid-cols-4 gap-2 mb-6 justify-items-center">
    <div class="col-start-2"><div id="U-face" class="cube-face shadow-inner rounded-md"></div></div>
    <div class="col-start-1"><div id="L-face" class="cube-face shadow-inner rounded-md"></div></div>
    <div><div id="F-face" class="cube-face shadow-inner rounded-md"></div></div>
    <div><div id="R-face" class="cube-face shadow-inner rounded-md"></div></div>
    <div class="col-start-4"><div id="B-face" class="cube-face shadow-inner rounded-md"></div></div>
    <div class="col-start-2"><div id="D-face" class="cube-face shadow-inner rounded-md"></div></div>
  </div>


  <div class="flex flex-col md:flex-row gap-4 mb-6">
    <input id="scramble-input" type="text" placeholder="Enter scramble moves (e.g., R U R')" class="flex-1 p-3 border rounded-lg focus:outline-none input-glow">
    <button id="scramble-btn" class="p-3 btn-base btn-scramble">Random Scramble</button>
    <button id="solve-btn" class="p-3 btn-base btn-solve">Solve Cube</button>
    <button id="reset-btn" class="p-3 btn-base btn-reset">Reset</button>
  </div>

  <div id="status-display" class="bg-gray-900 text-gray-300 p-4 rounded-lg mb-4 text-left font-mono">
    Status: Ready
  </div>
  <div id="solution-display" class="bg-gray-900 text-gray-300 p-4 rounded-lg text-left font-mono">
    Solution:
  </div>
</div>


<div id="message-box-container"></div>

<script>

function showMessage(message, type='info') {
  const container = document.getElementById('message-box-container');
  container.innerHTML = '';
  const overlay = document.createElement('div');
  overlay.className = 'message-box-overlay';
  const box = document.createElement('div');
  box.className = 'message-box flex flex-col items-center';
  const content = document.createElement('div');
  content.className = 'p-4 text-lg font-bold text-white';
  content.innerHTML = message.replace(/\n/g,'<br/>');
  box.appendChild(content);
  if (type === 'loading') {
    const spinner = document.createElement('div');
    spinner.className = 'loading-spinner mt-2';
    box.appendChild(spinner);
  }
  container.appendChild(overlay);
  container.appendChild(box);
  if (type !== 'loading') {
    overlay.addEventListener('click', ()=> container.innerHTML = '');
  }
}

function hideMessage() {
  document.getElementById('message-box-container').innerHTML = '';
}

const statusDisplay = document.getElementById('status-display');
const solutionDisplay = document.getElementById('solution-display');
const scrambleInput = document.getElementById('scramble-input');
const scrambleBtn = document.getElementById('scramble-btn');
const solveBtn = document.getElementById('solve-btn');
const resetBtn = document.getElementById('reset-btn');

function updateStatus(message) {
  statusDisplay.textContent = `Status: ${message}`;
}

let currentCubeState = {
  "U0":"U","U1":"U","U2":"U","U3":"U","U4":"U","U5":"U","U6":"U","U7":"U","U8":"U",
  "D0":"D","D1":"D","D2":"D","D3":"D","D4":"D","D5":"D","D6":"D","D7":"D","D8":"D",
  "F0":"F","F1":"F","F2":"F","F3":"F","F4":"F","F5":"F","F6":"F","F7":"F","F8":"F",
  "B0":"B","B1":"B","B2":"B","B3":"B","B4":"B","B5":"B","B6":"B","B7":"B","B8":"B",
  "L0":"L","L1":"L","L2":"L","L3":"L","L4":"L","L5":"L","L6":"L","L7":"L","L8":"L",
  "R0":"R","R1":"R","R2":"R","R3":"R","R4":"R","R5":"R","R6":"R","R7":"R","R8":"R"
};

const cubeFaces = ["U","L","F","R","B","D"];


function renderCube() {
  cubeFaces.forEach(faceKey => {
    const faceDiv = document.getElementById(`${faceKey}-face`);
    faceDiv.innerHTML = '';
    for (let i = 0; i < 9; i++) {
      const stickerDiv = document.createElement('div');
      stickerDiv.className = 'sticker';
      const colorLetter = currentCubeState[`${faceKey}${i}`];
      stickerDiv.classList.add(`face-${colorLetter}`);
      faceDiv.appendChild(stickerDiv);
    }
  });
}


function applyMoveToStateVisual(state, move) {
  const new_state = {...state};
  
  const side_map = {
    'U': [['F',[0,1,2]], ['R',[0,1,2]], ['B',[0,1,2]], ['L',[0,1,2]]],
    'D': [['F',[6,7,8]], ['L',[6,7,8]], ['B',[6,7,8]], ['R',[6,7,8]]],
    'F': [['U',[6,7,8]], ['R',[0,3,6]], ['D',[2,1,0]], ['L',[8,5,2]]],
    'B': [['U',[2,1,0]], ['L',[0,3,6]], ['D',[6,7,8]], ['R',[8,5,2]]],
    'L': [['U',[0,3,6]], ['F',[0,3,6]], ['D',[0,3,6]], ['B',[8,5,2]]],
    'R': [['U',[8,5,2]], ['B',[0,3,6]], ['D',[8,5,2]], ['F',[8,5,2]]]
  };

  const rotations = [[0,2,8,6],[1,5,7,3]]; 

  function rotateFace(face_key, times=1) {
    
    for (let t=0; t<times; t++) {
    
      const c = rotations[0];
      const tmpCorner = new_state[`${face_key}${c[3]}`];
      for (let i=3;i>0;i--) new_state[`${face_key}${c[i]}`] = new_state[`${face_key}${c[i-1]}`];
      new_state[`${face_key}${c[0]}`] = tmpCorner;
      
      const e = rotations[1];
      const tmpEdge = new_state[`${face_key}${e[3]}`];
      for (let i=3;i>0;i--) new_state[`${face_key}${e[i]}`] = new_state[`${face_key}${e[i-1]}`];
      new_state[`${face_key}${e[0]}`] = tmpEdge;
    }
  }

  function rotateSides(face_key, times=1) {
    
    const sequence = side_map[face_key];
    for (let t=0;t<times;t++) {
      const temp = sequence[3][1].map(i => new_state[`${sequence[3][0]}${i}`]);
    
      for (let i=3;i>0;i--) {
        const [toFace,toIdx] = sequence[i];
        const [fromFace,fromIdx] = sequence[i-1];
        for (let j=0;j<3;j++) new_state[`${toFace}${toIdx[j]}`] = new_state[`${fromFace}${fromIdx[j]}`];
      }
      const [firstFace, firstIdx] = sequence[0];
      for (let j=0;j<3;j++) new_state[`${firstFace}${firstIdx[j]}`] = temp[j];
    }
  }

  const face_key = move[0];
  if (move.length === 1) { 
    rotateFace(face_key,1);
    rotateSides(face_key,1);
  } else if (move[1] === "'") { 
    rotateFace(face_key,3); 
    rotateSides(face_key,3);
  } else if (move[1] === '2') {
    rotateFace(face_key,2);
    rotateSides(face_key,2);
  }
  return new_state;
}


async function applyMovesToCubeVisual(moves, delay=120) {
  for (const move of moves) {
    updateStatus(`Applying move: ${move}`);
    currentCubeState = applyMoveToStateVisual(currentCubeState, move);
    renderCube();
    await new Promise(r => setTimeout(r, delay));
  }
}

scrambleBtn.addEventListener('click', async () => {

  showMessage("Generating scramble...", 'loading');


  try {
    const resp = await fetch('/api/scramble', { method: 'GET' });
    if (resp.ok) {
      const data = await resp.json();
      hideMessage();
      const scramble = Array.isArray(data.scramble) ? data.scramble : (data.scramble || []).join(' ');
      const scrambleString = Array.isArray(data.scramble) ? data.scramble.join(' ') : scramble;
      scrambleInput.value = scrambleString;

      resetCubeToSolved();
      await applyMovesToCubeVisual(scrambleString.split(/\s+/).filter(s=>s.length));
      updateStatus("Cube Scrambled! Now click 'Solve Cube'.");
      return;
    }

  } catch (e) {

  }

  const faces = ['R','L','U','D','F','B'];
  const suffixes = ["","'","2"];
  const moves = [];
  let last = null;
  for (let i=0;i<20;i++) {
    let f = faces[Math.floor(Math.random()*faces.length)];

    if (f === last) { i--; continue; }
    last = f;
    const s = suffixes[Math.floor(Math.random()*suffixes.length)];
    moves.push(f + s);
  }
  hideMessage();
  scrambleInput.value = moves.join(' ');
  resetCubeToSolved();
  await applyMovesToCubeVisual(moves);
  updateStatus("Cube Scrambled! Now click 'Solve Cube'.");
});

solveBtn.addEventListener('click', async () => {
  const scrambleString = scrambleInput.value.trim();
  if (!scrambleString) { showMessage("Please enter a scramble or click 'Random Scramble' first."); return; }

  showMessage("Solving...", 'loading');
  solveBtn.disabled = true; scrambleBtn.disabled = true; resetBtn.disabled = true;

  const scrambleMoves = scrambleString.split(/\s+/).filter(m=>m);
  try {

    const resp = await fetch('/solve', {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({ scrambleMoves })
    });

    if (!resp.ok) {
      hideMessage();
      solutionDisplay.textContent = `Error: Solver endpoint returned ${resp.status}`;
      updateStatus("❌ Failed to find a solution.");
      return;
    }
    const data = await resp.json();
    hideMessage();
    const solution = data.solution || [];
    solutionDisplay.textContent = `Solution (${solution.length} moves):\n${solution.join(' ')}`;
    updateStatus("Applying solution...");
    await applyMovesToCubeVisual(solution, 120);
    updateStatus("✅ Cube Solved!");
  } catch (err) {
    hideMessage();
    solutionDisplay.textContent = `Error: ${err.message}`;
    updateStatus("❌ An error occurred during the request.");
  } finally {
    solveBtn.disabled = false; scrambleBtn.disabled = false; resetBtn.disabled = false;
  }
});

resetBtn.addEventListener('click', () => {
  resetCubeToSolved();
  renderCube();
  scrambleInput.value = '';
  solutionDisplay.textContent = 'Solution:';
  updateStatus("Cube has been reset to its solved state.");
});

function resetCubeToSolved() {
  currentCubeState = {
    "U0":"U","U1":"U","U2":"U","U3":"U","U4":"U","U5":"U","U6":"U","U7":"U","U8":"U",
    "D0":"D","D1":"D","D2":"D","D3":"D","D4":"D","D5":"D","D6":"D","D7":"D","D8":"D",
    "F0":"F","F1":"F","F2":"F","F3":"F","F4":"F","F5":"F","F6":"F","F7":"F","F8":"F",
    "B0":"B","B1":"B","B2":"B","B3":"B","B4":"B","B5":"B","B6":"B","B7":"B","B8":"B",
    "L0":"L","L1":"L","L2":"L","L3":"L","L4":"L","L5":"L","L6":"L","L7":"L","L8":"L",
    "R0":"R","R1":"R","R2":"R","R3":"R","R4":"R","R5":"R","R6":"R","R7":"R","R8":"R"
  };
}

window.addEventListener('DOMContentLoaded', () => {
  renderCube();
  updateStatus("Ready to scramble and solve.");
});
</script>
</body>
</html>
