Metadata-Version: 2.4
Name: identityservice-pythonsdk
Version: 1.0.7
Summary: Python SDK for IdentityService integration with multi-tenant authentication, JWT management, and gRPC services
Author: D3 Security
Author-email: IdentityService Team <support@identityservice.com>
Maintainer-email: IdentityService Team <support@identityservice.com>
License: MIT License
        
        Copyright (c) 2025 D3 Security
        
        Permission is hereby granted, free of charge, to any person obtaining a copy
        of this software and associated documentation files (the "Software"), to deal
        in the Software without restriction, including without limitation the rights
        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        copies of the Software, and to permit persons to whom the Software is
        furnished to do so, subject to the following conditions:
        
        The above copyright notice and this permission notice shall be included in all
        copies or substantial portions of the Software.
        
        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
        SOFTWARE.
Keywords: authentication,jwt,etcd,identity,security,multi-tenant
Classifier: Development Status :: 5 - Production/Stable
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Classifier: Topic :: Security :: Cryptography
Classifier: Topic :: System :: Distributed Computing
Requires-Python: >=3.8
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: cryptography>=41.0.0
Requires-Dist: PyJWT>=2.8.0
Requires-Dist: etcd3>=0.12.0
Requires-Dist: aiohttp>=3.9.0
Requires-Dist: pydantic>=2.5.0
Requires-Dist: dataclasses-json>=0.6.0
Requires-Dist: python-dateutil>=2.8.0
Requires-Dist: typing-extensions>=4.0.0
Requires-Dist: grpcio>=1.60.0
Requires-Dist: grpcio-tools>=1.60.0
Requires-Dist: googleapis-common-protos>=1.62.0
Provides-Extra: dev
Requires-Dist: pytest>=7.0.0; extra == "dev"
Requires-Dist: pytest-asyncio>=0.21.0; extra == "dev"
Requires-Dist: pytest-mock>=3.10.0; extra == "dev"
Requires-Dist: black>=23.0.0; extra == "dev"
Requires-Dist: isort>=5.12.0; extra == "dev"
Requires-Dist: mypy>=1.0.0; extra == "dev"
Provides-Extra: fastapi
Requires-Dist: fastapi>=0.100.0; extra == "fastapi"
Provides-Extra: redis
Requires-Dist: redis>=5.0.0; extra == "redis"
Provides-Extra: grpc
Requires-Dist: grpcio>=1.60.0; extra == "grpc"
Requires-Dist: grpcio-tools>=1.60.0; extra == "grpc"
Requires-Dist: googleapis-common-protos>=1.62.0; extra == "grpc"
Provides-Extra: all
Requires-Dist: identityservice-pythonsdk[dev,fastapi,grpc,redis]; extra == "all"
Dynamic: author
Dynamic: license-file
Dynamic: requires-python

# IdentityService Python SDK

Python SDK for IdentityService integration, providing multi-tenant authentication, JWT token management, and distributed configuration management.

## Features

- **Ed25519 JWT Authentication**: Modern cryptographic signatures for enhanced security
- **Multi-tenant Support**: Tenant-specific configuration and key management
- **Real-time Configuration**: Live configuration updates via etcd watching
- **Service Registration**: Automatic service discovery and health monitoring
- **High-performance Caching**: Memory and Redis-based caching with TTL
- **Framework Integration**: FastAPI and gRPC middleware for seamless integration
- **gRPC TestConnection Service**: Built-in TestConnection service for service health checks
- **Comprehensive Security**: Key rotation, rate limiting, and audit logging

## Installation

```bash
# Install from PyPI
pip install identityservice-pythonsdk==1.0.6

# Or install from source
pip install -e .
```

### Requirements

- Python 3.8+
- etcd cluster (for distributed configuration)
- Redis (optional, for caching)

## Quick Start

### 1. Environment Configuration

Set the following environment variables:

```bash
export D3_TENANT_GUID="your-tenant-guid"
export D3_API_KEY="your-tenant-api-key"
export ETCD_ENDPOINTS="etcd1:2379,etcd2:2379,etcd3:2379"
export SERVICE_NAME="YourService"
```

### 2. Basic Usage

```python
import asyncio
from d3_identity_client import D3IdentityClient

async def main():
    # Create and initialize client
    async with D3IdentityClient() as client:
        # Get tenant information
        tenant_info = await client.get_tenant_info()
        print(f"Tenant: {tenant_info.tenant_name}")
        
        # Generate service token
        token = await client.generate_service_token(
            service_name="MyService",
            permissions=["read", "write"]
        )
        
        # Validate token
        result = await client.validate_token(token)
        if result.is_valid:
            print(f"Token valid for tenant: {result.claims.tenant_name}")

if __name__ == "__main__":
    asyncio.run(main())
```

### 3. FastAPI Integration

```python
from fastapi import FastAPI, Depends
from d3_identity_client import D3IdentityClient, create_service_auth_dependency

app = FastAPI()

# Initialize client (do this at startup)
identity_client = None

@app.on_event("startup")
async def startup():
    global identity_client
    identity_client = await create_client()

@app.on_event("shutdown") 
async def shutdown():
    if identity_client:
        await identity_client.cleanup()

# Create authentication dependency
auth_required = create_service_auth_dependency(
    identity_client.auth_service,
    required_service="MyService"
)

@app.get("/protected")
async def protected_endpoint(auth_context=auth_required):
    return {
        "message": "Success",
        "tenant": auth_context.tenant_name,
        "service": auth_context.get_service_name()
    }
```

### 4. gRPC TestConnection Integration

Add TestConnection service to your existing CommandService gRPC server:

```python
import grpc
from concurrent import futures
from d3_identity_client import D3IdentityClient, IdentityServiceOptions
from d3_identity_client.controllers.grpc_controller import (
    TestConnectionGrpcServicer,
    add_servicer_to_server
)

async def integrate_with_command_service():
    # Initialize identity client
    config = IdentityServiceOptions(
        tenant_guid="your-tenant-guid",
        tenant_api_key="your-api-key",
        etcd_endpoints=["localhost:2379"],
        service_name="CommandService"
    )
    
    identity_client = D3IdentityClient(config)
    await identity_client.initialize()
    
    # Create your existing gRPC server
    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
    
    # Add your existing services
    # your_pb2_grpc.add_YourServiceServicer_to_server(YourServicer(), server)
    
    # Add TestConnection service to the SAME server
    test_servicer = TestConnectionGrpcServicer(
        identity_client.auth_service,
        identity_client.tenant_service
    )
    add_servicer_to_server(test_servicer, server)
    
    # Start on port 50051 (same port as your existing services)
    server.add_insecure_port('[::]:50051')
    server.start()
    
    print("âœ… CommandService with TestConnection running on port 50051")
    return server, identity_client

# Usage
server, client = await integrate_with_command_service()
```

**Call TestConnection from other services:**

```python
import grpc
from protos import test_connection_pb2, test_connection_pb2_grpc

# Connect to CommandService (same port for all services)
channel = grpc.insecure_channel('localhost:50051')
stub = test_connection_pb2_grpc.TestConnectionGrpcServiceStub(channel)

# Call TestConnection with JWT authentication
metadata = [('authorization', 'Bearer your-jwt-token')]
request = test_connection_pb2.TestConnectionRequest()
response = stub.TestConnection(request, metadata=metadata)

print(f"Tenant: {response.TenantName}")
print(f"Status: {response.Status.message}")
```

## Configuration

### Environment Variables

| Variable | Description | Default |
|----------|-------------|---------|
| `D3_TENANT_GUID` | Tenant GUID | Required |
| `D3_API_KEY` | Tenant API key | Required |
| `ETCD_ENDPOINTS` | etcd endpoints (comma-separated) | `localhost:2379` |
| `ETCD_USERNAME` | etcd authentication username | None |
| `ETCD_PASSWORD` | etcd authentication password | None |
| `CACHE_TYPE` | Cache type: `memory`, `redis`, `hybrid` | `memory` |
| `REDIS_HOST` | Redis host for caching | `localhost` |
| `REDIS_PORT` | Redis port | `6379` |
| `SERVICE_NAME` | Service name for registration | None |
| `LOG_LEVEL` | Logging level | `INFO` |

### Programmatic Configuration

```python
from d3_identity_client import IdentityServiceOptions, create_production_config

config = create_production_config(
    tenant_guid="your-tenant-guid",
    api_key="your-api-key",
    service_name="YourService",
    etcd_endpoints=["etcd1:2379", "etcd2:2379"],
    redis_host="redis.example.com"
)

client = D3IdentityClient(config)
```

## Advanced Usage

### Tenant Watching

Monitor tenant configuration changes in real-time:

```python
async def tenant_change_callback(tenant_info):
    print(f"Tenant configuration updated: {tenant_info.tenant_name}")
    # Update application configuration based on tenant changes

await client.watch_tenant(tenant_guid, tenant_change_callback)
```

### Service Discovery

Register and discover internal services:

```python
# Register service
await client.register_internal_service(
    service_name="MyService",
    service_endpoints={
        "http": "http://myservice:8080",
        "grpc": "grpc://myservice:50051"
    }
)

# Discover services
services = await client.get_all_internal_services()
command_service = services.get("CommandService")
if command_service:
    http_endpoint = command_service.get_endpoint("http")
```

### Custom Authentication

Implement custom authentication logic:

```python
from d3_identity_client import AuthService

async def custom_auth_handler(token: str):
    # Validate token
    context = await client.authenticate_token(token)
    
    if not context:
        raise AuthenticationError("Invalid token")
    
    # Check custom business rules
    if not context.token_claims.has_permission("custom_action"):
        raise AuthorizationError("Insufficient permissions")
    
    return context
```

### Multi-tenant Operations

Work with multiple tenants:

```python
# Get multiple tenants
tenant_guids = ["guid1", "guid2", "guid3"]
tenants = await client.get_multiple_tenants(tenant_guids)

for guid, tenant in tenants.items():
    if tenant and tenant.is_active_tenant():
        print(f"Active tenant: {tenant.tenant_name}")
```

## Security Features

### Key Rotation

The client automatically handles key rotation:

```python
# Keys are automatically rotated by the Identity Service
# Client handles both current and previous keys for validation
# No manual intervention required
```

### Rate Limiting

Configure tenant-specific rate limiting:

```python
tenant_info = await client.get_tenant_info()
api_limit = tenant_info.get_rate_limit_config("api_requests")

if api_limit:
    print(f"API rate limit: {api_limit.max_requests_per_minute()}/minute")
```

### Permissions

Check permissions in your application:

```python
async def check_permissions(auth_context, required_permission):
    if not await client.auth_service.check_permission(auth_context, required_permission):
        raise PermissionError(f"Permission '{required_permission}' required")
```

## Health Monitoring

Monitor client health:

```python
@app.get("/health")
async def health_check():
    health_status = await client.health_check()
    
    if health_status["status"] == "healthy":
        return {"status": "OK", "details": health_status}
    else:
        raise HTTPException(status_code=503, detail="Service unhealthy")
```

## Error Handling

The client provides comprehensive error handling:

```python
from d3_identity_client import TokenValidationResult

async def safe_token_validation(token: str):
    try:
        result = await client.validate_token(token)
        
        if result.is_valid:
            return result.claims
        else:
            logger.warning(f"Token validation failed: {result.error_message}")
            return None
            
    except Exception as e:
        logger.error(f"Token validation error: {e}")
        return None
```

## Development Mode

For development and testing:

```python
from d3_identity_client import create_development_config

config = create_development_config(
    tenant_guid="dev-tenant-guid",
    api_key="dev-api-key",
    service_name="DevService"
)

config.debug_mode = True
config.logging.log_level = LogLevel.DEBUG

client = D3IdentityClient(config)
```

## Testing

Mock the client for unit testing:

```python
import pytest
from unittest.mock import AsyncMock

@pytest.fixture
async def mock_client():
    client = AsyncMock(spec=D3IdentityClient)
    client.authenticate_token.return_value = AuthenticationContext(...)
    return client
```

## Migration from Legacy Authentication

Replace existing JWT authentication:

```python
# Before (legacy)
def verify_jwt_token(token):
    return jwt.decode(token, secret_key, algorithms=["HS256"])

# After (D3 Identity Service)
async def verify_jwt_token(token):
    result = await client.validate_token(token)
    return result.claims if result.is_valid else None
```

## Performance Considerations

- **Caching**: Enable Redis caching for production deployments
- **Connection Pooling**: Client automatically manages etcd connections
- **Token Caching**: JWT validation results are cached for performance
- **Batch Operations**: Use `get_multiple_tenants()` for bulk operations

## Troubleshooting

### Common Issues

1. **etcd Connection Failed**
   ```python
   # Check etcd endpoints and credentials
   health = await client.health_check()
   print(health["etcd"])
   ```

2. **Token Validation Failures**
   ```python
   # Check token format and expiration
   token_info = await client.jwt_service.get_token_info(token)
   print(f"Token expires: {token_info['expires_at']}")
   ```

3. **Tenant Not Found**
   ```python
   # Verify tenant GUID and status
   tenant = await client.get_tenant_info()
   if tenant:
       print(f"Tenant status: {tenant.status}")
   ```

### Debug Logging

Enable debug logging for detailed information:

```python
import logging
logging.getLogger("d3_identity_client").setLevel(logging.DEBUG)
```

## Support

For issues and questions:
- Check the [troubleshooting guide](docs/troubleshooting.md)
- Review [API documentation](docs/api.md)
- Submit issues on GitHub

## License

MIT License - see LICENSE file for details.
