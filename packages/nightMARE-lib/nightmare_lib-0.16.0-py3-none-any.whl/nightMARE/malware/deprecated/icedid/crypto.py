# coding: utf-8

import typing

from nightMARE.core import bits

KEY_LENGTH = 16
HASH_LENGTH = 4
CRYPTO_DATA_SIZE = 20


def __parse_key(data: bytes) -> list[int]:
    """
    Parse a byte sequence into a list of 32-bit integers to form a decryption key.

    :param data: The byte sequence containing the key data (expected to be at least KEY_LENGTH bytes).
    :return: A list of integers, each representing a 32-bit portion of the key.
    """

    key: list[int] = []
    for offset in range(0, KEY_LENGTH, 4):
        key.append(int.from_bytes(data[offset : offset + 4], "little"))
    return key


def __parse_integrity_hash(data: bytes, key: int) -> int:
    """
    Compute an integrity hash from a byte sequence by XORing it with a key value.

    :param data: The byte sequence to compute the hash from (typically HASH_LENGTH bytes).
    :param key: An integer key used to XOR the data.
    :return: The computed integrity hash as an integer.
    """

    return int.from_bytes(data, "little") ^ key


def __decrypt_aux(encrypted_data: bytes, key: list[int]) -> bytes:
    """
    Decrypt a byte sequence using a dynamic XOR-based algorithm with a rotating key.

    :param encrypted_data: The encrypted byte sequence to decrypt.
    :param key: A list of integers used as the decryption key, modified in-place during decryption.
    :return: The decrypted data as a byte sequence.
    """

    decrypted_data = bytearray([0 for _ in range(len(encrypted_data))])

    for i, x in enumerate(encrypted_data):
        index_0 = i & (len(key) - 1)
        index_1 = (i + 1) & (len(key) - 1)
        decrypted_data[i] = (x ^ (key[index_0] + key[index_1])) & 0xFF
        key[index_0] = bits.ror32(key[index_0], key[index_1] & 7) + 1
        key[index_1] = bits.ror32(key[index_1], key[index_0] & 7) + 1

    return bytes(decrypted_data)


def __check_integrity(decrypted_data: bytes, integrity_hash: int) -> bool:
    """
    Verify the integrity of decrypted data by computing a rolling hash and comparing it to a given value.

    :param decrypted_data: The decrypted byte sequence to check.
    :param integrity_hash: The expected hash value to compare against.
    :return: True if the computed hash matches the integrity_hash, False otherwise.
    """

    hash = 0
    for x in decrypted_data:
        hash = bits.rol32(x + hash, 3)
    return hash == integrity_hash


def decrypt_0(
    encrypted_data: bytes, check_integrity: bool = True
) -> typing.Optional[bytes]:
    """
    Decrypt ICEDID's encrypted data, optionally verifying its integrity.

    :param encrypted_data: ICEDID's encrypted data, including key and hash information at the end.
    :param check_integrity: Flag to enable/disable data integrity check after decryption (default: True).
    :return: The decrypted data as bytes if successful and integrity check passes (if enabled), None otherwise.
    """

    encrypted_data = bytearray(encrypted_data)

    crypto_data = encrypted_data[len(encrypted_data) - CRYPTO_DATA_SIZE :]
    encrypted_data = encrypted_data[: len(encrypted_data) - CRYPTO_DATA_SIZE]

    key = __parse_key(crypto_data[HASH_LENGTH:])
    integrity_hash = __parse_integrity_hash(crypto_data[:HASH_LENGTH], key[0])
    decrypted_data = __decrypt_aux(encrypted_data, key)

    return (
        decrypted_data
        if (not check_integrity or __check_integrity(decrypted_data, integrity_hash))
        else None
    )


def decrypt_1(encrypted_data: bytes) -> typing.Optional[bytes]:
    """
    Decrypt ICEDID's encrypted data from a forked-variant loader using a 64-bit key.

    :param encrypted_data: ICEDID's encrypted data, expected to be at least 128 bytes (64 bytes data + 64 bytes key).
    :return: The decrypted data as bytes, derived by XORing the first 64 bytes with the subsequent 64 bytes.
    """

    decrypted_data = bytearray()
    for i in range(len(encrypted_data[:64])):
        decrypted_data.append(encrypted_data[i] ^ encrypted_data[i + 64])

    return bytes(decrypted_data)
