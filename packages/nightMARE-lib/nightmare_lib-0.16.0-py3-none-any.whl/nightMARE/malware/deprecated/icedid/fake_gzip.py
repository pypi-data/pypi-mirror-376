# coding: utf-8

import construct

from nightMARE.malware.deprecated.icedid import crypto

MINIMUM_SIZE = 1024
MAGIC = 0x8B1F
FILENAME_OFFSET = 10


class FakeGzip(object):
    """
    ICEDID FakeGzip parser.

    This class parses a fake Gzip structure used by ICEDID malware, extracting configuration,
    core binary, and stage 2 payload data from an encrypted payload.
    """

    FakeGzipStruct = construct.Struct(
        "flag" / construct.Int8ul,
        "is_dll" / construct.Int8ul,
        "core_size" / construct.Int32ul,
        "stage_2_size" / construct.Int32ul,
        "core_directory" / construct.Array(32, construct.Int8ul),
        "core_filename" / construct.Array(32, construct.Int8ul),
        "stage_2_filename" / construct.Array(32, construct.Int8ul),
        "encrypted_configuration" / construct.Array(604, construct.Int8ul),
        "encrypted_core_and_stage_2"
        / construct.Array(
            construct.this.core_size + construct.this.stage_2_size, construct.Int8ul
        ),
    )

    def __check_data(self, data: bytes) -> None:
        """
        Validate the input data for minimum size and magic number.

        :param data: The raw byte data to check.
        :raise RuntimeError: If the data is too small or has an invalid magic number.
        """

        if len(data) < MINIMUM_SIZE:
            raise RuntimeError("Data is too small")

        if MAGIC != int.from_bytes(data[:2], "little"):
            raise RuntimeError("Bad magic")

    def __get_offset_to_payload(self, data: bytes) -> int:
        """
        Calculate the offset to the encrypted payload by finding the end of a null-terminated string.

        :param data: The raw byte data containing the payload.
        :return: The offset to the start of the encrypted payload.
        """

        offset = FILENAME_OFFSET
        while 0 != data[offset]:
            offset += 1
        return offset + 1

    def __repr__(self) -> str:
        """
        Provide a string representation of the FakeGzip object.

        :return: A formatted string describing the DLL status, core, and stage 2 details.
        """

        output = "is_dll: {}\n".format(self.is_dll)
        output += "core: {}/{} ({} bytes)\n".format(
            self.core_directory, self.core_filename, self.core_size
        )
        output += "stage_2: {} ({} bytes)".format(
            self.stage_2_filename, self.stage_2_size
        )
        return output

    def __init__(self, data: bytes) -> None:
        """
        Initialize the FakeGzip parser with raw binary data.

        :param data: The raw bytes containing the fake Gzip structure.
        :raise RuntimeError: If data validation fails or decryption of the payload fails.
        """

        self.__check_data(data)

        # TODO: Fix check_integrity=False
        encrypted_payload = data[self.__get_offset_to_payload(data) : -4]
        decrypted_payload = crypto.decrypt_0(encrypted_payload, check_integrity=False)
        if not decrypted_payload:
            raise RuntimeError("Failed to decrypt payload")

        self.__fake_gzip = self.FakeGzipStruct.parse(decrypted_payload)

    @property
    def configuration(self) -> bytes:
        """
        Get the encrypted configuration data.

        :return: The configuration as a byte sequence.
        """

        return bytes(self.__fake_gzip.encrypted_configuration)

    @property
    def core(self) -> bytes:
        """
        Get the core binary data.

        :return: The core binary as a byte sequence.
        """

        return bytes(
            self.__fake_gzip.encrypted_core_and_stage_2[: self.__fake_gzip.core_size]
        )

    @property
    def core_directory(self) -> str:
        """
        Get the core directory name.

        :return: The core directory as a UTF-8 string with null bytes stripped.
        """

        return str(bytes(self.__fake_gzip.core_directory), "utf-8").strip("\x00")

    @property
    def core_filename(self) -> bytes:
        """
        Get the core filename.

        :return: The core filename as a UTF-8 string with null bytes and backslashes stripped.
        """

        return (
            str(bytes(self.__fake_gzip.core_filename), "utf-8")
            .strip("\x00")
            .strip("\\")
        )

    @property
    def core_size(self) -> int:
        """
        Get the size of the core binary.

        :return: The size of the core binary in bytes.
        """

        return self.__fake_gzip.core_size

    @property
    def is_dll(self) -> bool:
        """
        Check if the core binary is a DLL.

        :return: True if the core is a DLL, False otherwise.
        """

        return bool(self.__fake_gzip.is_dll)

    @property
    def stage_2(self) -> bytes:
        """
        Get the stage 2 payload data.

        :return: The stage 2 payload as a byte sequence.
        """

        return bytes(
            self.__fake_gzip.encrypted_core_and_stage_2[self.__fake_gzip.core_size :]
        )

    @property
    def stage_2_filename(self) -> bytes:
        """
        Get the stage 2 filename.

        :return: The stage 2 filename as a UTF-8 string with null bytes stripped.
        """

        return str(bytes(self.__fake_gzip.stage_2_filename), "utf-8").strip("\x00")

    @property
    def stage_2_size(self) -> int:
        """
        Get the size of the stage 2 payload.

        :return: The size of the stage 2 payload in bytes.
        """

        return self.__fake_gzip.stage_2_size
