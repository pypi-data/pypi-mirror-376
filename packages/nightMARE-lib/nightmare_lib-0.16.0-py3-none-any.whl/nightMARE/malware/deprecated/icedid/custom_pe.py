from __future__ import annotations

import lief
import construct
import ctypes

from nightMARE.malware.deprecated.icedid import windows
from nightMARE.malware.deprecated.icedid import common

OFFSET_TO_NAME = 2
SIZEOF_IMAGE_BASE_RELOCATION = 8


def protection_to_lief_section_characteristics(
    protection: int,
) -> lief.PE.SECTION_CHARACTERISTICS:
    """
    Convert Windows memory protection constants to LIEF PE section characteristics.

    :param protection: A Windows memory protection constant (e.g., PAGE_READONLY).
    :return: Corresponding LIEF PE section characteristics flags.
    """

    match protection:
        case windows.PAGE_READONLY:
            return lief.PE.SECTION_CHARACTERISTICS.MEM_READ
        case windows.PAGE_READWRITE:
            return (
                lief.PE.SECTION_CHARACTERISTICS.MEM_READ
                | lief.PE.SECTION_CHARACTERISTICS.MEM_WRITE
            )
        case windows.PAGE_EXECUTE_READ:
            return (
                lief.PE.SECTION_CHARACTERISTICS.MEM_READ
                | lief.PE.SECTION_CHARACTERISTICS.MEM_EXECUTE
            )
        case windows.PAGE_EXECUTE_READWRITE:
            return (
                lief.PE.SECTION_CHARACTERISTICS.MEM_READ
                | lief.PE.SECTION_CHARACTERISTICS.MEM_WRITE
                | lief.PE.SECTION_CHARACTERISTICS.MEM_EXECUTE
            )


class CustomPE(object):
    """
    ICEDID's custom PE format parser.

    This class parses a custom PE format used by ICEDID malware, supporting two variants (V0 and V1),
    and provides methods to reconstruct it into a standard PE binary using LIEF.
    """

    CustomPESection = construct.Struct(
        "virtual_address" / construct.Int32ul,
        "virtual_size" / construct.Int32ul,
        "raw_offset" / construct.Int32ul,
        "raw_size" / construct.Int32ul,
        "protection" / construct.Int8ul,
    )

    CustomPEV0 = construct.Struct(
        "imagebase" / construct.Int32ul,
        "field_4" / construct.Int32ul,
        "size" / construct.Int32ul,
        "entrypoint" / construct.Int32ul,
        "import_va" / construct.Int32ul,
        "reloc_va" / construct.Int32ul,
        "reloc_size" / construct.Int32ul,
        "field_1c" / construct.Int32ul,
        "n_sections" / construct.Int32ul,
        "sections" / construct.Array(construct.this.n_sections, CustomPESection),
    )

    CustomPEV1 = construct.Struct(
        "imagebase" / construct.Int64ul,
        "size" / construct.Int32ul,
        "entrypoint" / construct.Int32ul,
        "import_va" / construct.Int32ul,
        "reloc_va" / construct.Int32ul,
        "reloc_size" / construct.Int32ul,
        "n_sections" / construct.Int32ul,
        "sections" / construct.Array(construct.this.n_sections, CustomPESection),
    )

    def __init__(self, data: bytes) -> None:
        """
        Initialize the CustomPE parser with raw binary data.

        :param data: The raw bytes of the custom PE format to parse.
        :raise RuntimeError: If neither CustomPEV0 nor CustomPEV1 can parse the data.
        """

        self.__content = data

        self.structure = None
        for parser in [CustomPE.CustomPEV0, CustomPE.CustomPEV1]:
            try:
                self.structure = parser.parse(data)
                break
            except Exception:
                continue
        else:
            raise RuntimeError("Failed to parse custom pe")

        self.__is_32 = 0 == 0xFFFFFFFF00000000 & self.structure.imagebase

    def __set_header(self, pe: lief.PE.Binary) -> lief.PE.Binary:
        """
        Set the PE header fields in a LIEF PE binary based on the parsed custom PE structure.

        :param pe: The LIEF PE binary object to modify.
        :return: The modified LIEF PE binary with updated header fields.
        """

        # Hack to fix lief behavior
        pe.header.sizeof_optional_header = 0xE0 if self.__is_32 else 0xF0
        # !

        pe.optional_header.imagebase = self.structure.imagebase
        pe.optional_header.addressof_entrypoint = self.structure.entrypoint

        pe.data_directories[lief.PE.DATA_DIRECTORY.IMPORT_TABLE].rva = (
            self.structure.import_va
        )

        pe.data_directories[lief.PE.DATA_DIRECTORY.BASE_RELOCATION_TABLE].rva = (
            self.structure.reloc_va
        )

        pe.data_directories[lief.PE.DATA_DIRECTORY.BASE_RELOCATION_TABLE].size = (
            self.structure.reloc_size
        )

        return pe

    def __add_sections(self, pe: lief.PE.Binary) -> lief.PE.Binary:
        """
        Add sections to a LIEF PE binary based on the parsed custom PE sections.

        :param pe: The LIEF PE binary object to modify.
        :return: The modified LIEF PE binary with added sections.
        """

        for i, custom_section in enumerate(self.structure.sections):
            section = lief.PE.Section(f".mare{i}")
            section.virtual_address = custom_section.virtual_address
            section.virtual_size = custom_section.virtual_size
            section.characteristics = protection_to_lief_section_characteristics(
                custom_section.protection
            )

            section.content = list(
                self.__content[
                    custom_section.raw_offset : custom_section.raw_offset
                    + custom_section.raw_size
                ]
            )

            pe.add_section(section, lief.PE.SECTION_TYPES.DATA)
        return pe

    @property
    def content(self) -> bytes:
        """
        Get the raw content of the custom PE.

        :return: The original byte data passed to the constructor.
        """

        return self.__content

    @property
    def is_32(self) -> bool:
        """
        Check if the custom PE is a 32-bit binary.

        :return: True if the PE is 32-bit, False if 64-bit.
        """

        return self.__is_32

    def to_pe(self) -> lief.PE.Binary:
        """
        Build a LIEF PE binary from the parsed custom PE format.

        :return: Reconstructed LIEF PE binary object representing the custom PE.
        """

        pe = lief.PE.Binary(
            "icedid",
            lief.PE.PE_TYPE.PE32 if self.__is_32 else lief.PE.PE_TYPE.PE32_PLUS,
        )
        return self.__add_sections(self.__set_header(pe))


class Loader(object):
    """
    ICEDID custom PE loader.

    Will map binary into current process, resolve imports and apply relocations.
    This class loads a CustomPE instance into memory, handling memory allocation,
    import resolution, and relocation application.
    """

    def __init__(self, custom_pe: CustomPE) -> None:
        """
        Initialize the loader with a CustomPE instance.

        :param custom_pe: The CustomPE object to load into memory.
        """

        self.__custom_pe = custom_pe
        self.__base_address = 0

        self.__map()
        self.__resolve_imports()
        self.__apply_relocations()

    def __apply_relocations_aux(self, relocations_address: int) -> None:
        """
        Apply relocations to the loaded binary starting at a given address.

        :param relocations_address: The memory address where relocation data begins.
        """

        while True:
            relocations = ctypes.cast(
                relocations_address, ctypes.POINTER(windows.IMAGE_BASE_RELOCATION)
            ).contents

            if not relocations.SizeOfBlock:
                break

            for address in range(
                relocations_address + SIZEOF_IMAGE_BASE_RELOCATION,
                relocations_address
                + ((relocations.SizeOfBlock - SIZEOF_IMAGE_BASE_RELOCATION) // 2),
                2,
            ):
                relocation = ctypes.cast(
                    address, ctypes.POINTER(ctypes.c_uint16)
                ).contents.value

                relocation_type = relocation >> 12
                relocation_offset = relocation & 0xFFF

                match relocation_type:
                    case windows.IMAGE_REL_BASED_HIGHLOW:
                        type_ = ctypes.c_uint32
                    case windows.IMAGE_REL_BASED_DIR64:
                        type_ = ctypes.c_uint64
                    case _:
                        continue

                ptr = ctypes.cast(
                    self.__base_address
                    + relocations.VirtualAddress
                    + relocation_offset,
                    ctypes.POINTER(type_),
                )

                ptr.contents = type_(
                    ptr.contents.value
                    - self.__custom_pe.structure.imagebase
                    + self.__base_address
                )

            relocations_address += relocations.SizeOfBlock

    def __apply_relocations(self) -> None:
        """
        Apply relocations to the loaded binary if necessary.

        Does nothing if the base address matches the image base or if no relocations are specified.
        """

        assert self.__base_address

        if (
            self.__custom_pe.structure.imagebase == self.__base_address
            or not self.__custom_pe.structure.reloc_va
        ):
            return

        self.__apply_relocations_aux(
            self.__base_address + self.__custom_pe.structure.reloc_va
        )

    def __allocate_image_memory(self) -> None:
        """
        Allocate memory for the PE image in the current process.

        :raise RuntimeError: If VirtualAlloc fails to allocate memory.
        """

        self.__base_address = windows.get_VirtualAlloc()(
            self.__custom_pe.structure.imagebase,
            self.__custom_pe.structure.size,
            windows.MEM_COMMIT | windows.MEM_RESERVE,
            windows.PAGE_EXECUTE_READWRITE,
        )

        if not self.__base_address:
            raise RuntimeError(
                "Failed to allocate image memory. GLE={}".format(
                    windows.get_GetLastError()()
                )
            )

    def __map_sections(self) -> None:
        """
        Map the custom PE sections into the allocated memory.
        """

        for section in self.__custom_pe.structure.sections:
            for i in range(section.raw_size):
                self.memory[section.virtual_address + i] = self.__custom_pe.content[
                    section.raw_offset + i
                ]

    def __map(self) -> None:
        """
        Map the custom PE into memory by allocating space and copying sections.
        """

        self.__allocate_image_memory()
        self.__map_sections()

    def __load_library_and_get_thunks(
        self, import_descriptor: ctypes.POINTER
    ) -> tuple[ctypes.c_void_p, ctypes.POINTER]:
        """
        Load a library and retrieve its import thunks.

        :param import_descriptor: Pointer to an IMAGE_IMPORT_DESCRIPTOR structure.
        :return: A tuple containing the loaded library handle and a pointer to the thunks.
        :raise RuntimeError: If LoadLibraryA fails to load the library.
        """

        library_name = ctypes.cast(
            self.__base_address + import_descriptor.Name, ctypes.c_char_p
        )

        library = windows.get_LoadLibraryA()(library_name)
        if not library:
            raise RuntimeError(
                "LoadLibraryA of {} failed, GLE={}".format(
                    library_name, windows.get_GetLastError()()
                )
            )

        thunks = ctypes.cast(
            self.__base_address
            + (
                import_descriptor.FirstThunk
                if import_descriptor.FirstThunk
                else import_descriptor.OriginalFirstThunk
            ),
            (
                ctypes.POINTER(windows.IMAGE_THUNK_DATA32)
                if self.__custom_pe.is_32
                else ctypes.POINTER(windows.IMAGE_THUNK_DATA64)
            ),
        )

        return library, thunks

    def __load_imports(self, library: ctypes.c_void_p, thunks: ctypes.POINTER) -> None:
        """
        Resolve and load imports for a given library into the thunk table.

        :param library: Handle to the loaded library.
        :param thunks: Pointer to the thunk data structure to populate.
        :raise RuntimeError: If GetProcAddress fails to resolve an import.
        """

        i = 0
        while True:
            if not thunks[i].AddressOfData:
                break

            ordinal_bit = 2 ** (31 if self.__custom_pe.is_32 else 63)
            if ordinal_bit & thunks[i].AddressOfData:
                import_name = thunks[i].AddressOfData & (ordinal_bit - 1)
            else:
                import_name = ctypes.cast(
                    self.__base_address + thunks[i].AddressOfData + OFFSET_TO_NAME,
                    ctypes.c_char_p,
                )

            function = windows.get_GetProcAddress()(library, import_name)
            if not function:
                raise RuntimeError(
                    "GetProcAddress of {} Failed. GLE={}".format(
                        import_name, windows.get_GetLastError()()
                    )
                )

            thunks[i].Function = function

            i += 1

    def __resolve_imports_aux(self, import_descriptors: ctypes.POINTER) -> None:
        """
        Resolve all imports from a given import descriptor table.

        :param import_descriptors: Pointer to an array of IMAGE_IMPORT_DESCRIPTOR structures.
        """

        i = 0
        while True:
            if not import_descriptors[i].Name:
                break

            library, thunks = self.__load_library_and_get_thunks(import_descriptors[i])
            self.__load_imports(library, thunks)

            i += 1

    def __resolve_imports(self) -> None:
        """
        Resolve all imports for the loaded PE if an import table exists.
        """

        assert self.__base_address

        if not self.__custom_pe.structure.import_va:
            return

        self.__resolve_imports_aux(
            ctypes.cast(
                self.__base_address + self.__custom_pe.structure.import_va,
                ctypes.POINTER(windows.IMAGE_IMPORT_DESCRIPTOR),
            )
        )

    @property
    def base_address(self) -> int:
        """
        Get the base address where the PE is loaded in memory.

        :return: The base memory address as an integer.
        """

        return self.__base_address

    @property
    def entrypoint(self) -> int:
        """
        Get the entry point address of the loaded PE.

        :return: The entry point address as an integer.
        """

        return self.__base_address + self.__custom_pe.structure.entrypoint

    @property
    def EntryPoint(self) -> common.EntryPointFunction:
        """
        Get the entry point as a callable function.

        :return: A ctypes function pointer to the entry point.
        """

        return ctypes.cast(self.entrypoint, common.EntryPointFunction)

    @property
    def memory(self) -> ctypes.POINTER[ctypes.c_ubyte]:
        """
        Get a pointer to the loaded PE's memory.

        :return: A ctypes pointer to the memory as an array of unsigned bytes.
        :raise RuntimeError: If no memory has been allocated (base_address is 0).
        """

        if not self.__base_address:
            RuntimeError("No memory")
        return ctypes.cast(self.__base_address, ctypes.POINTER(ctypes.c_ubyte))
