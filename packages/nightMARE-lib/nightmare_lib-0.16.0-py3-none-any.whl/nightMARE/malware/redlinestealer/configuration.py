# coding: utf-8

import base64
import functools
import json

import dotnetfile

from nightMARE.core import bits
from nightMARE.analysis import reversing

CONFIGURATION_PATTERN = "72 ?? ?? ?? 70 80 ?? ?? ?? 04 72 ?? ?? ?? 70 80 ?? ?? ?? 04 72 ?? ?? ?? 70 80 ?? ?? ?? 04 72 ?? ?? ?? 70 80 ?? ?? ?? 04"

HOST_OFFSET = 1
ID_OFFSET = 11
XOR_KEY_OFFSET = 31
MESSAGE_OFFSET = 21


class Configuration(object):
    """
    Represents a configuration object for RedLine Stealer malware settings.
    """

    def __init__(self, host: bytes, id: bytes, message: bytes):
        """
        Initialize the Configuration object with host, ID, and message data.

        :param host: The host string as bytes (format: IP:port).
        :param id: The ID string as bytes.
        :param message: The message string as bytes.
        """

        tmp = host.split(b":")
        self.ip = tmp[0]
        self.port = int(tmp[1])
        self.id = id
        self.message = message

    def __repr__(self) -> str:
        """
        Provide a JSON string representation of the configuration.

        :return: A JSON-formatted string with decoded configuration fields.
        """

        return json.dumps(
            {
                "ip": self.ip.decode("utf-8"),
                "port": self.port,
                "id": self.id.decode("utf-8"),
                "message": self.message.decode("utf-8"),
            }
        )


def decrypt_string(key: bytes, encrypted_string: bytes) -> bytes:
    """
    Decrypt a string using XOR and base64 decoding with a provided key.

    :param key: The decryption key as a byte sequence.
    :param encrypted_string: The encrypted string as a base64-encoded byte sequence.
    :return: The decrypted string as a byte sequence.
    """

    return base64.b64decode(bits.xor(base64.b64decode(encrypted_string), key))


def extract_configuration(binary: bytes) -> Configuration:
    """
    Extracts configuration from a RedLine Stealer sample.

    :param binary: The content of a RedLine Stealer sample as a byte sequence.
    :return: A Configuration object containing the extracted IP, port, ID, and message,
             or None if extraction fails or encounters an exception (though None is not
             explicitly returned in this implementation).
    """

    f = functools.partial(get_string, binary, get_stream_data(binary, "#US"))
    rz = reversing.Rizin.load(binary)
    configuration_offset = rz.find_first_pattern(
        [CONFIGURATION_PATTERN], reversing.Rizin.PatternType.HEX_PATTERN
    )
    xor_key = f(configuration_offset + XOR_KEY_OFFSET)
    return Configuration(
        *(
            decrypt_string(xor_key, f(configuration_offset + x))
            for x in [HOST_OFFSET, ID_OFFSET, MESSAGE_OFFSET]
        )
    )


def get_stream_data(binary: bytes, name: str) -> bytes:
    """
    Retrieve data from a specified .NET stream in the binary.

    :param binary: The raw binary data (a .NET PE file).
    :param name: The name of the stream to extract (e.g., "#US").
    :return: The byte sequence of the specified stream.
    """

    pe = dotnetfile.DotNetPE(binary)
    stream = pe.dotnet_stream_lookup[name]
    return pe.get_data(stream.address, stream.size)


def get_string(binary: bytes, stream: bytes, offset: int) -> bytes:
    """
    Extract a string from a stream at a given offset in the binary.

    :param binary: The raw binary data (used for Rizin analysis).
    :param stream: The stream data containing the string.
    :param offset: The offset in the binary where the string length is stored.
    :return: The extracted string as a byte sequence.
    """

    rz = reversing.Rizin.load(binary)
    return get_string_aux(stream, rz.get_u16(offset))


def get_string_aux(binary: bytes, offset: int) -> bytes:
    """
    Extract and decode a UTF-16 string from a binary stream at a given offset.

    :param binary: The stream data containing the string.
    :param offset: The offset in the stream where the string starts (after length byte).
    :return: The decoded string as a byte sequence (UTF-16 encoded with null terminator).
    """

    result = binary[offset + 1 :].split(b"\x00\x00")[0] + b"\x00"
    if result[0] == 0:
        return b""
    return result.decode("utf-16").encode("utf-8")
