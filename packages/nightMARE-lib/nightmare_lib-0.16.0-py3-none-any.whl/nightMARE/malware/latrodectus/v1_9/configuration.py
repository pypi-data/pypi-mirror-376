# coding: utf-8

import ctypes
import dataclasses
import re
import fnvhash


from nightMARE.analysis import reversing
from nightMARE.core import utils

from nightMARE.malware.latrodectus.v1_9 import crypto


URI_TLD_REGEX = re.compile(rb"https?://[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}(/[^\s]*)?")

CAMPAIGN_FUNCTION_PATTERN = "83E00833C085C075"
DECRYPTION_FUNCTION_PATTERN = "488954241048894C240856574881EC68010000"
LATRODECTUS_VERSION_PATTERNS = [
    "C74424????000000C74424????000000C74424????0000008B",
    "C74424??????????48C74424??????????C74424??????????8B",
]

AES_KEY_SIZE = 0x20
KEY_SCAN_RANGE_IN_DECRYPTION_FUNCTION = 0x40
PREV_INSTRUCTION_LEN_ENCRYPTED_STR = 0x7
RC4_KEY_SIZE = 0x40
VERSION_DISASSEMBLY_RANGE = 0x3


@dataclasses.dataclass
class Configuration(object):
    """
    Represents a configuration object for Latrodectus malware settings decrypted from AES-encrypted strings.
    """

    c2: list[bytes]
    version: bytes
    campaign: bytes
    rc4_key: bytes

    @property
    def campaign_hash(self) -> int:
        return fnvhash.fnv1a_32(self.campaign)


class EncryptedStringDescriptor(ctypes.Structure):
    _pack_ = 1
    _fields_ = [("length", ctypes.c_uint16), ("iv", ctypes.c_byte * 16)]


@dataclasses.dataclass
class EncryptedString(object):
    """
    Represents an encrypted string found in the binary.

    :param address: The memory address where the encrypted string's descriptor is located.
    :param iv: The initialization vector (IV) used for decryption.
    :param data: The encrypted data of the string.
    :param decryption_function_call_address: The address in the binary where the decryption function for this string is called.
    """

    address: int
    iv: bytes
    data: bytes
    decryption_function_call_address: int


@dataclasses.dataclass
class DecryptedString(object):
    """
    Represents a decrypted string.

    :param address: The original memory address where the encrypted string's descriptor was located.
    :param data: The decrypted data of the string.
    :param decryption_function_call_address: The address in the binary where the decryption function for this string was called.
    """

    address: int
    data: bytes
    decryption_function_call_address: int


def decrypt_strings(
    binary: bytes, encrypted_strings: list[EncryptedString]
) -> list[DecryptedString]:
    """
    Decrypts a list of encrypted strings using AES CTR mode with the AES key
    extracted from the provided binary.

    :param binary: The raw binary data from which to extract the AES key.
    :param encrypted_strings: A list of EncryptedString objects to be decrypted.
    :raise RuntimeError: If the AES key cannot be retrieved or if decryption fails.
    :return: A list of DecryptedString objects, each containing the decrypted data,
             its original address, and the address of the decryption function call.
    """

    key = get_aes_key(binary)

    results = []
    for encrypted_string in encrypted_strings:
        results.append(
            DecryptedString(
                encrypted_string.address,
                crypto.decrypt_string(key, encrypted_string.iv, encrypted_string.data),
                encrypted_string.decryption_function_call_address,
            )
        )

    return results


def extract_configuration(binary: bytes) -> Configuration:
    """
    Extracts the configuration from the Latrodectus binary.

    This function retrieves encrypted strings from the binary, identifies the AES key,
    decrypts the strings, and then extracts important information from the configuration
    such as campaign data, C2 URLs, and version. The configuration is returned as a
    `Configuration` object containing this information.

    :param binary: The raw binary data containing the configuration.
    :return: A Configuration object containing the extracted configuration information.
    :raises RuntimeError: If no strings are found for decryption.
    """

    encrypted_strings = get_encrypted_strings(binary)
    decrypted_strings = decrypt_strings(binary, encrypted_strings)
    if not decrypted_strings:
        raise RuntimeError("No string found")

    return Configuration(
        get_c2(decrypted_strings),
        get_version(binary),
        find_campaign_string(binary, encrypted_strings, decrypted_strings),
        find_rc4_key(decrypted_strings),
    )


def extract_version(binary: bytes, pattern_offset: int) -> bytes:
    """
    Extract the version number from the binary given a pattern offset.

    This function disassembles a small range around the `pattern_offset` and attempts to
    identify three immediate values which represent the major, minor, and patch versions.

    :param binary: The raw binary data to analyze.
    :param pattern_offset: The offset in the binary where the version pattern was found.
    :raises RuntimeError: If the disassembly fails or if there are not enough immediate values to extract the version.
    :return: The version number as a string in the format "major.minor.patch" encoded as UTF-8.
    """

    rz = reversing.Rizin.load(binary)

    immediates = []
    for instruction in rz.disassemble(pattern_offset, VERSION_DISASSEMBLY_RANGE):
        if (
            "opex" in instruction
            and "operands" in instruction["opex"]
            and len(instruction["opex"]["operands"]) > 1
            and instruction["opex"]["operands"][1]["type"] == "imm"
        ):
            immediates.append(instruction["opex"]["operands"][1]["value"])

        if len(immediates) == 3:
            break

    else:
        raise RuntimeError("Insufficient data to extract version number")

    major = immediates[2]
    minor = immediates[1]
    patch = immediates[0]
    return f"{major}.{minor}.{patch}".encode("utf-8")


def find_campaign_string(
    binary: bytes,
    encrypted_strings: list[EncryptedString],
    decrypted_strings: list[DecryptedString],
) -> bytes:
    """
    Look back from the campaign function pattern address to find the closest decrypted string
    that is likely the campaign string.

    This function identifies the campaign function's pattern address, then iterates backward
    from that address to find a decryption function call. It then matches this call address
    with the decrypted strings to return the campaign string.

    :param binary: The raw binary data to analyze.
    :param encrypted_strings: A list of EncryptedString objects.
    :param decrypted_strings: A list of DecryptedString objects.
    :raises RuntimeError: If no campaign string is found.
    :return: The decrypted campaign string, with any null terminators stripped.
    """

    campaign_function_pattern_address = get_campaign_function_pattern_address(binary)
    string_decryption_call_addresses = set(
        [x.decryption_function_call_address for x in encrypted_strings]
    )

    for ea in range(
        campaign_function_pattern_address,
        max(campaign_function_pattern_address - 256, 0),
        -1,
    ):
        if ea not in string_decryption_call_addresses:
            continue

        for decrypted_string in decrypted_strings:
            if ea == decrypted_string.decryption_function_call_address:
                return decrypted_string.data.rstrip(b"\x00")

    else:
        raise RuntimeError("Failed to find campaign string")


def find_rc4_key(decrypted_strings: list[DecryptedString]) -> bytes:
    """
    Find the RC4 key from the list of decrypted strings.

    The RC4 key is identified by its specific size (RC4_KEY_SIZE, potentially with a null terminator).

    :param decrypted_strings: A list of DecryptedString objects.
    :raises RuntimeError: If the RC4 key is not found or is not of the expected size.
    :return: The RC4 key as bytes, with any null terminator stripped.
    """

    for decrypted_string in decrypted_strings:
        if (
            len(decrypted_string.data) == RC4_KEY_SIZE + 1
            and decrypted_string.data[-1] == 0
        ):
            return decrypted_string.data[:-1]  # Strip null terminator

        elif len(decrypted_string.data) == RC4_KEY_SIZE:
            return decrypted_string.data

    else:
        raise RuntimeError("RC4 Key not found")


def get_aes_key(binary: bytes) -> bytes:
    """
    Retrieve the AES key used for decryption from Latrodectus binary.

    :param binary: The raw binary data containing the AES key.
    :raise RuntimeError: If the AES key cannot be extracted or is not 32 bytes long.
    :return: The AES key as a byte sequence.
    """

    rz = reversing.Rizin.load(binary)

    pattern_offset = rz.find_first_pattern(
        [DECRYPTION_FUNCTION_PATTERN], reversing.Rizin.PatternType.HEX_PATTERN
    )

    key = []
    for instruction in rz.disassemble(
        pattern_offset, KEY_SCAN_RANGE_IN_DECRYPTION_FUNCTION
    ):
        if (
            instruction["mnemonic"] == "mov"
            and "[rsp" in instruction["opcode"]
            and instruction["opex"]["operands"][1]["type"] == "imm"
        ):
            key.append(instruction["opex"]["operands"][1]["value"])

        if len(key) == AES_KEY_SIZE:
            break

    else:
        raise RuntimeError("Failed to extract a valid 32-byte AES key")

    return bytes(key)


def get_c2(decrypted_strings: list[DecryptedString]) -> list[bytes]:
    """
    Retrieves the C2 URLs from a list of decrypted strings.

    This function searches through the list of decrypted strings to find URLs using a
    combination of a general URL utility and a specific regex for URIs with TLDs.

    :param decrypted_strings: A list of DecryptedString objects, which may contain URLs.
    :return: A list of valid URLs found in the decrypted strings, with any null terminators stripped.
    """

    urls = []
    for decrypted_string in decrypted_strings:
        if utils.is_url(decrypted_string.data):
            urls.append(decrypted_string.data)

        elif match := URI_TLD_REGEX.search(decrypted_string.data):
            urls.append(match.group(0))

    return [x.rstrip(b"\x00") for x in urls]


def get_campaign_function_pattern_address(binary: bytes) -> int:
    """
    Locate the campaign function address in Latrodectus

    :param binary: The raw binary data to analyze.
    :return: The address of the campaign function.
    :raise RuntimeError: If the campaign function pattern cannot be found.
    """

    rz = reversing.Rizin.load(binary)

    if not (
        pattern_offset := rz.find_first_pattern(
            [CAMPAIGN_FUNCTION_PATTERN],
            reversing.Rizin.PatternType.HEX_PATTERN,
        )
    ):
        raise RuntimeError("Failed to find campaign function pattern in binary")

    return pattern_offset


def get_encrypted_strings(binary: bytes) -> list[EncryptedString]:
    """
    Retrieve the addresses and data of encrypted strings by analyzing the binary.

    This function identifies calls to the string decryption function, then looks at the
    previous instruction to find the address of the encrypted string descriptor. It then
    reads the descriptor to get the length and IV, and finally extracts the encrypted data.

    :param binary: The raw binary data to analyze.
    :raise RuntimeError: If the previous instruction or pointer cannot be found for any address,
                         or if the descriptor cannot be read.
    :return: A list of EncryptedString objects, each containing the address, IV, data,
             and the address of the decryption function call.
    """

    rz = reversing.Rizin.load(binary)

    results = []
    for ea in get_string_decryption_call_addresses(binary):

        previous_instruction = rz.disassemble(
            ea - PREV_INSTRUCTION_LEN_ENCRYPTED_STR, 1
        )

        if not previous_instruction or not (
            address := previous_instruction[0].get("ptr")
        ):
            raise RuntimeError(
                f"Failed to find previous instruction or pointer for address {hex(ea)}"
            )

        descriptor = EncryptedStringDescriptor.from_buffer_copy(
            rz.get_data(address, ctypes.sizeof(EncryptedStringDescriptor))
        )

        results.append(
            EncryptedString(
                address,
                descriptor.iv,
                rz.get_data(
                    address + ctypes.sizeof(EncryptedStringDescriptor),
                    descriptor.length,
                ),
                ea,
            )
        )

    return results


def get_string_decryption_call_addresses(binary: bytes) -> list[int]:
    """
    Locate all calls to string decryption function in Latrodectus

    :param binary: The raw binary data to analyze.
    :return: The list of all addresses to string decryption function calls.
    :raise RuntimeError: If no xrefs to string decryption function cannot be found.
    """

    rz = reversing.Rizin.load(binary)
    return rz.get_xrefs_to(
        rz.find_first_pattern(
            [DECRYPTION_FUNCTION_PATTERN],
            reversing.Rizin.PatternType.HEX_PATTERN,
        )
    )


def get_version(binary: bytes) -> bytes:
    """
    Retrieve the version number from the binary by finding a known version pattern.

    :param binary: The raw binary data to analyze.
    :raises RuntimeError: If no version pattern matches in the binary.
    :return: The version number as bytes in the format "major.minor.patch".
    """

    rz = reversing.Rizin.load(binary)

    if not (
        pattern_offset := rz.find_first_pattern(
            LATRODECTUS_VERSION_PATTERNS,
            reversing.Rizin.PatternType.HEX_PATTERN,
        )
    ):
        raise RuntimeError("No version pattern matched in binary.")

    return extract_version(binary, pattern_offset)
