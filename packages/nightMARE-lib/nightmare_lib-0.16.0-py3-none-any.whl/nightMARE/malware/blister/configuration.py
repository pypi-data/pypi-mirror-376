# coding: "utf-8"

import enum
import binascii
import ctypes
import json

from nightMARE.analysis import reversing
from nightMARE.core import bits
from nightMARE.core.compression import lznt1

from nightMARE.malware.blister import crypto


CORE_KEY_PATTERNS = [
    "FF FF D6 49 8B D7 4C 0F A3 F8 80 EC 02 C7 45 48 CD 3A 08 08",
    "48 8D 55 F0 48 83 C9 FF FF D6 49 8B D7 C7 45 48 ?? ?? ?? ?? ?? 8B ??",
]

CORE_TAG_PATTERNS = [
    "8B 7D 38 B8 ?? ?? ?? ?? E9 70",
    "8B 7D ?? B8 ?? ?? ?? ?? EB 0F 41 ?? B7 ?? 8B 34 87 ?? 03 ?? EB ??",
]

CONFIG_TAG_PATTERNS = [
    "48 89 04 24 49 63 C4 48 8B 04 24 F9 41 80 F8 F3 F5 81 38 ?? ?? ?? ?? E9 00 00 00 00"
]

CORE_TAG_OFFSET = 4
CONFIG_TAG_OFFSET = 19
TAG_SIZE = 4

KEY_OFFSET = 16
KEY_SIZE = 4

CORE_OFFSET = 4
CONFIG_SIZE = 0x66B


class RawConfiguration(ctypes.Structure):
    """
    Defines the raw structure of a Blister configuration in memory.

    :var config_offset: Offset to the configuration data
    :var flag: Configuration flags
    :var domain_hash: Hash of the domain for keying
    :var payload_export_hash: Hash of the payload export
    :var sleep_time: Sleep interval in seconds
    :var unk_0: Unknown data (1566 bytes)
    :var compressed_data_size: Size of the compressed payload
    :var uncompressed_data_size: Size of the uncompressed payload
    :var rabbit_iv: Initialization vector for Rabbit encryption (8 bytes)
    :var rabbit_key: Key for Rabbit encryption (16 bytes)
    """

    _pack_ = 1
    _fields_ = [
        ("config_offset", ctypes.c_uint32),
        ("flag", ctypes.c_uint32),
        ("domain_hash", ctypes.c_uint32),
        ("payload_export_hash", ctypes.c_uint32),
        ("sleep_time", ctypes.c_uint32),
        ("unk_0", ctypes.c_uint8 * 1566),
        ("compressed_data_size", ctypes.c_uint32),
        ("uncompressed_data_size", ctypes.c_uint32),
        ("rabbit_iv", ctypes.c_uint8 * 8),
        ("rabbit_key", ctypes.c_uint8 * 16),
    ]


class Configuration(object):
    """
    Represents a Blister configuration object with parsed attributes.

    Attributes:
        flag (int): A set of flags indicating various settings for the Blister.
        domain_hash (int): Hash value associated with the domain for the keying feature.
        payload_export_hash (int): Hash value associated with payload export.
        sleep_time (int): Time in seconds for sleep intervals.
        rabbit_key (bytes): Encryption key for Rabbit algorithm.
        rabbit_iv (bytes): Initialization vector for Rabbit algorithm.
        compressed_data_size (int): Size of compressed payload.
        uncompressed_data_size (int): Size of uncompressed payload.
        payload (bytes): Extracted payload.
        is_pe (bool): True if the payload is a PE file, False if shellcode.

    Note:
        The is_pe attribute is set to True based on the absence of the
        Configuration.Flags.EXECUTE_SHELLCODE_METHOD flag in the flag attribute.
    """

    class Flags(enum.Enum):
        """
        Enum defining possible configuration flags for Blister.

        :var DO_PERSISTANCE: Enable persistence
        :var OWN_PROCESS_REFLECTIVE_INJECTION_METHOD: Use reflective injection in own process
        :var OWN_PROCESS_HOLLOWING_METHOD: Use process hollowing in own process
        :var REMOTE_PROCESS_HOLLOWING_METHOD: Use process hollowing in a remote process
        :var EXECUTE_PAYLOAD_EXPORT: Execute payload export
        :var EXECUTE_SHELLCODE_METHOD: Execute as shellcode
        :var INJECT_WITH_CMDLINE: Inject with command line
        :var USE_SYSCALLS: Use syscalls
        :var USE_FRESH_MAPPED_NTDLL: Use freshly mapped NTDLL
        :var ENABLE_SLEEP_BEFORE_INJECTION: Enable sleep before injection
        :var CUSTOM_SLEEP_TIMER_SET: Use custom sleep timer
        :var ENABLE_PROCESS_INSTRUMENTATION_UNHOOK: Enable process instrumentation unhook
        :var ENABLE_KEYING: Enable keying feature
        """

        DO_PERSISTANCE = 0x1
        OWN_PROCESS_REFLECTIVE_INJECTION_METHOD = 0x2
        OWN_PROCESS_HOLLOWING_METHOD = 0x8
        REMOTE_PROCESS_HOLLOWING_METHOD = 0x10
        EXECUTE_PAYLOAD_EXPORT = 0x20
        EXECUTE_SHELLCODE_METHOD = 0x40
        INJECT_WITH_CMDLINE = 0x80
        USE_SYSCALLS = 0x100
        USE_FRESH_MAPPED_NTDLL = 0x200
        ENABLE_SLEEP_BEFORE_INJECTION = 0x1000
        CUSTOM_SLEEP_TIMER_SET = 0x2000
        ENABLE_PROCESS_INSTRUMENTATION_UNHOOK = 0x80000
        ENABLE_KEYING = 0x100000

    def __init__(
        self,
        flag: int,
        domain_hash: int,
        payload_export_hash: int,
        sleep_time: int,
        rabbit_key: bytes,
        rabbit_iv: bytes,
        compressed_data_size: int,
        uncompressed_data_size: int,
        payload: bytes,
    ):
        """
        Initializes a Configuration object with the provided attributes.

        :param flag: Configuration flags
        :param domain_hash: Hash of the domain for keying
        :param payload_export_hash: Hash of the payload export
        :param sleep_time: Sleep interval in seconds
        :param rabbit_key: Encryption key for Rabbit algorithm
        :param rabbit_iv: Initialization vector for Rabbit algorithm
        :param compressed_data_size: Size of the compressed payload
        :param uncompressed_data_size: Size of the uncompressed payload
        :param payload: Extracted payload data
        """

        self.flag = flag
        self.domain_hash = domain_hash
        self.payload_export_hash = payload_export_hash
        self.sleep_time = (
            sleep_time
            if Configuration.Flags.CUSTOM_SLEEP_TIMER_SET.value & self.flag
            else 600000
        )
        self.rabbit_key = rabbit_key
        self.rabbit_iv = rabbit_iv
        self.compressed_data_size = compressed_data_size
        self.uncompressed_data_size = uncompressed_data_size
        self.is_pe = not Configuration.Flags.EXECUTE_SHELLCODE_METHOD.value & self.flag
        self.payload = b"MZ" + payload[2:] if self.is_pe else payload

    @property
    def injection_method(self) -> str:
        """
        Determines the injection method based on the configuration flags.

        :return: A string describing the injection method
        :raise: RuntimeError: If no injection method is specified in the flags
        """

        if (
            Configuration.Flags.OWN_PROCESS_REFLECTIVE_INJECTION_METHOD.value
            & self.flag
        ):
            return "Reflective injection"
        elif Configuration.Flags.EXECUTE_SHELLCODE_METHOD.value & self.flag:
            return "Execute shellcode"
        elif Configuration.Flags.OWN_PROCESS_HOLLOWING_METHOD.value & self.flag:
            return "Process hollowing current executable (rundll32.exe in case of a DLL sample)"
        elif Configuration.Flags.REMOTE_PROCESS_HOLLOWING_METHOD.value & self.flag:
            return "Process hollowing IE or Werfault"
        else:
            raise RuntimeError("Injection method missing in configuration")

    @property
    def enabled_features(self) -> list[str]:
        """
        Retrieves a list of enabled feature names based on the configuration flags.

        :return: A list of enabled feature names

        """

        return [x.name for x in Configuration.Flags if x.value & self.flag]

    @staticmethod
    def from_raw(raw_configuration: RawConfiguration, payload: bytes):
        """
        Creates a Configuration object from a raw configuration structure and payload.

        :param raw_configuration: The raw configuration structure
        :param payload: The payload data
        :return: A Configuration object

        """

        return Configuration(
            raw_configuration.flag,
            raw_configuration.domain_hash,
            raw_configuration.payload_export_hash,
            raw_configuration.sleep_time,
            bytes(raw_configuration.rabbit_key),
            bytes(raw_configuration.rabbit_iv),
            raw_configuration.compressed_data_size,
            raw_configuration.uncompressed_data_size,
            payload,
        )

    def __repr__(self) -> str:
        """
        Returns a JSON-formatted string representation of the configuration.

        :return: A JSON string representing the configuration
        """

        return json.dumps(
            {
                "flag": self.flag,
                "domain_hash": self.domain_hash,
                "payload_export_hash": self.payload_export_hash,
                "sleep_time": self.sleep_time,
                "rabbit_key": binascii.hexlify(self.rabbit_key).decode(),
                "rabbit_iv": binascii.hexlify(self.rabbit_iv).decode(),
                "compressed_data_size": self.compressed_data_size,
                "uncompressed_data_size": self.uncompressed_data_size,
                "injection_method": self.injection_method,
                "is_pe": self.is_pe,
                "enabled_features": self.enabled_features,
            },
            indent=4,
        )


def extract_configuration(binary: bytes) -> Configuration:
    """
    Extracts and parses the configuration from a Blister sample.

    :param binary: Bytes of a Blister sample to extract the configuration and payload from
    :return: A Configuration object containing the extracted data
    """

    raw_configuration = get_raw_configuration(get_core_blob(binary))
    return Configuration.from_raw(
        raw_configuration, get_payload(binary, raw_configuration)
    )


def get_config_tag(core_blob: bytes) -> bytes:
    """
    Retrieves the configuration tag from the core blob.

    :param core_blob: The core blob data
    :return: The configuration tag as bytes
    """

    rz = reversing.Rizin.load(core_blob)
    return rz.get_data(
        rz.find_first_pattern(
            CONFIG_TAG_PATTERNS, reversing.Rizin.PatternType.HEX_PATTERN
        )
        + CONFIG_TAG_OFFSET,
        TAG_SIZE,
    )


def get_core_blob(binary: bytes) -> bytes:
    """
    Decrypts and retrieves the Blister core blob from the binary.

    :param binary: The PE content of the Blister sample
    :return: The decrypted core blob as bytes
    """

    return bits.xor(
        get_rsrc_section(binary)[get_core_offset(binary) :],
        get_core_key(binary),
    )


def get_core_key(binary: bytes) -> bytes:
    """
    Retrieves the core decryption key from the binary.

    :param binary: The Blister sample binary
    :return: The core decryption key as bytes
    """

    rz = reversing.Rizin.load(binary)
    return rz.get_data(
        rz.find_first_pattern(
            CORE_KEY_PATTERNS, reversing.Rizin.PatternType.HEX_PATTERN
        )
        + KEY_OFFSET,
        KEY_SIZE,
    )


def get_core_offset(binary: bytes) -> int:
    """
    Calculates the offset of the core data within the resource section.

    :param binary: The Blister sample binary
    :return: The offset of the core data
    """

    return get_rsrc_section(binary).find(get_core_tag(binary)) + TAG_SIZE


def get_core_tag(binary: bytes) -> bytes:
    """
    Retrieves the core tag from the binary.

    :param binary: The Blister sample binary
    :return: The core tag as bytes
    """

    rz = reversing.Rizin.load(binary)
    tag_offset = rz.find_first_pattern(
        CORE_TAG_PATTERNS, reversing.Rizin.PatternType.HEX_PATTERN
    )
    return rz.get_data(tag_offset + CORE_TAG_OFFSET, TAG_SIZE)


def get_payload(binary: bytes, raw_configuration: RawConfiguration) -> bytes:
    """
    Extracts and decrypts the payload from the binary using the raw configuration.

    :param binary: The Blister sample binary
    :param raw_configuration: The raw configuration structure
    :return: The decrypted and decompressed payload as bytes
    """

    offset = get_core_offset(binary) + raw_configuration.config_offset + CONFIG_SIZE
    cipher = crypto.Rabbit(
        bytes(raw_configuration.rabbit_key), bytes(raw_configuration.rabbit_iv)
    )
    return lznt1.decompress(
        cipher.crypt(
            get_rsrc_section(binary)[
                offset : offset + raw_configuration.compressed_data_size
            ]
        )
    )


def get_raw_configuration(core_blob: bytes) -> RawConfiguration:
    """
    Extracts the raw configuration structure from the core blob.

    :param core_blob: The core blob data
    :return: A RawConfiguration object
    :raise: SignatureNotFoundError: If the configuration tag is not found
    """

    if -1 == (config_blob_offset := core_blob.rfind(get_config_tag(core_blob))):
        raise RuntimeError("Failed to find config blob offset")
    config_blob_offset += TAG_SIZE

    return RawConfiguration.from_buffer_copy(
        config_blob_offset.to_bytes(4, "little") + core_blob[config_blob_offset:]
    )


def get_rsrc_section(binary: bytes) -> bytes:
    """
    Retrieves the .rsrc section from the binary.

    :param binary: The Blister sample binary
    :return: The .rsrc section data as bytes
    """

    return reversing.Rizin.load(binary).get_section(".rsrc")
