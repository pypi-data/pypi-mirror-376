# coding: "utf-8"

from nightMARE.analysis import reversing
from nightMARE.core import bits
from nightMARE.core.compression import lznt1

from nightMARE.malware.ghostpulse import payload_common as pc

TAG = 0xEA79A5C6
TAG_OFFSET = 4

IDAT_CHUNK_SIZE_OFFSET = -4
IDAT_TOTAL_SIZE_OFFSET = 12
IDAT_XOR_KEY_OFFSET = 8


def extract_payload(binary: bytes) -> bytes:
    """
    Extracts payload from an encrypted file of GhostPulse.

    :param binary: Bytes of the encrypted file (PNG format expected).
    :return: The decrypted payload bytes.
    :raise RuntimeError: If the first stage extraction fails (invalid GhostPulse file).
    """

    if not (first_stage := get_first_stage(binary)):
        raise RuntimeError(
            "Failed to extract first stage, file does not appear to be GhostPulse file"
        )
    return pc.get_decrypted_payload(
        pc.get_third_stage(pc.get_second_stage(first_stage))
    )


def get_chunk_size(x: int) -> int:
    """
    Reorder the bytes of a 32-bit integer to compute the chunk size.

    :param x: The 32-bit integer representing the chunk size in a non-standard byte order.
    :return: The reordered chunk size as a 32-bit unsigned integer.
    """

    return (
        (((x >> 8) & 0xFF) << 16) + (((x >> 16) & 0xFF) << 8) + (x << 24) + (x >> 24)
    ) & 0xFFFFFFFF


def get_first_stage(binary: bytes) -> bytes:
    """
    Extracts the payload from the IDAT chunk of the PNG file.

    :param binary: The PNG file data.
    :return: The decrypted and decompressed first stage payload bytes, or None if no valid tag is found.
    :raise RuntimeError: If the tag is not found in any IDAT chunk.
    """

    rz = reversing.Rizin.load(binary)

    tag_found = False
    encrypted_data = b""
    key = b""
    total_size = 0
    for idat_offset in get_idat_offsets(binary):
        if TAG == rz.get_u32(idat_offset + TAG_OFFSET):
            tag_found = True
            key = rz.get_data(idat_offset + IDAT_XOR_KEY_OFFSET, 4)
            total_size = rz.get_u32(idat_offset + IDAT_TOTAL_SIZE_OFFSET) & 0xFFFFFFF0

        if not tag_found:
            continue

        chunk_size = get_chunk_size(rz.get_u32(idat_offset + IDAT_CHUNK_SIZE_OFFSET))
        chunk_size = (
            chunk_size
            if len(encrypted_data) + chunk_size < total_size
            else total_size - len(encrypted_data) + 16
        )
        encrypted_data += rz.get_data(idat_offset + 4, chunk_size)

    if not tag_found:
        raise RuntimeError("Failed to extract first stage")
    return lznt1.decompress(bits.xor(encrypted_data[16:], key) + b"\x00" * 0x100)


def get_idat_offsets(binary: bytes) -> list[int]:
    """
    Find the offsets of all IDAT chunks in the PNG file.

    :param binary: The PNG file data.
    :return: A list of integer offsets where IDAT chunks are located.
    """

    return [
        x["address"]
        for x in reversing.Rizin.load(binary).find_pattern(
            "IDAT", reversing.Rizin.PatternType.STRING_PATTERN
        )
    ]
