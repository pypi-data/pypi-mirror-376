# coding: "utf-8"

import binascii
from PIL import Image
from io import BytesIO

from nightMARE.analysis import reversing
from nightMARE.core import bits

from nightMARE.malware.ghostpulse import payload_common as pc

ENCRYPTED_DATA_OFFSET = 0x10
XOR_KEY_OFFSET_PIXELS = 4
LENGTH_OFFSET = 0x0C


def extract_payload(binary: bytes) -> bytes:
    """
    Extracts payload from an encrypted file of GhostPulse.

    :param binary: Bytes of the encrypted file (PNG format expected).
    :return: The decrypted payload bytes.
    """

    return pc.get_decrypted_payload(
        pc.get_third_stage(pc.get_second_stage(get_first_stage(binary)))
    )


def get_first_stage(binary: bytes) -> bytes:
    """
    Extracts the configuration from the pixels of the PNG file.

    :param binary: The PNG file data.
    :return: The decrypted configuration bytes, or None if extraction fails.
    """

    return get_payload_from_pixels(get_image_pixels(binary))


def get_image_pixels(binary: bytes) -> bytes:
    """
    Extract pixel data from a PNG image as a byte sequence.

    :param binary: The PNG file data.
    :return: A byte sequence of pixel components (e.g., RGB or RGBA values).
    :raise IOError: If the PNG data is invalid and cannot be opened by PIL.
    """

    with Image.open(BytesIO(binary)) as image:
        width, height = image.size
        pixels = bytearray(
            [
                component
                for i in range(height)
                for j in range(width)
                for component in image.getpixel((j, i))
            ]
        )
        return bytes(pixels)


def get_payload_from_pixels(pixels: bytes) -> bytes:
    """
    Extract and decrypt the payload from pixel data.

    :param pixels: The pixel data as a byte sequence.
    :return: The decrypted payload bytes.
    :raise RuntimeError: If the tag offset cannot be found in the pixel data.
    """

    tag_offset = get_tag_offset(pixels)
    rz = reversing.Rizin.load(pixels)
    xor_key = rz.get_data(tag_offset + XOR_KEY_OFFSET_PIXELS, size=4)
    length = rz.get_u32(tag_offset + LENGTH_OFFSET)
    encrypted_data = rz.get_data(tag_offset + ENCRYPTED_DATA_OFFSET, length)
    return bits.xor(encrypted_data, xor_key)


def get_tag_offset(pixels: bytes) -> int:
    """
    Find the offset of the configuration in the pixels data.

    :param pixels: The pixel data as a byte sequence.
    :return: The offset of the encrypted configuration.
    :raise RuntimeError: If the configuration tag is not found in the pixel data.
    """

    rz = reversing.Rizin.load(pixels)
    for i in range(0, len(pixels)):
        if binascii.crc32(rz.get_data(i + 4, 4 * 3)) & 0xFFFFFFFF == rz.get_u32(i):
            return i
    else:
        raise RuntimeError("Failed to get tag offset")
