# coding: utf-8

import functools
import base64
import typing

from nightMARE.core import cast

C2_SEPARATOR = b"\x1e"
CONFIGURATION_SEPARATOR = b"\x7c\x1e\x1e\x1f\x7c"

DIRECTORY_MAPPING = {
    0: "%Temp%",
    1: "<CurrentMalwareDirectory>",
    2: "%SystemDrive%",
    3: "%WinDir%",
    4: "%WinDir%//[SysWOW64|system32]",
    5: "%ProgramFiles%",
    6: "%AppData%",
    7: "%UserProfile%",
    8: "%ProgramData%|%ProgramFiles%",
}

bool_to_byte = lambda x: cast.p8(int(x))
byte_to_bool = lambda x: bool(cast.u8(x))

utf8_to_str = functools.partial(bytes.decode, encoding="utf-8")
str_to_utf8 = lambda x: x.encode("utf-8")

utf16_to_str = functools.partial(bytes.decode, encoding="utf-16")
str_to_utf16 = lambda x: x.encode("utf-16-le")

ascii_bytes_to_int = lambda x: int(utf8_to_str(x))
int_to_ascii_bytes = lambda x: str_to_utf8(str(x))

ascii_bytes_to_bool = lambda x: bool(ascii_bytes_to_int(x))
bool_to_ascii_bytes = lambda x: int_to_ascii_bytes(int(x))

bytes_to_b64_str = lambda x: base64.b64encode(x).decode("utf-8")

int_to_directory = lambda x: DIRECTORY_MAPPING[x]
directory_to_int = lambda x: {v: k for (k, v) in DIRECTORY_MAPPING.items()}[x]

bytes_to_directory = lambda x: int_to_directory(cast.u8(x))
directory_to_bytes = lambda x: cast.p8(directory_to_int(x))

ascii_bytes_to_directory = lambda x: int_to_directory(ascii_bytes_to_int(x))
directory_to_ascii_bytes = lambda x: int_to_ascii_bytes(directory_to_int(x))


def unpack_c2(packed_c2: bytes) -> list[dict[str, typing.Any]]:
    """
    Unpacks the packed C2 bytes and returns a list of dictionaries containing the C2 information.

    :param packed_c2: The packed C2 bytes to be unpacked.
    :return: A list of dictionaries, where each dictionary represents a C2.
    """

    results = []
    for c2 in (x for x in packed_c2.split(C2_SEPARATOR) if x):
        host, port, tls = c2.split(b":")
        results.append(
            {"host": host.decode("utf-8"), "port": int(port), "tls": bool(int(tls))}
        )
    return results


def pack_c2(unpacked_c2: list[dict[str, typing.Any]]) -> bytes:
    """
    Packs the unpacked C2 configuration into a byte string.

    :param unpacked_c2: A list of dictionaries representing the unpacked C2 configuration.
    :return: A byte string representing the packed C2 configuration.
    """

    result = bytes()
    for x in unpacked_c2:
        result += (
            x["host"].encode()
            + b":"
            + str(x["port"]).encode()
            + b":"
            + str(int(x["tls"])).encode()
            + C2_SEPARATOR
        )
    return result


def unpack_window_names(packed_data: bytes) -> list[str]:
    """
    Unpacks the window names from the packed data.

    :param packed_data: The packed data containing window names.
    :return: A list of unpacked window names.
    """

    if not packed_data[0]:
        return []
    return utf16_to_str(packed_data).split(";")


def pack_window_names(unpacked_data: list[str]) -> bytes:
    """
    Packs a list of window names into a byte string.

    :param unpacked_data: The list of window names to be packed.
    :return: The packed window names as a byte string.
    """

    if not unpacked_data:
        return b"\x00\x00"
    return str_to_utf16(";".join(unpacked_data))


CONFIGURATION_MAPPING = {
    0: ("c2_list", unpack_c2, pack_c2),
    1: ("botnet", utf8_to_str, str_to_utf8),
    2: ("connect_interval_in_second", ascii_bytes_to_int, int_to_ascii_bytes),
    3: ("enable_install_flag", byte_to_bool, bool_to_byte),
    4: ("enable_hkcu_run_persistence_flag", byte_to_bool, bool_to_byte),
    5: ("enable_hklm_run_persistence_flag", byte_to_bool, bool_to_byte),
    7: (
        "keylogger_maximum_file_size",
        ascii_bytes_to_int,
        int_to_ascii_bytes,
    ),
    8: (
        "enable_hklm_policies_explorer_run_flag",
        byte_to_bool,
        bool_to_byte,
    ),
    9: ("install_parent_directory", ascii_bytes_to_directory, directory_to_ascii_bytes),
    10: ("install_filename", utf16_to_str, str_to_utf16),
    12: (
        "enable_persistence_directory_and_binary_hidding_flag",
        byte_to_bool,
        bool_to_byte,
    ),
    13: (
        "enable_process_injection_flag",
        ascii_bytes_to_bool,
        bool_to_ascii_bytes,
    ),
    14: ("mutex", utf8_to_str, str_to_utf8),
    15: ("keylogger_mode", ascii_bytes_to_int, int_to_ascii_bytes),
    16: (
        "keylogger_parent_directory",
        ascii_bytes_to_directory,
        directory_to_ascii_bytes,
    ),
    17: ("keylogger_filename", utf16_to_str, str_to_utf16),
    18: (
        "enable_keylogger_file_encryption_flag",
        byte_to_bool,
        bool_to_byte,
    ),
    19: ("enable_keylogger_file_hidding_flag", byte_to_bool, bool_to_byte),
    20: ("enable_screenshot_flag", byte_to_bool, bool_to_byte),
    21: (
        "screenshot_interval_in_minutes",
        ascii_bytes_to_int,
        int_to_ascii_bytes,
    ),
    22: (
        "enable_screenshot_specific_window_names_flag",
        byte_to_bool,
        bool_to_byte,
    ),
    23: ("screenshot_specific_window_names", unpack_window_names, pack_window_names),
    24: (
        "screenshot_specific_window_names_interval_in_seconds",
        ascii_bytes_to_int,
        int_to_ascii_bytes,
    ),
    25: (
        "screenshot_parent_directory",
        ascii_bytes_to_directory,
        directory_to_ascii_bytes,
    ),
    26: ("screenshot_folder", utf8_to_str, str_to_utf8),
    27: ("enable_screenshot_encryption_flag", byte_to_bool, bool_to_byte),
    35: ("enable_audio_recording_flag", byte_to_bool, bool_to_byte),
    36: (
        "audio_recording_duraction_in_minutes",
        ascii_bytes_to_int,
        int_to_ascii_bytes,
    ),
    37: ("audio_record_parent_directory", bytes_to_directory, directory_to_bytes),
    38: ("audio_record_folder", utf8_to_str, str_to_utf8),
    39: ("disable_uac_flag", byte_to_bool, bool_to_byte),
    40: ("logging_mode", ascii_bytes_to_int, int_to_ascii_bytes),
    41: ("connect_delay_in_second", ascii_bytes_to_int, int_to_ascii_bytes),
    42: ("keylogger_specific_window_names", unpack_window_names, pack_window_names),
    43: (
        "enable_browser_cleaning_on_startup_flag",
        byte_to_bool,
        bool_to_byte,
    ),
    44: (
        "enable_browser_cleaning_only_for_the_first_run_flag",
        byte_to_bool,
        bool_to_byte,
    ),
    45: (
        "browser_cleaning_sleep_time_in_minutes",
        ascii_bytes_to_int,
        int_to_ascii_bytes,
    ),
    46: ("enable_uac_bypass_flag", byte_to_bool, bool_to_byte),
    48: ("install_directory", utf16_to_str, str_to_utf16),
    49: ("keylogger_root_directory", utf16_to_str, str_to_utf16),
    50: ("enable_watchdog_flag", byte_to_bool, bool_to_byte),
    52: ("license", utf8_to_str, str_to_utf8),
    53: (
        "enable_screenshot_mouse_drawing_flag",
        byte_to_bool,
        bool_to_byte,
    ),
    54: ("tls_raw_certificate", bytes_to_b64_str, base64.b64decode),
    55: ("tls_key", bytes_to_b64_str, base64.b64decode),
    56: ("tls_raw_peer_certificate", bytes_to_b64_str, base64.b64decode),
}


def unpack_configuration(packed_configuration: bytes) -> dict[str, typing.Any]:
    """
    Unpacks the packed configuration and returns a dictionary.

    This function splits the packed configuration by the predefined separator, then
    uses the `CONFIGURATION_MAPPING` to decode the corresponding data for each field.

    :param packed_configuration: The packed configuration as bytes.
    :return: A dictionary containing the unpacked configuration.
    """

    result = {}
    for i, x in enumerate(
        (x for x in packed_configuration.split(CONFIGURATION_SEPARATOR) if x)
    ):
        if not (tmp := CONFIGURATION_MAPPING.get(i, None)):
            result[i] = bytes_to_b64_str(x)
            continue

        result[tmp[0]] = tmp[1](x)

    return result


def pack_configuration(unpacked_configuration: dict[str, typing.Any]) -> bytes:
    """
    Packs the unpacked configuration into a byte string.

    This function iterates through the unpacked configuration dictionary and uses the
    corresponding packing functions from `CONFIGURATION_MAPPING` to encode the data.

    :param unpacked_configuration: The unpacked configuration as a dictionary.
    :return: The packed configuration as a byte string.
    """

    results = []

    for i, x in enumerate(unpacked_configuration.items()):
        if not (tmp := CONFIGURATION_MAPPING.get(i, None)):
            results.append(base64.b64decode(x[1]))
            continue

        results.append(tmp[2](x[1]))

    return CONFIGURATION_SEPARATOR.join(results)
