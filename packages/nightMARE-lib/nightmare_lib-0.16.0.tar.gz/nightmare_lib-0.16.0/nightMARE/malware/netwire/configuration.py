# coding: utf-8

import json

from Crypto.Cipher import ARC4

from nightMARE.analysis import reversing

RC4_DECRYPTION_PATTERNS = [
    "02 ?? 0F B6 C9 88 ?? ?? ?? 0F B6 ?? ?? ?? 30 0C ?? 47",
    "01 ?? 0F B6 C9 8A ?? ?? ?? 30 0C ?? 47",
]

RC4_INIT_PATTERNS = [
    "0F B6 ?? 8A ?? ?? ?? 88 ?? ?? 89 ?? 88 ?? ?? ?? 8D ?? ?? 99 F7 7C ?? ??",
    "0F B6 ?? 8A ?? ?? ?? 88 ?? ?? 8D ?? ?? 88 ?? ?? ?? 99 F7 7C ?? ??",
]


class Configuration(object):
    """
    Represents a configuration object for malware settings decrypted from RC4-encrypted strings.
    """

    def __init__(self, config: list):
        """
        Initialize the Configuration object with a list of decrypted configuration strings.

        :param config: A list of byte strings representing the raw configuration data.
        """

        self.c2_list: list[bytes] = config[0].rstrip(b";").split(b";")
        self.password: bytes = config[2]
        self.host_id: bytes = config[3]
        self.mutex: bytes = config[4]
        self.installation_path: bytes = config[5]
        self.run_registry_key_entry: bytes = config[6]
        self.active_setup_key: bytes = config[7]
        self.keylogger_logs_directory: bytes = config[8]
        self.sleep_in_seconds = int(config[11])

    def __repr__(self) -> str:
        """
        Provide a JSON string representation of the configuration.

        :return: A JSON-formatted string with decoded configuration fields.
        """

        return json.dumps(
            {
                "c2_list": [x.decode("utf-8") for x in self.c2_list],
                "password": self.password.decode("utf-8"),
                "host_id": self.host_id.decode("utf-8"),
                "mutex": self.mutex.decode("utf-8"),
                "installation_path": self.installation_path.decode("utf-8"),
                "run_registry_key_entry": self.run_registry_key_entry.decode("utf-8"),
                "active_setup_key": self.active_setup_key.decode("utf-8"),
                "keylogger_logs_directory": self.keylogger_logs_directory.decode(
                    "utf-8"
                ),
                "sleep_in_seconds": self.sleep_in_seconds,
            }
        )


def get_encrypted_strings(binary: bytes) -> list[bytes]:
    """
    Retrieve a list of encrypted strings from the binary.

    :param binary: The raw binary data containing encrypted strings.
    :return: A list of encrypted string byte sequences.
    """

    rz = reversing.Rizin.load(binary)
    return [
        rz.get_data(x[0], x[1]) for x in get_encrypted_strings_offsets_and_sizes(binary)
    ]


def decrypt_configuration(binary: bytes, key: bytes) -> Configuration:
    """
    Decrypt configuration strings from the binary using an RC4 key.

    :param binary: The raw binary data containing encrypted configuration strings.
    :param key: The RC4 key used for decryption.
    :return: A Configuration object with decrypted settings.
    """

    raw_config = []
    for x in get_encrypted_strings(binary):
        decrypted_data = ARC4.new(key).decrypt(x)
        raw_config.append(decrypted_data.split(b"\x00")[0])
    return Configuration(raw_config)


def get_function_data_offset_and_size_args(
    binary: bytes, reference_to_func: int
) -> tuple[int, int]:
    """
    Extract data offset and size arguments passed to a function by analyzing previous instructions.

    :param binary: The raw binary data to analyze.
    :param reference_to_func: The address of a reference to the target function.
    :return: A tuple containing the data offset and size as integers.
    :raise RuntimeError: If the arguments cannot be retrieved within four previous instructions.
    """

    rz = reversing.Rizin.load(binary)

    ea = reference_to_func
    data_offset_and_size = []
    for _ in range(4):
        prev_insn = rz.disassemble_previous_instruction(ea)

        if len(prev_insn["opex"]["operands"]) > 1:
            if prev_insn["mnemonic"] == "mov":
                first_op = prev_insn["opex"]["operands"][0]
                second_op = prev_insn["opex"]["operands"][1]
                if first_op["type"] == "mem" and second_op["type"] == "imm":
                    data_offset_and_size.append(second_op["value"])

        elif prev_insn["mnemonic"] == "push":
            first_op = prev_insn["opex"]["operands"][0]
            if first_op["type"] == "imm":
                data_offset_and_size.append(first_op["value"])

        ea = prev_insn["addr"]

        if len(data_offset_and_size) == 2:
            return tuple(data_offset_and_size)

    else:
        raise RuntimeError("Unable to retrieve arguments from function")


def get_rc4_init_function_offset(binary: bytes) -> int:
    """
    Find the starting offset of the RC4 initialization function in the binary.

    :param binary: The raw binary data to search.
    :return: The offset of the RC4 initialization function's start.
    :raise RuntimeError: If no matching RC4 init pattern is found.
    """

    rz = reversing.Rizin.load(binary)
    if not (
        offset := rz.get_function_start(
            rz.find_first_pattern(
                RC4_INIT_PATTERNS, reversing.Rizin.PatternType.HEX_PATTERN
            )
        )
    ):
        raise RuntimeError("Failed to get rc4 init function")

    return offset


def get_rc4_key_offset_and_size(binary: bytes) -> tuple[int, int]:
    """
    Retrieve the offset and size of the RC4 key in the binary.

    :param binary: The raw binary data to analyze.
    :return: A tuple containing the offset to the RC4 key and its size as integers.
    """

    rz = reversing.Rizin.load(binary)
    return get_function_data_offset_and_size_args(
        binary, rz.get_xrefs_to(get_rc4_init_function_offset(binary))[0]
    )


def get_decrypt_function_offset(binary: bytes) -> int:
    """
    Find the starting offset of the RC4 decryption function in the binary.

    :param binary: The raw binary data to search.
    :return: The offset of the RC4 decryption function's start.
    :raise RuntimeError: If no matching RC4 decryption pattern is found.
    """

    rz = reversing.Rizin.load(binary)
    if not (
        offset := rz.get_function_start(
            rz.find_first_pattern(
                RC4_DECRYPTION_PATTERNS, reversing.Rizin.PatternType.HEX_PATTERN
            )
        )
    ):
        raise RuntimeError("Failed to get decryption function offset")

    return offset


def get_decryption_args(binary: bytes, references_to_decrypt_func: list) -> list:
    """
    Retrieve the data offset and size arguments for all calls to the decryption function.

    :param binary: The raw binary data to analyze.
    :param references_to_decrypt_func: A list of reference addresses to the decryption function.
    :return: A list of tuples, each containing the data offset and size for a decryption call.
    """

    data_offsets_and_sizes = []
    for i in range(len(references_to_decrypt_func)):
        data_offsets_and_sizes.append(
            get_function_data_offset_and_size_args(
                binary, references_to_decrypt_func[i]
            )
        )
    return data_offsets_and_sizes


def get_encrypted_strings_offsets_and_sizes(binary: bytes) -> list:
    """
    Retrieve a list of offsets and sizes for encrypted strings in the binary.

    :param binary: The raw binary data to analyze.
    :return: A list of tuples, each containing the offset and size of an encrypted string.
    """

    rz = reversing.Rizin.load(binary)

    references_to_decrypt_func = rz.get_xrefs_to(get_decrypt_function_offset(binary))
    if len(references_to_decrypt_func) == 1:
        if not (offset := rz.get_function_start(references_to_decrypt_func[0])):
            raise RuntimeError("Failed to get function start")

        references_to_decrypt_func = rz.get_xrefs_to(offset)

    return get_decryption_args(binary, references_to_decrypt_func)


def get_rc4_key(binary: bytes) -> bytes:
    """
    Extract the RC4 key from the binary.

    :param binary: The raw binary data containing the RC4 key.
    :return: The RC4 key as a byte sequence.
    """

    return reversing.Rizin.load(binary).get_data(*get_rc4_key_offset_and_size(binary))


def extract_configuration(binary: bytes) -> Configuration:
    """
    Extract and decrypt the configuration from the binary using RC4.

    :param binary: The raw binary data containing encrypted configuration strings.
    :return: A Configuration object with decrypted settings
    """

    return decrypt_configuration(
        binary,
        get_rc4_key(binary),
    )
