# coding: utf-8

import ctypes
import dataclasses
import json

from Crypto.Cipher import ARC4

from nightMARE.analysis import reversing
from nightMARE.core import cast
from nightMARE.core import regex


PORT_VALUES = (80, 443)

STRING_DECRYPT_PATTERNS = [
    "48894C24??4881EC68010000488B05????????4833C448898424????????48C74424",
    "554881ec40010000488dac248000000048898dd0000000",
    "4154555756534881ec300100004889cf8b318b41048984242c010000",
    "48895c241048896c24184889742420574881ec50010000488b05b2ba01004833c4",
    "48895c241048896c24184889742420574881ec50010000488b0522bc01004833c4",
    "415541545756534881EC????????8B318B41??4889CB",
    "48895C24??48896C24??48897424??57",
    "415541545756534881ec300100008b318b41044889cb488d4e09",
]

SEND_C2_FUNCTION_PATTERNS = [
    "55534881ec18010000488dac248000000048898db0000000488995b80000004489c044898dc8000000668985c0",
    "44894c2420664489442418488954241048894c24084881ec1801000048c74424780000000048c7842",
    "4c894c24204c89442418488954241048894c24084881ec98010000488b05ce0402004833c44889842480010000",
    "48895C24??48896C24??48897424??5741544155415641574883EC??33ED418BF9",
    "48895c240848896c241048897424185741544155415641574883ec60",
    "4157415641554154555756534881EC????????4889CD4C89C1",
    "4157415641554154555756534883EC584889CB4889D54589C44489CE",
    "4157415641554154555756534883ec5848833d68d0010000488bb424c8000000",
    "4157415641554154555756534883EC??48833D??????????488B9C24????????",
    "4157415641554154555756534883ec58",
]


@dataclasses.dataclass
class Configuration(object):
    """
    Stores the extracted WarmCookie malware configuration.
    """

    c2: list[bytes]
    campaign: list[bytes]
    rc4_key: bytes
    mutex: list[bytes]


class EncryptedStringDescriptor(ctypes.Structure):
    """
    Defines the structure of an encrypted string descriptor in memory.
    """

    _pack_ = 1
    _fields_ = [
        ("length", ctypes.c_uint32),
        ("rc4_key", ctypes.c_uint32),
    ]


@dataclasses.dataclass
class EncryptedString(object):
    """
    Represents an encrypted string found in the malware binary.
    """

    address: int
    rc4_key: int
    data: bytes
    decryption_function_call_address: int


def decrypt_strings(encrypted_strings: list[EncryptedString]) -> list[bytes]:
    """
    Decrypts a list of EncryptedString objects using their respective RC4 keys.

    :param encrypted_strings: A list of `EncryptedString` objects to decrypt.
    :return: A list of decrypted strings as bytes.
    """

    results = []
    for encrypted_string in encrypted_strings:
        cipher = ARC4.new(encrypted_string.rc4_key.to_bytes(4, "little"))
        data = cipher.decrypt(encrypted_string.data)
        results.append(data)

    return results


def extract_configuration(binary: bytes) -> Configuration:
    """
    Extracts the full malware configuration by orchestrating the decryption process.

    :param binary: The malware binary content.
    :return: A `Configuration` object containing the extracted data.
    :exception RuntimeError: If no encrypted strings are found in the binary.
    """

    if not (encrypted_strings := get_encrypted_strings(binary)):
        raise RuntimeError("No encrypted string found")

    return parse_configuration(decrypt_strings(encrypted_strings), get_port(binary))


def is_port_near_c2(binary: bytes, port_cand_addr: int, c2_list: list[int]) -> bool:
    """
    Checks if a port candidate address is referenced near a call to the C2 sending function.

    :param binary: The malware binary content.
    :param port_cand_addr: The memory address of the port value to check.
    :param c2_list: A list of virtual addresses where the C2 sending function is called.
    :return: True if the port address is referenced nearby, False otherwise.
    """

    rz = reversing.Rizin.load(binary)

    for c2_call_sites in c2_list:
        ea = c2_call_sites
        for _ in range(20):
            instruction = rz.disassemble_previous_instruction(ea)
            ea = instruction["addr"]

            if instruction["mnemonic"] in ("mov", "movzx"):
                target_addr = instruction.get("ptr")
                if target_addr is None:
                    continue

                if port_cand_addr == target_addr:
                    return True

    return False


def get_port(binary: bytes) -> int | None:
    """
    Searches the .data section for the C2 communication port number.

    :param binary: The malware binary content.
    :return: The C2 port number as an integer, or None if not found.
    :exception RuntimeError: If the .data section is not found.
    """

    rz = reversing.Rizin.load(binary)
    sections = json.loads(rz.rizin.cmd("iSj"))
    data_section = next((s for s in sections if s.get("name") == ".data"), None)

    send_c2_calls = get_send_c2_function_call_addresses(binary)

    if not data_section:
        raise RuntimeError("No .data section found")

    start = data_section["vaddr"]
    end = start + data_section["vsize"]

    for addr in range(start, end, 4):
        port_bytes = rz.get_data(addr, 4)
        port = cast.u32(port_bytes)

        if port in PORT_VALUES and is_port_near_c2(binary, addr, send_c2_calls):
            return port

    return None


def parse_rc4_key(decrypted_str: bytes) -> bytes | None:
    """
    Identifies if a decrypted string is a hexadecimal RC4 key.

    :param decrypted_str: A decrypted string to check.
    :return: The RC4 key as bytes if it matches the pattern, otherwise None.
    """

    if 8 <= len(decrypted_str) <= 32 and regex.get_regex(
        regex.RegexOptions.HEX_STRING_REGEX, True
    ).match(decrypted_str):
        return decrypted_str.rstrip(b"\x00")

    return None


def find_rc4_key_index(decrypted_strings: list[bytes]) -> int | None:
    """
    Finds the index of the RC4 key within a list of decrypted strings.

    :param decrypted_strings: A list of decrypted strings.
    :return: The index of the RC4 key, or None if not found.
    """

    for i, decrypted_string in enumerate(decrypted_strings):
        data = decrypted_string.data
        if 8 <= len(data) <= 32 and regex.get_regex(
            regex.RegexOptions.HEX_STRING_REGEX, True
        ).match(data):
            return i

    return None


def parse_mutexes(decrypted_strings: bytes) -> list[bytes]:
    """
    Extracts GUIDs (likely mutex names) from a decrypted string.

    :param decrypted_strings: A single decrypted string to search for GUIDs.
    :return: A sorted list of unique GUID strings found.
    """

    results = []
    for m in regex.get_regex(regex.RegexOptions.GUID_REGEX, True).finditer(
        decrypted_strings
    ):
        results.append(m.group(0))

    return sorted(list(set(results)))


def get_encrypted_strings(binary: bytes) -> list[EncryptedString]:
    """
    Finds and parses all encrypted string descriptors and data in the binary.

    :param binary: The malware binary content.
    :return: A list of `EncryptedString` objects.
    """

    rz = reversing.Rizin.load(binary)

    results = []
    string_decrypt_calls = get_string_decryption_call_addresses(binary)
    for call_address in string_decrypt_calls:
        ea = call_address
        encrypted_string_descriptor_addr = None
        for _ in range(10):
            instruction = rz.disassemble_previous_instruction(ea)
            ea = instruction["addr"]

            operands = instruction["opex"]["operands"]
            if (
                len(operands)
                and "reg" == operands[0]["type"]
                and "rcx" == operands[0]["value"]
                and (tmp_addr := instruction.get("ptr"))
            ):
                encrypted_string_descriptor_addr = tmp_addr
                break

        else:
            continue

        desc_data = rz.get_data(
            encrypted_string_descriptor_addr,
            ctypes.sizeof(EncryptedStringDescriptor),
        )

        if not desc_data or len(desc_data) < ctypes.sizeof(EncryptedStringDescriptor):
            continue

        encrypted_string_descriptor = EncryptedStringDescriptor.from_buffer_copy(
            desc_data
        )

        if (
            encrypted_string_descriptor.length > len(binary)
            or encrypted_string_descriptor.length > 0x10000
            or encrypted_string_descriptor.length == 0xFFFFFFFF
            or encrypted_string_descriptor.length == 0
        ):
            continue

        encrypted_string_address = encrypted_string_descriptor_addr + ctypes.sizeof(
            EncryptedStringDescriptor
        )

        string_data = rz.get_data(
            encrypted_string_address,
            encrypted_string_descriptor.length,
        )

        if not string_data or len(string_data) < encrypted_string_descriptor.length:
            continue

        results.append(
            EncryptedString(
                encrypted_string_address,
                encrypted_string_descriptor.rc4_key,
                string_data,
                call_address,
            )
        )

    return results


def get_string_decryption_call_addresses(binary: bytes) -> list[int]:
    """
    Finds all call sites to the string decryption functions using pattern matching.

    :param binary: The malware binary content.
    :return: A sorted list of unique virtual addresses where decryption functions are called.
    """

    rz = reversing.Rizin.load(binary)

    addresses = []
    for pattern in STRING_DECRYPT_PATTERNS:
        for address in (
            x["address"]
            for x in rz.find_pattern(pattern, reversing.Rizin.PatternType.HEX_PATTERN)
        ):
            addresses += rz.get_xrefs_to(address)

    return sorted(list(set(addresses)))


def get_send_c2_function_call_addresses(binary: bytes) -> list[int]:
    """
    Finds all call sites to the C2 communication functions using pattern matching.

    :param binary: The malware binary content.
    :return: A sorted list of unique virtual addresses where C2 functions are called.
    :exception RuntimeError: If no calls to the C2 communication function are found.
    """

    rz = reversing.Rizin.load(binary)

    addr_list = []
    for pattern in SEND_C2_FUNCTION_PATTERNS:
        pattern_results = rz.find_pattern(
            pattern, reversing.Rizin.PatternType.HEX_PATTERN
        )

        for result in pattern_results:
            pattern_addr = result.get("address")

            if pattern_addr:
                xrefs = rz.get_xrefs_to(pattern_addr)
                addr_list.extend(xrefs)

            else:
                print(f"Could not extract address from result: {result}")

    if not addr_list:
        raise RuntimeError("No send C2 function calls found for any pattern")

    return sorted(list(set(addr_list)))


def parse_configuration(
    decrypted_strings: list[bytes], port: int | None
) -> Configuration:
    """
    Parses a list of decrypted strings to build the final configuration object.

    :param decrypted_strings: A list of decrypted strings.
    :param port: The C2 communication port, or None.
    :return: A `Configuration` object.
    :exception RuntimeError: If the C2 list or RC4 key cannot be parsed.
    """

    c2_list = []
    mutexes = []
    rc4_key: bytes | None = None
    campaign: bytes | None = None
    found_rc4_key_index = None
    for i, decrypted_string in enumerate(decrypted_strings):
        try:
            decrypted_string = decrypted_string.replace(b"\x00", b"")
        except:
            decrypted_string = decrypted_string

        if tmp := parse_c2(decrypted_string):
            c2_list.append(tmp)

        elif tmp := parse_mutexes(decrypted_string):
            mutexes += tmp

        elif not rc4_key and (tmp := parse_rc4_key(decrypted_string)):
            rc4_key = tmp
            found_rc4_key_index = i

    if found_rc4_key_index:
        try:
            candidate = (
                decrypted_strings[found_rc4_key_index + 1]
                .decode("utf-16")
                .encode("utf-8")
            )

        except UnicodeDecodeError:
            candidate = decrypted_strings[found_rc4_key_index + 1]

    campaign = candidate if len(candidate) < 20 else None
    mutexes = sorted(list(set(mutexes)))

    if not all([c2_list, rc4_key]):
        raise RuntimeError("Failed to parse configuration")

    if port:
        c2_list = [
            b"http" + (b"s" if port == 443 else b"") + b"://" + x for x in c2_list
        ]

    return Configuration(c2_list, campaign, rc4_key, mutexes)


def parse_c2(decrypted_string: bytes) -> bytes | None:
    """
    Parses a C2 address from a single decrypted string.

    :param decrypted_string: A decrypted string that may contain a C2 address.
    :return: The C2 address as bytes if found, otherwise None.
    """

    for x in [
        regex.RegexOptions.IP_PORT_REGEX,
        regex.RegexOptions.IP_REGEX,
        regex.RegexOptions.URL_REGEX,
        regex.RegexOptions.DOMAIN_REGEX,
    ]:
        if m := regex.get_regex(x, True).search(decrypted_string):
            value = m.group(0).rstrip(b"\x00")
            if not value.lower().endswith((b".dll", b".exe")):
                return value

    return None
