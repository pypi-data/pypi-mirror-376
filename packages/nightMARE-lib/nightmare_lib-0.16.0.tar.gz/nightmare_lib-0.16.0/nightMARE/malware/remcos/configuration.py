# coding: utf-8

from __future__ import annotations

import pathlib
import typing

import lief

from Crypto.Cipher import ARC4

from nightMARE.core import cast
from nightMARE.analysis import reversing

from nightMARE.malware.remcos import struct

KEY_SIZE_OFFSET = 0
KEY_OFFSET = 1


def get_encrypted_configuration(binary: bytes) -> bytes:
    """
    Reads the encrypted configuration from the provided binary data.

    This function parses the binary data using the `lief` library to locate and extract
    the encrypted configuration stored in the PE resources.

    :param binary: The binary data of the executable.
    :return: The encrypted configuration as bytes, or None if the configuration is not found.
    :raise RuntimeError: If the encrypted configuration cannot be retrieved.
    """

    pe = lief.parse(binary)
    for first_level_child in pe.resources.childs:
        if first_level_child.id != 10:
            continue

        for second_level_child in first_level_child.childs:
            if second_level_child.name == "SETTINGS":
                return bytes(second_level_child.childs[0].content)
    else:
        raise RuntimeError("Failed to get encrypted configuration")


def patch_encrypted_configuration(
    path: pathlib.Path, encrypted_configuration: bytes
) -> None:
    """
    Patches the encrypted configuration into a specified PE file.

    This function modifies the PE file located at `path` by replacing its existing
    encrypted configuration with the provided `encrypted_configuration` bytes.

    :param path: The path to the PE file to be patched.
    :param encrypted_configuration: The encrypted configuration to be injected into the PE file.

    """

    pe = lief.parse(path)
    for first_level_child in pe.resources.childs:
        if first_level_child.id != 10:
            continue

        for second_level_child in first_level_child.childs:
            if second_level_child.name == "SETTINGS":
                second_level_child.delete_child(0)
                second_level_child.add_data_node(
                    lief.PE.ResourceData(list(encrypted_configuration), 0)
                )

                builder = lief.PE.Builder(pe)
                builder.build_resources(True)
                builder.build()
                builder.write(str(path))
                return


def get_raw_configuration(binary: bytes) -> bytes:
    """
    Decrypts the encrypted configuration extracted from the binary.

    This function first retrieves the encrypted configuration from the binary data
    using the `get_encrypted_configuration` function, then decrypts it using the
    ARC4 cipher and returns the decrypted configuration.

    :param binary: The binary data of the executable containing the encrypted configuration.
    :return: The decrypted configuration in bytes.
    :raise RuntimeError: If the encrypted configuration cannot be decrypted.
    """

    rz = reversing.Rizin(get_encrypted_configuration(binary))
    key_size = rz.get_u8(KEY_SIZE_OFFSET)
    key = rz.get_data(KEY_OFFSET, key_size)
    return ARC4.ARC4Cipher(key).decrypt(rz.get_data(KEY_OFFSET + key_size))


def encrypt_configuration(configuration: bytes, key: bytes) -> bytes:
    """
    Encrypts the configuration using the provided key.

    This function uses the ARC4 cipher to encrypt the given configuration data
    with the specified key.

    :param configuration: The configuration to be encrypted.
    :param key: The key used for encryption.
    :return: The encrypted configuration in bytes.
    """

    return cast.p8(len(key)) + key + ARC4.ARC4Cipher(key).encrypt(configuration)


def extract_configuration(binary: bytes) -> dict[str, typing.Any]:
    """
    Extracts and unpacks the decrypted configuration from the binary data.

    This function combines the decryption process and the unpacking of the configuration
    to return the final, usable configuration data.

    :param binary: The binary data of the executable containing the encrypted configuration.
    :return: The unpacked configuration.
    """

    return struct.unpack_configuration(get_raw_configuration(binary))
