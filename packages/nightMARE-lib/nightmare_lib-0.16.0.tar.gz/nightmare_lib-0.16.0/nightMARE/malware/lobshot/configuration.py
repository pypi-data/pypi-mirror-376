# coding: utf-8

import json

from nightMARE.analysis import reversing
from nightMARE.core import regex
from nightMARE.malware.lobshot import crypto

DECRYPTION_FUNCTION_PATTERN = "8A 5A ?? 8D 52 ?? 80 EB ?? 85 FF 74 ?? C0 E0 ?? 2C ?? 0A C3 32 C1 32 C7 88 06 32 E8 83 C6 ?? 83 C5 ?? EB ??"


class Configuration(object):
    """
    Represents a configuration object containing an IP address and port number.
    """

    def __init__(self, ip: bytes, port: int):
        """
        Initialize the Configuration object with an IP address and port.

        :param ip: The IP address as a string (in bytes format initially).
        :param port: The port number as an integer.
        """

        self.ip = ip
        self.port = port

    def __repr__(self) -> str:
        """
        Provide a JSON string representation of the configuration.

        :return: A JSON-formatted string with decoded IP and port.
        """

        return json.dumps({"ip": str(self.ip, "utf-8"), "port": self.port}, indent=4)


def get_encrypted_strings(binary: bytes) -> list[bytes]:
    """
    Retrieve a list of encrypted strings from the binary.

    :param binary: The raw binary data containing encrypted strings.
    :return: A list of encrypted string byte sequences.
    """

    rz = reversing.Rizin.load(binary)

    result = []
    ea = get_encrypted_string_table(binary)
    while True:
        t = rz.get_u32(ea)
        s = rz.get_string(t)
        if not is_string_valid(s):
            break
        result.append(s)
        ea += 4

    return result


def get_encrypted_string_table(binary: bytes) -> int:
    """
    Locate the encrypted string table in the binary by analyzing instructions.

    :param binary: The raw binary data to analyze.
    :return: The offset of the encrypted string table.
    :raise RuntimeError: If the encrypted string table cannot be found.
    """

    rz = reversing.Rizin.load(binary)
    pattern_offset = rz.find_first_pattern(
        [DECRYPTION_FUNCTION_PATTERN], reversing.Rizin.PatternType.HEX_PATTERN
    )

    rz = reversing.Rizin.load(binary)
    target_register = rz.disassemble(pattern_offset, 1)[0]["opex"]["operands"][1][
        "base"
    ]

    ea = pattern_offset
    start = rz.get_function_start(pattern_offset)
    if not start:
        raise RuntimeError("Failed to find function start")

    while ea >= start:
        prev_insn = rz.disassemble_previous_instruction(ea)
        ea = prev_insn["addr"]

        if 2 != len(prev_insn["opex"]["operands"]):
            continue

        first_op = prev_insn["opex"]["operands"][0]
        second_op = prev_insn["opex"]["operands"][1]
        if (
            first_op["type"] == "reg"
            and first_op["value"] == target_register
            and second_op["type"] == "mem"
        ):
            return second_op["disp"]
    else:
        raise RuntimeError("Encrypted string table not found")


def get_strings(binary: bytes) -> list[bytes]:
    """
    Decrypt and retrieve a list of strings from the binary.

    :param binary: The raw binary data containing encrypted strings.
    :return: A list of decrypted string byte sequences.
    """

    return list(map(crypto.decrypt_string, get_encrypted_strings(binary)))


def is_string_valid(s: bytes) -> bool:
    """
    Check if a byte sequence is a valid string (lowercase ASCII letters only).

    :param s: The byte sequence to validate.
    :return: True if all bytes are lowercase ASCII letters (a-z), False otherwise.
    """

    return all(map(lambda x: 0x61 <= x <= 0x7A, s))


def extract_configuration(binary: bytes) -> Configuration:
    """
    Search the configuration IP and port within the data blob.

    :param binary: Data blob containing encrypted IP and port strings.
    :return: A Configuration object containing the decrypted IP and optionally port.
    :raise RuntimeError: If both IP and port cannot be extracted from the strings.
    """

    ip = None
    port = None
    for x in get_strings(binary):
        if ip and port:
            return Configuration(ip, port)

        if regex.get_regex(regex.RegexOptions.IP_REGEX, True).search(x):
            ip = x
        if regex.get_regex(regex.RegexOptions.PORT_REGEX, True).search(x):
            port = int(x)

    else:
        raise RuntimeError("Failed to extract IP/Port")
