# coding: "utf-8"

from struct import unpack

from nightMARE.core import bits
from nightMARE.core import cast


class RabbitState(object):
    """
    Represents the internal state of the Rabbit stream cipher.

    Attributes:
        x (list[int]): 8 32-bit state variables
        c (list[int]): 8 32-bit counter variables
        carry (int): Carry bit for counter updates
    """

    def __init__(self):
        """
        Initializes a RabbitState object with zeroed state and counter variables.



        """
        self.x = [0] * 8
        self.c = [0] * 8
        self.carry = 0


class RabbitCtx(object):
    """
    Represents the context for the Rabbit stream cipher, holding master and work states.

    Attributes:
        m (RabbitState): Master state
        w (RabbitState): Work state
    """

    def __init__(self):
        """
        Initializes a RabbitCtx object with master and work states.
        """

        self.m = RabbitState()
        self.w = RabbitState()


class Rabbit(object):
    """
    Implements the Rabbit stream cipher for encryption and decryption.

    Attributes:
        ctx (RabbitCtx): The cipher context containing master and work states
    """

    def __init__(self, key, iv):
        """
        Initializes a Rabbit cipher instance with a key and initialization vector.

        :param key: The 16-byte encryption key
        :param iv: The 8-byte initialization vector
        """

        self.ctx = RabbitCtx()
        self.set_iv(iv)
        self.set_key(key)

    def g_func(self, x):
        """
        Computes the g-function for the Rabbit cipher, used in state updates.

        :param x: The 32-bit input value
        :return: The 32-bit result of the g-function
        """

        x = x & 0xFFFFFFFF
        x = (x * x) & 0xFFFFFFFFFFFFFFFF
        result = (x >> 32) ^ (x & 0xFFFFFFFF)
        return result

    def set_key(self, key):
        """
        Sets the encryption key and initializes the master state.

        :param key: The 16-byte encryption key
        """

        key0 = cast.u32(key[0:4])
        key1 = cast.u32(key[4:8])
        key2 = cast.u32(key[8:12])
        key3 = cast.u32(key[12:16])
        s = self.ctx.m
        s.x[0] = key0
        s.x[2] = key1
        s.x[4] = key2
        s.x[6] = key3
        s.x[1] = ((key3 << 16) & 0xFFFFFFFF) | ((key2 >> 16) & 0xFFFF)
        s.x[3] = ((key0 << 16) & 0xFFFFFFFF) | ((key3 >> 16) & 0xFFFF)
        s.x[5] = ((key1 << 16) & 0xFFFFFFFF) | ((key0 >> 16) & 0xFFFF)
        s.x[7] = ((key2 << 16) & 0xFFFFFFFF) | ((key1 >> 16) & 0xFFFF)
        s.c[0] = bits.rol32(key2, 16)
        s.c[2] = bits.rol32(key3, 16)
        s.c[4] = bits.rol32(key0, 16)
        s.c[6] = bits.rol32(key1, 16)
        s.c[1] = (key0 & 0xFFFF0000) | (key1 & 0xFFFF)
        s.c[3] = (key1 & 0xFFFF0000) | (key2 & 0xFFFF)
        s.c[5] = (key2 & 0xFFFF0000) | (key3 & 0xFFFF)
        s.c[7] = (key3 & 0xFFFF0000) | (key0 & 0xFFFF)
        s.carry = 0

        for i in range(4):
            self.next_state(self.ctx.m)

        for i in range(8):
            self.ctx.m.c[i] ^= self.ctx.m.x[(i + 4) & 7]
        self.ctx.w = self.copy_state(self.ctx.m)

    def copy_state(self, state):
        """
        Creates a copy of a RabbitState object.

        :param state: The state to copy
        :return: A new RabbitState object with copied values
        """

        n = RabbitState()
        n.carry = state.carry

        for i, j in enumerate(state.x):
            n.x[i] = j
        for i, j in enumerate(state.c):
            n.c[i] = j
        return n

    def set_iv(self, iv):
        """
        Sets the initialization vector and updates the work state.

        :param iv: The 8-byte initialization vector
        """

        v = [0] * 4
        v[0] = unpack("<I", iv[0:4])[0]
        v[2] = unpack("<I", iv[4:8])[0]
        v[1] = (v[0] >> 16) | (v[2] & 0xFFFF0000)
        v[3] = ((v[2] << 16) | (v[0] & 0x0000FFFF)) & 0xFFFFFFFF
        for i in range(8):
            self.ctx.w.c[i] = self.ctx.m.c[i] ^ v[i & 3]
        tmp = []

        for cc in self.ctx.m.x:
            tmp += [cc]
        self.ctx.w.x = tmp

        for i in range(4):
            self.next_state(self.ctx.w)

    def next_state(self, state):
        """
        Advances the Rabbit cipher state to the next iteration.

        :param state: The RabbitState object to update
        """

        g = [0] * 8
        x = [0x4D34D34D, 0xD34D34D3, 0x34D34D34]
        for i in range(8):
            tmp = state.c[i]
            state.c[i] = (state.c[i] + x[i % 3] + state.carry) & 0xFFFFFFFF
            state.carry = state.c[i] < tmp
        for i in range(8):
            g[i] = self.g_func(state.x[i] + state.c[i])

        j = 7
        i = 0
        while i < 8:
            state.x[i] = (
                g[i] + bits.rol32(g[j], 16) + bits.rol32(g[j - 1], 16)
            ) & 0xFFFFFFFF
            i += 1
            j += 1
            state.x[i] = (g[i] + bits.rol32(g[j & 7], 8) + g[j - 1]) & 0xFFFFFFFF
            i += 1
            j += 1
            j &= 7

    def crypt(self, msg):
        """
        Encrypts or decrypts a message using the Rabbit stream cipher.

        :param msg: The message to encrypt or decrypt (bytes)
        :return: The encrypted or decrypted message as bytes
        """

        plain = []
        msg_len = len(msg)
        c = self.ctx
        x = [0] * 4
        start = 0
        while True:
            self.next_state(c.w)
            for i in range(4):
                x[i] = c.w.x[i << 1]
            x[0] ^= (c.w.x[5] >> 16) ^ (c.w.x[3] << 16)
            x[1] ^= (c.w.x[7] >> 16) ^ (c.w.x[5] << 16)
            x[2] ^= (c.w.x[1] >> 16) ^ (c.w.x[7] << 16)
            x[3] ^= (c.w.x[3] >> 16) ^ (c.w.x[1] << 16)
            b = [0] * 16
            for i, j in enumerate(x):
                for z in range(4):
                    b[z + 4 * i] = 0xFF & (j >> (8 * z))
            for i in range(16):
                plain.append((msg[start] ^ b[i]))
                start += 1
                if start == msg_len:
                    return bytes(plain)


def st(b):
    """
    Converts a byte sequence to a string by interpreting each byte as a character.

    :param b: The byte sequence to convert
    :return: The resulting string
    """

    a = ""
    for x in b:
        a += chr(x)
    return a
