# coding: utf-8

import typing

from Crypto.Cipher import ARC4

from nightMARE.analysis import reversing


SMOKELOADER_PATTERN_x64 = "48 89 5C 24 08 48 89 6C 24 10 48 89 74 24 18 57 41 56 41 57 48 83 EC 40 4C 8B FA 48 8B E9 E8 ?? ?? ?? ?? 48 ?? ?? ?? ?? ?? ?? 48 8B CD"

SMOKELOADER_PATTERN_x86 = (
    "51 53 55 56 57 ?? ?? ?? ?? 8B E9 E8 ?? ?? ?? ?? BA ?? ?? ?? ?? 8B CD E8"
)


RVA_TO_RAW_OFFSET = 0x400 - 0x1000


def get_encrypted_configuration(
    binary: bytes, encrypted_configuration_offset: int
) -> tuple[bytes, bytes]:
    """
    Extracts the encryption key and the encrypted configuration from the binary data.

    This function uses Rizin to extract the encryption key (4 bytes) and the
    encrypted configuration based on the offset provided.

    :param binary: The binary data containing the SmokeLoader payload.
    :param encrypted_configuration_offset: The offset where the encrypted configuration starts.

    :return: A tuple containing:
        - `key`: The encryption key (4 bytes).
        - `encrypted_configuration`: The encrypted configuration data.
    """

    rz = reversing.Rizin.load(binary)
    encrypted_configuration_size = rz.get_u8(encrypted_configuration_offset)
    key = rz.get_data(encrypted_configuration_offset + 1, 4)
    encrypted_configuration = rz.get_data(
        encrypted_configuration_offset + 5, encrypted_configuration_size
    )
    return key, encrypted_configuration


def get_configuration(
    binary: bytes, encrypted_configuration_offset: int
) -> dict[str, typing.Any]:
    """
    Decrypts the configuration from the binary data using the extracted encryption key.

    This function retrieves the encrypted configuration and decrypts it using ARC4
    with the provided encryption key, then returns the decrypted configuration.

    :param binary: The binary data containing the encrypted configuration.
    :param encrypted_configuration_offset: The offset of the encrypted configuration.

    :return: A dictionary containing the decrypted configuration:
        - `c2`: The decrypted C2 configuration (as bytes).
    """

    key, encrypted_configuration = get_encrypted_configuration(
        binary, encrypted_configuration_offset
    )
    return {"c2": ARC4.new(key).decrypt(encrypted_configuration)}


def get_encrypted_configuration_offset_32(
    binary: bytes, config_decryption_function_offset: int
) -> int:
    """
    Disassembles the binary to find the offset where the encrypted configuration is located
    in a 32-bit binary.

    This function uses Rizin to disassemble the binary starting from the given offset,
    looking for the address where the encrypted configuration is stored.

    :param binary: The binary data to disassemble.
    :param config_decryption_function_offset: The offset to start disassembling from.

    :return: The offset where the encrypted configuration is located (RVA to raw).
    """

    rz = reversing.Rizin.load(binary)
    rz.set_bits(32)
    ea = rz.get_previous_instruction_offset(config_decryption_function_offset)
    while True:
        instruction = rz.disassemble_next_instruction(ea)
        operands = instruction["opex"]["operands"]

        if (
            len(operands) > 1
            and instruction["mnemonic"] == "mov"
            and operands[0]["type"] == "reg"
            and operands[0]["value"] == "edx"
            and operands[1]["type"] == "imm"
        ):
            return (operands[1]["value"] + RVA_TO_RAW_OFFSET) & 0xFFFF

        elif instruction["type"] in ["jmp", "cjmp", "ret"]:
            raise RuntimeError("Failed to get encryption offset")

        ea = instruction["addr"]


def get_encrypted_configuration_offset_64(
    binary: bytes, config_decryption_function_offset: int
) -> int:
    """
    Disassembles the binary to find the offset where the encrypted configuration is located
    in a 64-bit binary.

    This function uses Rizin to disassemble the binary starting from the given offset,
    looking for the address where the encrypted configuration is stored in 64-bit mode.

    :param binary: The binary data to disassemble.
    :param config_decryption_function_offset: The offset to start disassembling from.

    :return: The offset where the encrypted configuration is located (RVA to raw).
    """

    rz = reversing.Rizin.load(binary)
    rz.set_bits(64)
    offset = rz.get_previous_instruction_offset(config_decryption_function_offset)
    ea = offset
    while True:
        instruction = rz.disassemble_next_instruction(ea)
        operands = instruction["opex"]["operands"]

        if (
            len(operands) > 1
            and instruction["mnemonic"] == "lea"
            and operands[0]["type"] == "reg"
            and operands[0]["value"] == "rdx"
            and operands[1]["type"] == "mem"
        ):
            return operands[1]["disp"] + instruction["addr"] + instruction["size"]

        elif instruction["type"] in ["jmp", "cjmp", "ret"]:
            raise RuntimeError("Failed to get encryption offset")

        ea = instruction["addr"]


def get_configuration_decryption_function_offset(
    binary: bytes,
) -> tuple[bool, int]:
    """
    Finds the offset of the configuration decryption function by searching for a pattern in the binary.

    This function uses Rizin to search for predefined patterns specific to either
    a 32-bit or 64-bit binary to identify where the configuration decryption function starts.

    :param binary: The binary data to search.

    :return: A tuple containing:
        - A boolean indicating whether the binary is 64-bit (`True`) or 32-bit (`False`).
        - The offset where the configuration decryption function is located.
    """

    rz = reversing.Rizin.load(binary)
    if x := rz.find_pattern(
        SMOKELOADER_PATTERN_x64, reversing.Rizin.PatternType.HEX_PATTERN
    ):
        return True, x[0]["address"]
    elif x := rz.find_pattern(
        SMOKELOADER_PATTERN_x86, reversing.Rizin.PatternType.HEX_PATTERN
    ):
        return False, x[0]["address"]
    else:
        raise RuntimeError("Failed to get config decryption function offset")


def extract_configuration(binary: bytes) -> dict[str, typing.Any]:
    """
    Extracts the configuration from the SmokeLoader binary.

    This function determines whether the binary is 32-bit or 64-bit, retrieves the decryption
    function offset, and extracts the configuration by decrypting the encrypted configuration
    stored in the binary.

    :param binary: The binary data from which to extract the configuration.

    :return: A dictionary containing the extracted and decrypted configuration.
        - `c2`: The decrypted C2 configuration as bytes.
    """

    is_x64, configuration_decryption_function_offset = (
        get_configuration_decryption_function_offset(binary)
    )

    return get_configuration(
        binary,
        (
            get_encrypted_configuration_offset_64(
                binary, configuration_decryption_function_offset
            )
            if is_x64
            else get_encrypted_configuration_offset_32(
                binary, configuration_decryption_function_offset
            )
        ),
    )
