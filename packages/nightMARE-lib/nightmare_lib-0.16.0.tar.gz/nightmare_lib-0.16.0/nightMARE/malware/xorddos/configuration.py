# coding: utf-8

import typing
import re

from nightMARE.analysis import reversing
from nightMARE.core import bits
from nightMARE.core import utils


C2_REGEX = re.compile(rb"^((\w+\.)+[a-zA-Z]{2,}:\d+\|?)+$")

DECRYPTION_FUNCTION_PATTERN = (
    "c1 f8 1f c1 e8 1c 8d 14 01 83 e2 0f 29 c2 0f b6 82 68 08 0d 08 30 04 19 83 c1 01"
)

SIZE = 0x200


def extract_configuration(binary: bytes) -> dict[str, typing.Any]:
    """
    Retrieves a configuration object based on the provided binary and aggressiveness
    level.

    This function extracts a configuration dictionary from the provided binary data by
    identifying the decryption function, retrieving the decryption key, and parsing
    the decrypted strings into a structured format. It combines the parsed configuration
    with the key used for decryption.

    :param binary: The binary data of the Xorddos ELF file.
    :return: The configuration object extracted from the binary as a dictionary.
    """
    decryption_function_offset = get_decryption_function(binary)
    key = get_key(binary, decryption_function_offset)
    return parse_configuration(
        get_strings(
            binary,
            key,
            decryption_function_offset,
        )
    ) | {"key": key}


def get_decryption_function(binary: bytes) -> int:
    rz = reversing.Rizin.load(binary)
    if not (
        f := rz.get_function_start(
            rz.find_first_pattern(
                [DECRYPTION_FUNCTION_PATTERN], reversing.Rizin.PatternType.HEX_PATTERN
            )
        )
    ):
        raise RuntimeError("Failed to find decryption function")
    return f


def get_encrypted_candidates(
    binary: bytes, decrypted_function_offset: int
) -> list[bytes]:
    """
    Retrieves a list of encrypted data candidates from the binary.

    This function uses Rizin to find references to the decryption function offset,
    extracts data blocks of a specified size from those references, and returns them
    as a list of byte sequences.

    :param binary: The binary data to analyze.
    :param decrypted_function_offset: The offset of the decryption function.
    :return: A list of encrypted byte sequences extracted from the binary.
    """

    rz = reversing.Rizin.load(binary)
    candidates = []
    for xref in rz.get_xrefs_to(decrypted_function_offset):
        if not (function_start := rz.get_function_start(xref)):
            continue

        if not (references := rz.get_function_references(function_start)):
            continue

        for reference in references:
            if reference["type"] == "DATA":
                candidates.append(rz.get_data(reference["to"], SIZE))
    return candidates


def get_key(binary: bytes, decryption_function_offset: int) -> bytes:
    """
    Extracts the decryption key from the binary.

    This function uses Rizin to locate data references to the decryption function
    offset and retrieves the string at that location as the decryption key. If no key
    is found, it raises an exception.

    :param binary: The binary data containing the key.
    :param decryption_function_offset: The offset of the decryption function.
    :return: The decryption key as an integer.
    :raise RuntimeError: If the key cannot be retrieved from the binary.
    """

    rz = reversing.Rizin.load(binary)
    for ref in rz.get_function_references(decryption_function_offset):
        if ref["type"] == "DATA":
            return rz.get_string(ref["to"])
    raise RuntimeError("Failed to get key")


def get_strings(
    binary: bytes, key: bytes, decryption_function_offset: int
) -> list[bytes]:
    """
    Decrypts and extracts printable strings from the binary.

    This function retrieves encrypted candidates, decrypts them using the provided key
    via XOR operation, splits the result, and attempts to decode the segments into
    printable strings using UTF-16-BE or UTF-8 encodings. Only printable strings are
    returned as UTF-8 encoded bytes.

    :param binary: The binary data to extract strings from.
    :param key: The decryption key in bytes.
    :param decryption_function_offset: The offset of the decryption function.
    :return: A list of decrypted, printable strings encoded as UTF-8 bytes.
    """

    candidates = []
    for encrypted_candidate in get_encrypted_candidates(
        binary, decryption_function_offset
    ):
        for decrypted_candidate in bits.xor(encrypted_candidate, key).split(
            b"\x00\x00"
        ):
            try:
                candidate = decrypted_candidate.decode("utf-16-be")
            except UnicodeDecodeError:
                try:
                    candidate = decrypted_candidate.decode("utf-8")
                except UnicodeDecodeError:
                    continue

            if candidate and candidate.isprintable():
                candidates.append(candidate.encode("utf-8"))

    return candidates


def parse_configuration(candidates: list[bytes]) -> dict[str, typing.Any]:
    """
    Parses a list of byte strings into a configuration dictionary.

    This function processes a list of byte strings, identifying and categorizing them
    as either C2 (command and control) server addresses or URLs based on predefined
    regular expressions. It returns a dictionary with the parsed results.

    :param candidates: A list of byte strings to parse.
    :return: A dictionary containing lists of C2 addresses and URLs.
    """

    c2 = []
    urls = []

    for candidate in candidates:
        if match := C2_REGEX.match(candidate):
            c2 += match.group(0).split(b"|")
        elif utils.is_url(candidate):
            urls.append(candidate)

    return {"c2": c2, "urls": urls}
