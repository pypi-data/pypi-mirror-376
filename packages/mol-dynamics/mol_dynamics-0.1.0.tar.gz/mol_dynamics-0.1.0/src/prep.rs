//! Contains setup code, including applying forcefield data to our specific
//! atoms.

// Notes to square away the 3 "atom name" / "Amber atom type" / "force field type" keys.
// This guide shows Type 1. https://emleddin.github.io/comp-chem-website/AMBERguide-AMBER-atom-types.html,
//
// Update: "Type 1" = "type_in_res" in our code now. "Type 2" = "ff_type" for AAs, and "Type 3" = "ff_type" for small mols.
//
// Type 1 Examples: "CA", "HA", "CZ", "HB3", "HH22", HZ2", "N", "H", "HG3", "O", "CD", "C", "HG23", "CG", "CB", "CG1", "HE2", "HB3",
// Type 1 Sources: `amino19.lib`, col 0. mmCIF atom coordinate files.
//
// Type 2 Examples:  "HC", "C8", "HC", "H"(both), "XC", "N"(both), "H"(both), "H1", "CT", "OH", "HO", "2C",
// Type 2 Sources: `amino19.lib` (AA/protein partial charges), col 1. `frcmod.ff19SB`. (AA/protein params)
//
// Small Mol/lig:
// Type 3 Examples: "oh", "h1", "ca", "o", "os", "c6", "n3", "c3"
// Type 3 Sources: `.mol2` generated by Amber. (Small mol coordinates and partial charges) `gaff2.dat` (Small molg params)
//
// MOl2 for ligands also have "C10", "O7" etc, which is ambiguous here, and not required, as their params
// use Type 3, which is present. It's clear what to do for ligand
//
// Best guess: Type 1 identifies labels within the residue only. Type 2 (AA) and Type 3 (small mol) are the FF types.

use std::{
    collections::{HashMap, HashSet},
    fmt,
    thread::park_timeout_ms,
};

#[cfg(feature = "encode")]
use bincode::{Decode, Encode};
use bio_files::{
    AtomGeneric, BondGeneric,
    md_params::{AngleBendingParams, BondStretchingParams, ForceFieldParams, LjParams, MassParams},
};
use itertools::Itertools;
use na_seq::Element;

use crate::{
    AtomDynamics, MdState, ParamError, neighbors::build_neighbors, params::ForceFieldParamsIndexed,
};

/// Add items from one parameter set to the other. If there are duplicates, the second set's overrides
/// the baseline.
pub fn merge_params(baseline: &ForceFieldParams, add_this: &ForceFieldParams) -> ForceFieldParams {
    let mut merged = baseline.clone();

    merged.mass.extend(add_this.mass.clone());
    merged.lennard_jones.extend(add_this.lennard_jones.clone());

    merged.bond.extend(add_this.bond.clone());
    merged.angle.extend(add_this.angle.clone());
    merged.dihedral.extend(add_this.dihedral.clone());
    merged.improper.extend(add_this.improper.clone());

    // merged.mass.reserve(add_this.mass.len());
    // for (k, v) in &add_this.mass {
    //     merged.mass.insert(k.clone(), v.clone());
    // }
    //
    // merged.lennard_jones.reserve(add_this.lennard_jones.len());
    // for (k, v) in &add_this.lennard_jones {
    //     merged.lennard_jones.insert(k.clone(), v.clone());
    // }
    //
    // merged.bond.reserve(add_this.bond.len());
    // for (k, v) in &add_this.bond {
    //     merged.bond.insert(k.clone(), v.clone());
    // }
    //
    // merged.angle.reserve(add_this.angle.len());
    // for (k, v) in &add_this.angle {
    //     merged.angle.insert(k.clone(), v.clone());
    // }
    //
    // merged.dihedral.reserve(add_this.dihedral.len());
    // for (k, v) in &add_this.dihedral {
    //     merged.dihedral.insert(k.clone(), v.clone());
    // }
    //
    // merged.improper.reserve(add_this.improper.len());
    // for (k, v) in &add_this.improper {
    //     merged.improper.insert(k.clone(), v.clone());
    // }

    merged
}

// /// Helper that reduces repetition. Used for populating all bonded parameters by index.
// fn ff_type_from_idx<'a>(
//     atoms: &'a [AtomGeneric],
//     idx: usize,
//     descriptor: &str,
// ) -> Result<&'a String, ParamError> {
//     let atom = &atoms[idx];
//
//     atom.force_field_type.as_ref().ok_or_else(|| {
//         ParamError::new(&format!(
//             "MD failure: Atom missing FF type on {descriptor}: {atom}"
//         ))
//     })
// }

#[derive(Clone, Default, Debug)]
pub(crate) struct HydrogenRigidConstraint {
    /// Atom indices, of the dynamic set.
    pub atom_0: usize,
    pub atom_1: usize,
    /// A cache vs storing r_0. This is the target distance to maintain.
    pub r0_sq: f64,
    /// 1.0 / ai.mass + 1.0 / aj.mass; a cache. Set on the first step.
    pub inv_mass: Option<f64>,
}

// /// See notes on `HydrogenConstraint` for more information.
// #[derive(Clone, Debug)]
// pub(crate) enum HydrogenConstraintInner {
//     /// The constraints here are atom indices of each bond to H, and r_0 as defined in the Amber
//     /// param data. (We don't need k_b, as the bond is fixed len). The final value is a cached r_0^2
//     Constrained(Vec<HydrogenRigidConstraint>),
//     Flexible,
// }

// impl Default for HydrogenConstraintInner {
//     fn default() -> Self {
//         Self::Constrained(Vec::new())
//     }
// }

/// We use this variant in the configuration API. Deferrs to `HydrogenConstraintInner` for holding
/// constraints.
#[cfg_attr(feature = "encode", derive(Encode, Decode))]
#[derive(Clone, Copy, Default, PartialEq, Debug)]
pub enum HydrogenConstraint {
    /// Uses Shake and Rattle to fix the hydrogen positions. This allows for a larger timestep,
    /// e.g. 2fs instead of 1fs.
    #[default]
    Constrained,
    /// Uses the same bonded parameters as elsewhere: A spring model
    Flexible,
}

impl fmt::Display for HydrogenConstraint {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            HydrogenConstraint::Constrained => write!(f, "Constrained"),
            HydrogenConstraint::Flexible => write!(f, "Flexible"),
        }
    }
}

/// Associate loaded Force field data (e.g. from Amber) into the atom indices used in a specific
/// dynamics sim. This handles combining general and molecule-specific parameter sets, and converting
/// between atom name, and the specific indices of the atoms we're using.
///
/// This code is straightforward if params are available; much of the logic here is related to handling
/// missing parameters.
impl ForceFieldParamsIndexed {
    pub fn new(
        params: &ForceFieldParams,
        // params_specific: Option<&ForceFieldParams>,
        // atoms: &[AtomGeneric],
        atoms: &[AtomDynamics],
        // bonds: &[BondGeneric],
        adjacency_list: &[Vec<usize>],
        // Mutable, since we load the hydrogen r0s into it, instead of adding bond stretching params
        // in case of fixed hydrogen.
        // h_constraints: &mut HydrogenConstraintInner,
        h_constraint: HydrogenConstraint,
    ) -> Result<Self, ParamError> {
        let mut result = Self::default();

        // Combine the two force field sets. When a value is present in both, refer the lig-specific
        // one.
        // let params = merge_params(params_general, params_specific);

        for (i, atom) in atoms.iter().enumerate() {
            // let ff_type = match &atom.force_field_type {
            //     Some(ff_t) => ff_t,
            //     None => {
            //         eprintln!("Atom missing FF type: {atom}");
            //         match atom.element {
            //             Element::Carbon => {
            //                 eprintln!(
            //                     "Indexing: Atom missing FF type: {atom}; Falling back to generic C"
            //                 );
            //                 "C"
            //             }
            //             Element::Nitrogen => {
            //                 eprintln!(
            //                     "Indexing: Atom missing FF type: {atom}; Falling back to generic N"
            //                 );
            //                 "N"
            //             }
            //             Element::Oxygen => {
            //                 eprintln!(
            //                     "Indexing: Atom missing FF type: {atom}; Falling back to generic O"
            //                 );
            //                 "O"
            //             }
            //             Element::Hydrogen => {
            //                 eprintln!(
            //                     "Indexing: Atom missing FF type: {atom}; Falling back to generic H"
            //                 );
            //                 "H"
            //             }
            //             _ => {
            //                 return Err(ParamError::new(&format!(
            //                     "MD failure: Atom missing FF type: {atom}"
            //                 )));
            //             }
            //         }
            //     }
            // };

            let ff_type = &atom.force_field_type;

            // Mass
            if let Some(mass) = params.mass.get(ff_type) {
                result.mass.insert(i, mass.clone());
            } else {
                if ff_type.starts_with("C") {
                    match params.mass.get("C") {
                        Some(m) => {
                            result.mass.insert(i, m.clone());
                            println!("Using C fallback mass for {ff_type}");
                        }
                        None => {
                            return Err(ParamError::new(&format!(
                                "MD failure: Missing mass params for {ff_type}"
                            )));
                        }
                    }
                } else if ff_type.starts_with("N") {
                    match params.mass.get("N") {
                        Some(m) => {
                            result.mass.insert(i, m.clone());
                            println!("Using N fallback mass for {ff_type}");
                        }
                        None => {
                            return Err(ParamError::new(&format!(
                                "MD failure: Missing mass params for {ff_type}"
                            )));
                        }
                    }
                } else if ff_type.starts_with("O") {
                    match params.mass.get("O") {
                        Some(m) => {
                            result.mass.insert(i, m.clone());
                            println!("Using O fallback mass for {ff_type}");
                        }
                        None => {
                            return Err(ParamError::new(&format!(
                                "MD failure: Missing mass params for {ff_type}"
                            )));
                        }
                    }
                } else {
                    result.mass.insert(
                        i,
                        MassParams {
                            atom_type: "".to_string(),
                            mass: atom.element.atomic_weight(),
                            comment: None,
                        },
                    );

                    println!("Missing mass params on {atom}; using element default.");

                    // return Err(ParamError::new(&format!(
                    //     "MD failure: Missing mass params for {ff_type}"
                    // )));
                }
            }

            // Lennard-Jones / van der Waals
            if let Some(vdw) = params.lennard_jones.get(ff_type) {
                result.lennard_jones.insert(i, vdw.clone());
                // If the key is missing for the given FF type in our loaded data, check for certain
                // special cases.
            } else {
                // The mass values for all 4 of these are present in frcmod.ff19sb.
                if ff_type == "2C" || ff_type == "3C" || ff_type == "C8" {
                    result
                        .lennard_jones
                        .insert(i, params.lennard_jones.get("CT").unwrap().clone());
                } else if ff_type == "CO" {
                    result
                        .lennard_jones
                        .insert(i, params.lennard_jones.get("C").unwrap().clone());
                } else if ff_type == "OXT" {
                    result
                        .lennard_jones
                        .insert(i, params.lennard_jones.get("O2").unwrap().clone());
                } else if ff_type.starts_with("N") {
                    result
                        .lennard_jones
                        .insert(i, params.lennard_jones.get("N").unwrap().clone());
                    println!("Using N fallback VdW for {atom}");
                } else if ff_type.starts_with("O") {
                    result
                        .lennard_jones
                        .insert(i, params.lennard_jones.get("O").unwrap().clone());
                    println!("Using O fallback LJ for {atom}");
                } else {
                    println!("Missing LJ params for {atom}; setting to 0.");
                    // 0. no interaction.
                    // todo: If this is "CG" etc, fall back to other carbon params instead.
                    result.lennard_jones.insert(
                        i,
                        LjParams {
                            atom_type: "".to_string(),
                            sigma: 0.,
                            eps: 0.,
                        },
                    );
                }

                // return Err(ParamError::new(&format!(
                //     "MD failure: Missing Van der Waals params for {ff_type}"
                // )));
            }
        }

        // Map from serial number fo index, for bonds and the atoms they point ot.
        // let mut index_map = HashMap::new();
        // for (i, atom) in atoms.iter().enumerate() {
        //     index_map.insert(atom.serial_number, i);
        // }

        // Bond lengths.
        // for bond in bonds {
        for (i0, neighbors) in adjacency_list.iter().enumerate() {
            for &i1 in neighbors {
                if i0 >= i1 {
                    continue; // Only add each bond once.
                }

                // todo: Be careful! Your SNs don't work when flattened.
                // let (atom_0_sn, atom_1_sn) = (bond.atom_0_sn, bond.atom_1_sn);

                // let i0 = match index_map.get(&atom_0_sn) {
                //     Some(i) => *i,
                //     None => {
                //         return Err(ParamError::new(&format!(
                //             "Missing atom {atom_0_sn} as specified in a bond"
                //         )));
                //     }
                // };
                // let i1 = match index_map.get(&atom_1_sn) {
                //     Some(i) => *i,
                //     None => {
                //         return Err(ParamError::new(&format!(
                //             "Missing atom {atom_1_sn} as specified in a bond"
                //         )));
                //     }
                // };

                let type_0 = &atoms[i0].force_field_type;
                let type_1 = &atoms[i1].force_field_type;

                let data = params
                    .bond
                    .get(&(type_0.clone(), type_1.clone()))
                    .or_else(|| params.bond.get(&(type_1.clone(), type_0.clone())))
                    .cloned();

                let Some(mut data) = data else {
                    // todo: We get this sometimes with glitched mmCIF files that have duplicate atoms
                    // todo in slightly different positions.
                    eprintln!(
                        "Missing bond parameters for {type_0}-{type_1} on {} - {}. Using a safe default.",
                        atoms[i0], atoms[i1]
                    );
                    result.bond_stretching.insert(
                        (i0.min(i1), i0.max(i1)),
                        BondStretchingParams {
                            atom_types: (String::new(), String::new()),
                            k_b: 300.,
                            r_0: (atoms[i0].posit - atoms[i1].posit).magnitude() as f32,
                            comment: None,
                        },
                    );
                    continue;
                };

                // let atom_0 = i0.min(i1);
                // let atom_1 = i0.max(i1);

                // If using fixed hydrogens, don't add these to our bond stretching params;
                // add to a separate hydrogen rigid param variable.
                if h_constraint == HydrogenConstraint::Constrained {
                    if atoms[i0].element == Element::Hydrogen
                        || atoms[i0].element == Element::Hydrogen
                    {
                        // `bonds_topology` exists separately from `bond_params` specifically so we can
                        // account for bonds to H in exclusions.
                        // We will populate inverse mass in a second loop.

                        let inv_mass = 1. / atoms[i0].mass + 1. / atoms[i0].mass;
                        println!("Inverse mass: {:?}", inv_mass); // todo: Just checking to confirm populated.

                        result
                            .bond_rigid_constraints
                            .insert((i0, i1), (data.r_0.powi(2), inv_mass));
                        result.bonds_topology.insert((i0, i1));
                        continue;
                    }
                }

                data.k_b *= 2.0;

                result.bond_stretching.insert((i0, i1), data);
                result.bonds_topology.insert((i0, i1));
            }
        }

        // Valence angles: Every connection between 3 atoms bonded linearly.
        for (ctr, neighbors) in adjacency_list.iter().enumerate() {
            if neighbors.len() < 2 {
                continue;
            }
            for (&n0, &n1) in neighbors.iter().tuple_combinations() {
                let type_n0 = &atoms[n0].force_field_type;
                let type_ctr = &atoms[ctr].force_field_type;
                let type_n1 = &atoms[n1].force_field_type;

                let mut data = match params.angle.get(&(
                    type_n0.clone(),
                    type_ctr.clone(),
                    type_n1.clone(),
                )) {
                    Some(param) => param.clone(),
                    // Try the other atom order.
                    None => {
                        match params.angle.get(&(
                            type_n1.clone(),
                            type_ctr.clone(),
                            type_n0.clone(),
                        )) {
                            Some(param) => param.clone(),
                            None => {
                                // todo: Get to the bottom of this.
                                // todo: In at least some cases, it's caused by duplicate atoms in the MMCIf file. Consider
                                // todo: sanitizing it on load.
                                println!(
                                    "Missing valence angle params {type_n0}-{type_ctr}-{type_n1} on {} - {} - {}. Using a safe default.",
                                    atoms[n0], atoms[ctr], atoms[n1]
                                );
                                // parm19.dat, HC-CT-HC
                                AngleBendingParams {
                                    atom_types: (String::new(), String::new(), String::new()),
                                    k: 35.,
                                    theta_0: 1.91113,
                                    comment: None,
                                }
                            }
                        }
                    }
                };

                // This prevents multiplying by 2 each computation at runtime.
                data.k *= 2.0;

                result.angle.insert((n0, ctr, n1), data);
            }
        }

        // Proper and improper dihedral angles.
        let mut seen = HashSet::<(usize, usize, usize, usize)>::new();

        // Proper dihedrals: Atoms 1-2-3-4 bonded linearly
        for (i1, nbr_j) in adjacency_list.iter().enumerate() {
            for &i2 in nbr_j {
                if i1 >= i2 {
                    continue;
                } // handle each j-k bond once

                for &i0 in adjacency_list[i1].iter().filter(|&&x| x != i2) {
                    for &i3 in adjacency_list[i2].iter().filter(|&&x| x != i1) {
                        if i0 == i3 {
                            continue;
                        }

                        // Canonicalise so (i1, i2) is always (min, max)
                        let idx_key = if i1 < i2 {
                            (i0, i1, i2, i3)
                        } else {
                            (i3, i2, i1, i0)
                        };
                        if !seen.insert(idx_key) {
                            continue;
                        }

                        let type_0 = &atoms[i0].force_field_type;
                        let type_1 = &atoms[i1].force_field_type;
                        let type_2 = &atoms[i2].force_field_type;
                        let type_3 = &atoms[i3].force_field_type;

                        if let Some(dihe) = params.get_dihedral(
                            &(
                                type_0.clone(),
                                type_1.clone(),
                                type_2.clone(),
                                type_3.clone(),
                            ),
                            true,
                        ) {
                            let mut dihe = dihe.clone();
                            // Divide here; then don't do it during the dyamics run.
                            dihe.barrier_height /= dihe.divider as f32;
                            dihe.divider = 1;
                            result.dihedral.insert(idx_key, dihe);
                        } else {
                            return Err(ParamError::new(&format!(
                                "MD failure: Missing dihedral params for {type_0}-{type_1}-{type_2}-{type_3}"
                            )));
                        }
                    }
                }
            }
        }

        // Improper dihedrals 2-1-3-4. Atom 3 is the hub, with the other 3 atoms bonded to it.
        // The order of the others in the angle calculation affects the sign of the result.
        // Generally only for planar configs.
        //
        // Note: The sattelites are expected to be in alphabetical order, re their FF types.
        // So, for the hub of "ca" with sattelites of "ca", "ca", and "os", the correct combination
        // to look for in the params is "ca-ca-ca-os"
        for (ctr, satellites) in adjacency_list.iter().enumerate() {
            if satellites.len() < 3 {
                continue;
            }

            // Unique unordered triples of neighbours
            for a in 0..satellites.len() - 2 {
                for b in a + 1..satellites.len() - 1 {
                    for d in b + 1..satellites.len() {
                        let (sat0, sat1, sat2) = (satellites[a], satellites[b], satellites[d]);

                        let idx_key = (sat0, sat1, ctr, sat2); // order is fixed â†’ no swap
                        if !seen.insert(idx_key) {
                            continue;
                        }

                        let type_0 = &atoms[sat0].force_field_type;
                        let type_1 = &atoms[sat1].force_field_type;
                        let type_ctr = &atoms[ctr].force_field_type;
                        let type_2 = &atoms[sat2].force_field_type;

                        // Sort satellites alphabetically; required to ensure we don't miss combinations.
                        let mut sat_types = [type_0.clone(), type_1.clone(), type_2.clone()];
                        sat_types.sort();

                        let key = (
                            sat_types[0].clone(),
                            sat_types[1].clone(),
                            type_ctr.clone(),
                            sat_types[2].clone(),
                        );

                        // In the case of improper, unlike all other param types, we are allowed to
                        // have missing values. Impropers areonly, by Amber convention, for planar
                        // hub and spoke setups, so non-planar ones will be omitted. These may occur,
                        // for example, at ring intersections.
                        if let Some(dihe) = params.get_dihedral(
                            // &(t0.clone(), t1.clone(), t_ctr.clone(), t2.clone()),
                            &key, false,
                        ) {
                            let mut dihe = dihe.clone();
                            // Generally, there is no divisor for impropers, but set it up here
                            // to be more general.
                            dihe.barrier_height /= dihe.divider as f32;
                            dihe.divider = 1;

                            // println!("\nAdding improper: {:?}", dihe);

                            result.improper.insert(idx_key, dihe);
                        }
                    }
                }
            }
        }

        Ok(result)
    }
}

impl MdState {
    /// Note: We don't call this during runtime, as we don't rebuild static there,
    /// and we don't necessarily rebuild water at the same time as dyn.
    pub(crate) fn init_neighbors(&mut self) {
        self.neighbors_nb.ref_pos_dyn = self.atoms.iter().map(|a| a.posit).collect();
        // Static refs don't change. The dyn and water positions pdate periodically.
        // self.neighbors_nb.ref_pos_static = self.atoms_static.iter().map(|a| a.posit).collect();
        self.neighbors_nb.ref_pos_water_o = self.water.iter().map(|m| m.o.posit).collect();

        self.neighbors_nb.dy_dy = build_neighbors(
            &self.neighbors_nb.ref_pos_dyn,
            &self.neighbors_nb.ref_pos_dyn,
            &self.cell,
            true,
        );

        // self.neighbors_nb.dy_static = build_neighbors(
        //     &self.neighbors_nb.ref_pos_dyn,
        //     &self.neighbors_nb.ref_pos_static,
        //     &self.cell,
        //     false,
        // );

        self.neighbors_nb.dy_water = build_neighbors(
            &self.neighbors_nb.ref_pos_dyn,
            &self.neighbors_nb.ref_pos_water_o,
            &self.cell,
            false,
        );
        self.rebuild_dy_water_inv();

        // self.neighbors_nb.water_static = build_neighbors(
        //     &self.neighbors_nb.ref_pos_water_o,
        //     &self.neighbors_nb.ref_pos_static,
        //     &self.cell,
        //     false,
        // );

        self.neighbors_nb.water_water = build_neighbors(
            &self.neighbors_nb.ref_pos_water_o,
            &self.neighbors_nb.ref_pos_water_o,
            &self.cell,
            true,
        );
    }

    /// We use this to set up optimizations defined in the Amber reference manual. `excluded` deals
    /// with sections were we skip coulomb and Vdw interactions for atoms separated by 1 or 2 bonds. `scaled14` applies a force
    /// scaler for these interactions, when separated by 3 bonds.
    pub(crate) fn setup_nonbonded_exclusion_scale_flags(&mut self) {
        // Helper to store pairs in canonical (low,high) order
        let push = |set: &mut HashSet<(usize, usize)>, i: usize, j: usize| {
            if i < j {
                set.insert((i, j));
            } else {
                set.insert((j, i));
            }
        };

        // 1-2
        for indices in &self.force_field_params.bonds_topology {
            push(&mut self.pairs_excluded_12_13, indices.0, indices.1);
        }

        // 1-3
        for (indices, _) in &self.force_field_params.angle {
            push(&mut self.pairs_excluded_12_13, indices.0, indices.2);
        }

        // 1-4. We do not count improper dihedrals here.
        for (indices, _) in &self.force_field_params.dihedral {
            push(&mut self.pairs_14_scaled, indices.0, indices.3);
        }

        // Make sure no 1-4 pair is also in the excluded set
        for p in &self.pairs_14_scaled {
            self.pairs_excluded_12_13.remove(p);
        }
    }
}
