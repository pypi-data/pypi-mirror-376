import sympy as sp
import numpy as np
from scipy.stats import spearmanr

from copul.checkerboard.biv_check_pi import BivCheckPi
from copul.families.core.biv_copula import BivCopula


class WigglyMixtureCopula(BivCopula):
    r"""
    Implements a copula as a mixture of a singular "wiggly" copula and the
    independence copula.

    This copula is generated by mixing two sources:
    1. A singular component where V = (U + ε * sin(k * 2π * U)) mod 1.
    2. The independence copula where U and V are independent Uniform(0,1).

    The mixture is controlled by a parameter δ (delta). With probability δ, a
    sample is drawn from the independence copula; with probability 1-δ, it's
    drawn from the singular wiggly curve. This approach breaks the perfect
    functional dependence, allowing for a low Chatterjee's xi while maintaining
    a high Spearman's rho.

    ---------------------
    Parameters
    ---------------------
    epsilon (ε): float, amplitude of the sine wave. A smaller epsilon leads
                 to a higher Spearman's rho. Must be in [0, 1].

    k: int, frequency of the sine wave. A higher k helps lower Chatterjee's xi.

    delta (δ): float, the mixing weight for the independence copula. A higher
               delta lowers both xi and rho. Must be in [0, 1].

    ---------------------
    Properties
    ---------------------
    - Spearman's Rho (ρ): Can be high if δ and ε are small, as most points
      follow the global monotonic trend of the wiggly curve.

    - Chatterjee's Xi (ξ): Can be low if k is high and δ is sufficiently
      large to break the perfect functional dependence from the singular part.
    """

    # Define symbolic parameters using sympy
    epsilon = sp.symbols("epsilon", positive=True)
    k = sp.symbols("k", positive=True, integer=True)
    delta = sp.symbols("delta", positive=True)
    params = [epsilon, k, delta]
    intervals = {
        "epsilon": sp.Interval(0, 1),
        "k": sp.Interval(1, sp.oo),
        "delta": sp.Interval(0, 1),
    }

    def __init__(self, epsilon=0.1, k=40, delta=0.25):
        """
        Initializes the WigglyMixtureCopula.

        Args:
            epsilon (float): Amplitude of the oscillation. Default is 0.1.
            k (int): Frequency of the oscillation. Default is 40.
            delta (float): Mixture weight for independence. Default is 0.25.
        """
        if not (0 <= epsilon <= 1):
            raise ValueError("Parameter 'epsilon' must be between 0 and 1.")
        if not (isinstance(k, int) and k > 0):
            raise ValueError("Parameter 'k' must be a positive integer.")
        if not (0 <= delta <= 1):
            raise ValueError("Parameter 'delta' must be between 0 and 1.")

        super().__init__(epsilon=epsilon, k=k, delta=delta)
        self.epsilon_val = epsilon
        self.k_val = k
        self.delta_val = delta

    def _g(self, u_values):
        """
        The private generating function for the singular "wiggly" component.
        """
        return (
            u_values + self.epsilon_val * np.sin(self.k_val * 2 * np.pi * u_values)
        ) % 1

    def sample(self, n=1000):
        """
        Generate n samples from the mixture copula.

        Args:
            n (int): The number of samples to generate.

        Returns:
            numpy.ndarray: An array of shape (n, 2) with the generated samples.
        """
        if not isinstance(n, int) or n <= 0:
            raise ValueError("Number of samples 'n' must be a positive integer.")

        # Decide for each sample which component to draw from
        mixture_draw = np.random.rand(n)
        is_independent = mixture_draw < self.delta_val
        n_independent = np.sum(is_independent)
        n_wiggly = n - n_independent

        # Generate samples for both components
        u_sample = np.random.rand(n)
        v_sample = np.zeros(n)

        # Fill in samples from the wiggly component
        if n_wiggly > 0:
            v_sample[~is_independent] = self._g(u_sample[~is_independent])

        # Fill in samples from the independence component
        if n_independent > 0:
            v_sample[is_independent] = np.random.rand(n_independent)

        return np.vstack((u_sample, v_sample)).T

    def rvs(self, n=1, **kwargs):
        """Alias for sample, for compatibility with some libraries."""
        return self.sample(n)

    @staticmethod
    def _chatterjee_xi_from_sample(x, y):
        """
        A static helper method to calculate Chatterjee's Xi from a sample.
        """
        n = len(x)
        if n < 2:
            return 0.0
        idx = np.argsort(x)
        y_sorted = y[idx]
        ranks = np.argsort(np.argsort(y_sorted)) + 1
        sum_abs_diff = np.sum(np.abs(np.diff(ranks)))
        xi_n = 1 - (3 * sum_abs_diff) / (n**2 - 1)
        return xi_n

    def get_rho(self, n_samples=5000):
        """Numerically compute Spearman's Rho by generating a large sample."""
        samples = self.sample(n_samples)
        rho, _ = spearmanr(samples[:, 0], samples[:, 1])
        return rho

    def get_xi(self, n_samples=5000):
        """Numerically compute Chatterjee's Xi by generating a large sample."""
        samples = self.sample(n_samples)
        return self._chatterjee_xi_from_sample(samples[:, 0], samples[:, 1])

    # -------- Symbolic and Metadata Properties -------- #

    @property
    def is_absolutely_continuous(self) -> bool:
        # The mixture contains a singular component, so it is not AC.
        return False

    @property
    def is_symmetric(self) -> bool:
        return False


# ---------------- Demo ---------------- #
if __name__ == "__main__":
    # 1. Instantiate the copula with parameters designed to meet the criteria
    #    (rho > 0.5, xi < 0.1)
    wiggly_copula = WigglyMixtureCopula(epsilon=0.1, k=20)
    samples = wiggly_copula.rvs(20000)
    ccop = BivCheckPi.from_data(samples)
    # ccop.plot_pdf()
    print(f"Spearman's Rho: {wiggly_copula.get_rho()}")
    print(f"Chatterjee's Xi: {wiggly_copula.get_xi()}")
    print("Done!")
