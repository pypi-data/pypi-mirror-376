---
title: Router API
description: Organize and group API endpoints with routers
---

import { Aside } from '@astrojs/starlight/components';

## Router Class

Routers allow you to organize related endpoints together and apply common configuration like prefixes, tags, and middleware.

### Basic Router

```python
from zenith import Router

# Create router
router = Router()

@router.get("/")
async def list_items():
    return {"items": []}

@router.post("/")
async def create_item(item: dict):
    return {"created": item}

@router.get("/{item_id}")
async def get_item(item_id: int):
    return {"item_id": item_id}
```

### Router with Configuration

```python
from zenith import Router

router = Router(
    prefix="/api/v1/users",
    tags=["Users"],
    responses={
        404: {"description": "User not found"},
        422: {"description": "Validation error"}
    }
)

@router.get("/")
async def list_users():
    """List all users."""
    return {"users": []}

@router.post("/")
async def create_user(user: UserCreate):
    """Create a new user."""
    return {"user": user}
```

## Router Parameters

### `prefix`

Add a common prefix to all routes:

```python
# Router with prefix
api_router = Router(prefix="/api/v1")
user_router = Router(prefix="/users")
post_router = Router(prefix="/posts")

@user_router.get("/")  # Becomes /users/
async def list_users():
    return {"users": []}

@post_router.get("/")  # Becomes /posts/
async def list_posts():
    return {"posts": []}

# Include in main router
api_router.include_router(user_router)
api_router.include_router(post_router)

# Include in app (final paths: /api/v1/users/, /api/v1/posts/)
app.include_router(api_router)
```

### `tags`

Group endpoints in OpenAPI documentation:

```python
# Separate routers by feature
user_router = Router(prefix="/users", tags=["Users"])
auth_router = Router(prefix="/auth", tags=["Authentication"])
admin_router = Router(prefix="/admin", tags=["Administration"])

@user_router.get("/")
async def list_users():
    return {"users": []}

@auth_router.post("/login")
async def login(credentials: LoginRequest):
    return {"token": "..."}    
```

### `dependencies`

Apply dependencies to all routes in the router:

```python
from zenith import Router, Depends
from zenith.auth import get_current_user

# All routes require authentication
protected_router = Router(
    prefix="/protected",
    dependencies=[Depends(get_current_user)]
)

@protected_router.get("/profile")
async def get_profile():
    # User already authenticated via router dependency
    return {"profile": "..."}

@protected_router.post("/settings")
async def update_settings(settings: UserSettings):
    return {"updated": True}
```

### `responses`

Define common response schemas:

```python
common_responses = {
    400: {"description": "Bad Request", "model": ErrorResponse},
    401: {"description": "Unauthorized", "model": ErrorResponse},
    404: {"description": "Not Found", "model": ErrorResponse},
    500: {"description": "Internal Server Error", "model": ErrorResponse}
}

router = Router(
    prefix="/users",
    tags=["Users"],
    responses=common_responses
)

@router.get("/{user_id}", responses={
    200: {"model": UserResponse}
})
async def get_user(user_id: int):
    # Inherits common responses + adds 200 response
    return {"user": "..."}
```

## Route Methods

### HTTP Methods

```python
router = Router(prefix="/items")

@router.get("/")  # GET /items/
async def list_items():
    return {"items": []}

@router.post("/")  # POST /items/
async def create_item(item: ItemCreate):
    return {"created": item}

@router.get("/{item_id}")  # GET /items/{item_id}
async def get_item(item_id: int):
    return {"item_id": item_id}

@router.put("/{item_id}")  # PUT /items/{item_id}
async def update_item(item_id: int, item: ItemUpdate):
    return {"updated": item_id}

@router.patch("/{item_id}")  # PATCH /items/{item_id}
async def partial_update(item_id: int, item: ItemPartial):
    return {"patched": item_id}

@router.delete("/{item_id}")  # DELETE /items/{item_id}
async def delete_item(item_id: int):
    return {"deleted": item_id}

@router.head("/{item_id}")  # HEAD /items/{item_id}
async def check_item_exists(item_id: int):
    return  # Just headers, no body

@router.options("/")  # OPTIONS /items/
async def item_options():
    return {"methods": ["GET", "POST"]}
```

### Route Decorators with Parameters

```python
@router.get(
    "/{item_id}",
    response_model=ItemResponse,
    status_code=200,
    summary="Get item by ID",
    description="Retrieve a single item by its unique identifier",
    response_description="The requested item",
    tags=["Items", "Retrieval"],
    deprecated=False,
    operation_id="getItemById",
    responses={
        404: {"description": "Item not found"}
    }
)
async def get_item(item_id: int = Path(..., description="Item ID")):
    return {"item_id": item_id}
```

## Including Routers

### Basic Inclusion

```python
from zenith import Zenith, Router

# Create app
app = Zenith()

# Create routers
users_router = Router(prefix="/users")
items_router = Router(prefix="/items")

# Include in app
app.include_router(users_router)
app.include_router(items_router)
```

### Nested Router Structure

```python
# API versioning with nested routers
api_v1 = Router(prefix="/api/v1", tags=["API v1"])
api_v2 = Router(prefix="/api/v2", tags=["API v2"])

# V1 routes
users_v1 = Router(prefix="/users")
posts_v1 = Router(prefix="/posts")

api_v1.include_router(users_v1)
api_v1.include_router(posts_v1)

# V2 routes  
users_v2 = Router(prefix="/users")
posts_v2 = Router(prefix="/posts")

api_v2.include_router(users_v2)
api_v2.include_router(posts_v2)

# Include versions in main app
app.include_router(api_v1)
app.include_router(api_v2)

# Final routes:
# /api/v1/users/, /api/v1/posts/
# /api/v2/users/, /api/v2/posts/
```

### Router with Override Parameters

```python
# Original router
users_router = Router(prefix="/users", tags=["Users"])

# Include with modifications
app.include_router(
    users_router,
    prefix="/api/v1",  # Prepend to existing prefix
    tags=["API", "Users"],  # Additional tags
    dependencies=[Depends(api_key_auth)]  # Additional dependencies
)

# Final prefix: /api/v1/users
# Final tags: ["API", "Users"]
```

## Router Middleware

### Router-Specific Middleware

```python
from zenith.middleware import RateLimitMiddleware

# Create router with middleware
api_router = Router(
    prefix="/api",
    middleware=[
        RateLimitMiddleware({"requests_per_minute": 100})
    ]
)

@api_router.get("/data")
async def get_data():
    # Rate limiting applied only to this router's routes
    return {"data": "..."}

# Include in app
app.include_router(api_router)
```

### Conditional Middleware

```python
import os
from zenith.middleware import SecurityHeadersMiddleware, CORSMiddleware

# Different middleware for different environments
if os.getenv("ENVIRONMENT") == "production":
    middleware = [
        SecurityHeadersMiddleware({"force_https": True}),
        RateLimitMiddleware({"requests_per_minute": 60})
    ]
else:
    middleware = [
        CORSMiddleware({"allow_origins": ["*"]})
    ]

api_router = Router(
    prefix="/api",
    middleware=middleware
)
```

## Router Events

### Router Startup/Shutdown

```python
from zenith import Router

router = Router(prefix="/data")

@router.on_event("startup")
async def startup_event():
    """Initialize router resources."""
    print("Data router starting up")
    # Initialize connections, caches, etc.

@router.on_event("shutdown")
async def shutdown_event():
    """Cleanup router resources."""
    print("Data router shutting down")
    # Close connections, cleanup resources

@router.get("/")
async def get_data():
    return {"data": "..."}

# Events are executed when router is included
app.include_router(router)
```

### Multiple Event Handlers

```python
router = Router(prefix="/services")

@router.on_event("startup")
async def init_database():
    """Initialize database connection."""
    print("Initializing database...")

@router.on_event("startup")
async def init_cache():
    """Initialize cache."""
    print("Initializing cache...")

@router.on_event("startup")
async def init_external_services():
    """Connect to external services."""
    print("Connecting to external services...")

# All startup handlers will be executed in order
```

## Route Organization Patterns

### Feature-Based Organization

```python
# app/routes/users.py
from zenith import Router
from app.contexts.users import UserContext

router = Router(prefix="/users", tags=["Users"])

@router.get("/")
async def list_users(users: UserContext = Depends()):
    return await users.list_users()

@router.post("/")
async def create_user(
    user_data: UserCreate,
    users: UserContext = Depends()
):
    return await users.create_user(user_data)

# app/routes/posts.py
from zenith import Router
from app.contexts.posts import PostContext

router = Router(prefix="/posts", tags=["Posts"])

@router.get("/")
async def list_posts(posts: PostContext = Depends()):
    return await posts.list_posts()

# app/main.py
from app.routes import users, posts

app.include_router(users.router)
app.include_router(posts.router)
```

### Versioned API Structure

```python
# app/routes/v1/__init__.py
from zenith import Router
from . import users, posts, auth

router = Router(prefix="/v1", tags=["API v1"])

router.include_router(auth.router)
router.include_router(users.router)
router.include_router(posts.router)

# app/routes/v2/__init__.py
from zenith import Router
from . import users, posts, auth

router = Router(prefix="/v2", tags=["API v2"])

router.include_router(auth.router)
router.include_router(users.router)
router.include_router(posts.router)

# app/main.py
from app.routes import v1, v2

app.include_router(v1.router, prefix="/api")
app.include_router(v2.router, prefix="/api")
```

### Domain-Driven Structure

```python
# app/domains/user/routes.py
from zenith import Router
from .context import UserContext
from .models import User, UserCreate, UserUpdate

router = Router(prefix="/users", tags=["Users"])

@router.get("/", response_model=List[User])
async def list_users(users: UserContext = Depends()):
    return await users.list_users()

# app/domains/order/routes.py
from zenith import Router
from .context import OrderContext
from .models import Order, OrderCreate

router = Router(prefix="/orders", tags=["Orders"])

@router.post("/", response_model=Order)
async def create_order(
    order_data: OrderCreate,
    orders: OrderContext = Depends()
):
    return await orders.create_order(order_data)

# app/main.py
from app.domains.user.routes import router as user_router
from app.domains.order.routes import router as order_router

app.include_router(user_router)
app.include_router(order_router)
```

## Router Testing

```python
from zenith.testing import TestClient
from zenith import Zenith, Router
import pytest

# Create test router
test_router = Router(prefix="/test")

@test_router.get("/")
async def test_endpoint():
    return {"message": "test"}

@test_router.post("/items")
async def create_test_item(item: dict):
    return {"created": item}

# Test router in isolation
@pytest.mark.asyncio
async def test_router():
    app = Zenith()
    app.include_router(test_router)
    
    async with TestClient(app) as client:
        # Test GET
        response = await client.get("/test/")
        assert response.status_code == 200
        assert response.json() == {"message": "test"}
        
        # Test POST
        response = await client.post("/test/items", json={"name": "test"})
        assert response.status_code == 200
        assert response.json() == {"created": {"name": "test"}}
```

## Advanced Router Features

### Custom Route Classes

```python
from zenith.routing import APIRoute
from typing import Callable

class TimingRoute(APIRoute):
    def get_route_handler(self) -> Callable:
        original_route_handler = super().get_route_handler()
        
        async def custom_route_handler(request):
            import time
            start_time = time.time()
            response = await original_route_handler(request)
            process_time = time.time() - start_time
            response.headers["X-Process-Time"] = str(process_time)
            return response
        
        return custom_route_handler

# Use custom route class
router = Router(
    prefix="/timed",
    route_class=TimingRoute
)

@router.get("/")
async def timed_endpoint():
    return {"message": "This response includes timing headers"}
```

### Router with Custom Dependency Resolution

```python
class DatabaseRouter(Router):
    def __init__(self, db_url: str, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.db_url = db_url
    
    def get_database_session(self):
        # Custom dependency for this router
        return create_session(self.db_url)

# Use custom router
db_router = DatabaseRouter(
    db_url="postgresql://localhost/special_db",
    prefix="/special"
)

@db_router.get("/data")
async def get_special_data():
    # Uses the router's custom database session
    return {"data": "from special database"}
```

<Aside type="tip">
  **Organization Tip**: Use routers to group related functionality and apply common configuration. This keeps your API organized and makes it easier to apply cross-cutting concerns like authentication and rate limiting.
</Aside>

## Router Best Practices

1. **Group by Feature** - Organize routes by domain/feature, not by HTTP method
2. **Use Prefixes** - Apply consistent URL prefixes for better organization
3. **Tag Appropriately** - Use tags to group related endpoints in documentation
4. **Apply Common Dependencies** - Use router-level dependencies for shared requirements
5. **Version Your APIs** - Use separate routers for different API versions
6. **Keep Routers Focused** - Each router should have a single responsibility
7. **Test Routers in Isolation** - Test router functionality independently

Routers are essential for building maintainable, well-organized APIs in Zenith. They provide the structure and flexibility needed for complex applications while maintaining clean separation of concerns.