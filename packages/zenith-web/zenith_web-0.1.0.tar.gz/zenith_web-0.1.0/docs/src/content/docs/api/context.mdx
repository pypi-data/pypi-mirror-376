---
title: Context API
description: Business logic organization with the Context system
---

import { Aside } from '@astrojs/starlight/components';

## Context Class

The Context system is Zenith's approach to organizing business logic separately from web concerns. Contexts provide dependency injection, database access, and service composition.

### Basic Context

```python
from zenith import Context
from zenith.db import Session
from sqlmodel import select

class UserContext(Context):
    """User-related business logic."""
    
    def __init__(self):
        super().__init__()
        # Database session available as self.db
    
    async def create_user(self, email: str, name: str) -> User:
        """Create a new user."""
        user = User(email=email, name=name)
        self.db.add(user)
        await self.db.commit()
        await self.db.refresh(user)
        return user
    
    async def get_user_by_email(self, email: str) -> Optional[User]:
        """Find user by email address."""
        statement = select(User).where(User.email == email)
        result = await self.db.exec(statement)
        return result.first()
```

### Context with Dependency Injection

```python
from zenith import Context, Depends
from app.services.email import EmailService
from app.services.storage import StorageService

class UserContext(Context):
    """User context with service dependencies."""
    
    def __init__(
        self,
        email_service: EmailService = Depends(),
        storage: StorageService = Depends()
    ):
        super().__init__()
        self.email_service = email_service
        self.storage = storage
    
    async def register_user(self, user_data: UserCreate) -> User:
        """Register user with email verification."""
        # Check if email exists
        existing = await self.get_user_by_email(user_data.email)
        if existing:
            raise ValueError("Email already registered")
        
        # Create user
        user = User(**user_data.model_dump())
        self.db.add(user)
        await self.db.commit()
        await self.db.refresh(user)
        
        # Send welcome email
        await self.email_service.send_welcome_email(user)
        
        return user
```

## Context Properties

### Database Session

Every context has access to a database session:

```python
class ProductContext(Context):
    async def create_product(self, product_data: ProductCreate) -> Product:
        product = Product(**product_data.model_dump())
        
        # Database session available as self.db
        self.db.add(product)
        await self.db.commit()
        await self.db.refresh(product)
        
        return product
    
    async def bulk_update_prices(self, updates: List[PriceUpdate]):
        """Bulk update with transaction."""
        async with self.db.begin():  # Transaction
            for update in updates:
                product = await self.db.get(Product, update.product_id)
                if product:
                    product.price = update.new_price
        
        # Auto-commit on success, rollback on error
```

### Request Context

Access current request information:

```python
class AuditContext(Context):
    async def log_user_action(self, action: str, details: dict):
        """Log user action with request context."""
        log_entry = AuditLog(
            user_id=self.current_user.id if self.current_user else None,
            action=action,
            details=details,
            ip_address=self.request.client.host,
            user_agent=self.request.headers.get('user-agent'),
            timestamp=datetime.utcnow()
        )
        
        self.db.add(log_entry)
        await self.db.commit()
```

### Caching

Built-in caching support:

```python
from zenith.cache import cache_result

class ProductContext(Context):
    @cache_result(ttl=300)  # Cache for 5 minutes
    async def get_featured_products(self) -> List[Product]:
        """Get featured products with caching."""
        statement = select(Product).where(
            Product.is_featured == True,
            Product.is_active == True
        )
        result = await self.db.exec(statement)
        return result.all()
    
    async def update_product(self, product_id: int, updates: ProductUpdate):
        """Update product and invalidate cache."""
        product = await self.db.get(Product, product_id)
        if not product:
            return None
        
        # Update product
        for field, value in updates.model_dump(exclude_unset=True).items():
            setattr(product, field, value)
        
        await self.db.commit()
        
        # Invalidate related caches
        await self.cache.invalidate('get_featured_products')
        
        return product
```

## Using Contexts in Routes

### Basic Usage

```python
from zenith import Router, Depends
from app.contexts.users import UserContext

router = Router()

@router.post("/users")
async def create_user(
    user_data: UserCreate,
    users: UserContext = Depends()  # Automatic injection
) -> User:
    return await users.create_user(user_data)

@router.get("/users/{user_id}")
async def get_user(
    user_id: int,
    users: UserContext = Depends()
) -> User:
    user = await users.get_user(user_id)
    if not user:
        raise HTTPException(404, "User not found")
    return user
```

### Multiple Contexts

```python
@router.post("/orders")
async def create_order(
    order_data: OrderCreate,
    current_user: User = Depends(get_current_user),
    orders: OrderContext = Depends(),
    inventory: InventoryContext = Depends(),
    payments: PaymentContext = Depends()
) -> Order:
    # Check inventory
    available = await inventory.check_availability(order_data.items)
    if not available:
        raise HTTPException(400, "Items not available")
    
    # Process payment
    payment = await payments.process_payment(
        current_user.id,
        order_data.payment_method,
        order_data.total
    )
    
    # Create order
    order = await orders.create_order(
        current_user,
        order_data,
        payment_id=payment.id
    )
    
    # Update inventory
    await inventory.reserve_items(order_data.items)
    
    return order
```

## Context Composition

### Nested Contexts

```python
class OrderContext(Context):
    def __init__(
        self,
        users: UserContext = Depends(),
        products: ProductContext = Depends(),
        notifications: NotificationContext = Depends()
    ):
        super().__init__()
        self.users = users
        self.products = products
        self.notifications = notifications
    
    async def process_order(self, order_data: OrderCreate, user_id: int) -> Order:
        # Get user (using nested context)
        user = await self.users.get_user(user_id)
        if not user:
            raise ValueError("User not found")
        
        # Validate products
        for item in order_data.items:
            product = await self.products.get_product(item.product_id)
            if not product or not product.is_available:
                raise ValueError(f"Product {item.product_id} not available")
        
        # Create order
        order = Order(
            user_id=user_id,
            items=order_data.items,
            total=sum(item.price * item.quantity for item in order_data.items)
        )
        
        self.db.add(order)
        await self.db.commit()
        await self.db.refresh(order)
        
        # Send confirmation (using nested context)
        await self.notifications.send_order_confirmation(user, order)
        
        return order
```

### Context Inheritance

```python
class BaseContext(Context):
    """Base context with common functionality."""
    
    async def log_action(self, action: str, entity_id: int):
        """Log action for audit trail."""
        log = ActivityLog(
            action=action,
            entity_id=entity_id,
            user_id=self.current_user.id if self.current_user else None,
            timestamp=datetime.utcnow()
        )
        self.db.add(log)
        await self.db.commit()
    
    async def check_permission(self, permission: str) -> bool:
        """Check if current user has permission."""
        if not self.current_user:
            return False
        return permission in self.current_user.permissions

class UserContext(BaseContext):
    """User context extending base functionality."""
    
    async def update_user(self, user_id: int, updates: UserUpdate) -> User:
        # Check permission (inherited method)
        if not await self.check_permission('users:edit'):
            raise PermissionError("Insufficient permissions")
        
        user = await self.db.get(User, user_id)
        if not user:
            return None
        
        # Update user
        for field, value in updates.model_dump(exclude_unset=True).items():
            setattr(user, field, value)
        
        await self.db.commit()
        
        # Log action (inherited method)
        await self.log_action('user_updated', user_id)
        
        return user
```

## Error Handling in Contexts

```python
from zenith.exceptions import BusinessLogicError, ValidationError

class PaymentContext(Context):
    async def process_payment(
        self,
        user_id: int,
        amount: float,
        payment_method: str
    ) -> Payment:
        try:
            # Validate amount
            if amount <= 0:
                raise ValidationError("Amount must be positive")
            
            # Get user
            user = await self.db.get(User, user_id)
            if not user:
                raise ValidationError("User not found")
            
            # Check payment method
            if not user.has_payment_method(payment_method):
                raise BusinessLogicError("Payment method not available")
            
            # Process with external service
            result = await self.payment_service.charge(
                user.stripe_customer_id,
                amount,
                payment_method
            )
            
            if not result.success:
                raise BusinessLogicError(f"Payment failed: {result.error}")
            
            # Create payment record
            payment = Payment(
                user_id=user_id,
                amount=amount,
                payment_method=payment_method,
                external_id=result.transaction_id,
                status='completed'
            )
            
            self.db.add(payment)
            await self.db.commit()
            await self.db.refresh(payment)
            
            return payment
        
        except Exception as e:
            # Log error for debugging
            self.logger.error(f"Payment processing failed: {e}")
            
            # Re-raise business logic errors as-is
            if isinstance(e, (BusinessLogicError, ValidationError)):
                raise
            
            # Wrap other exceptions
            raise BusinessLogicError("Payment processing failed") from e
```

## Context Configuration

### Global Context Configuration

```python
from zenith import Zenith
from app.contexts import UserContext, ProductContext

app = Zenith()

# Configure context dependencies
app.configure_context(UserContext, {
    'cache_ttl': 300,
    'audit_enabled': True
})

app.configure_context(ProductContext, {
    'enable_inventory_sync': True,
    'price_change_notifications': True
})
```

### Environment-Specific Configuration

```python
class UserContext(Context):
    def __init__(self, config: dict = None):
        super().__init__()
        self.config = config or {}
        self.audit_enabled = self.config.get('audit_enabled', False)
        self.cache_ttl = self.config.get('cache_ttl', 60)
    
    async def create_user(self, user_data: UserCreate) -> User:
        user = User(**user_data.model_dump())
        self.db.add(user)
        await self.db.commit()
        
        # Optional audit logging
        if self.audit_enabled:
            await self.log_user_creation(user)
        
        return user
```

## Testing Contexts

```python
from zenith.testing import TestContext
import pytest

@pytest.mark.asyncio
async def test_user_creation():
    async with TestContext(UserContext) as users:
        # Create test user
        user_data = UserCreate(
            email="test@example.com",
            name="Test User"
        )
        
        user = await users.create_user(user_data)
        
        assert user.email == "test@example.com"
        assert user.name == "Test User"
        assert user.id is not None

@pytest.mark.asyncio
async def test_user_context_with_mocks():
    # Mock dependencies
    mock_email_service = Mock()
    mock_storage = Mock()
    
    async with TestContext(UserContext, {
        'email_service': mock_email_service,
        'storage': mock_storage
    }) as users:
        user_data = UserCreate(
            email="test@example.com",
            name="Test User"
        )
        
        user = await users.register_user(user_data)
        
        # Verify email service was called
        mock_email_service.send_welcome_email.assert_called_once_with(user)
        
        assert user.email == "test@example.com"
```

## Performance Considerations

### Connection Pooling

```python
class UserContext(Context):
    async def bulk_create_users(self, users_data: List[UserCreate]) -> List[User]:
        """Efficient bulk user creation."""
        users = [User(**data.model_dump()) for data in users_data]
        
        # Use bulk operations
        self.db.add_all(users)
        await self.db.commit()
        
        # Refresh all at once
        for user in users:
            await self.db.refresh(user)
        
        return users
```

### Lazy Loading

```python
class ProductContext(Context):
    @property
    def search_service(self):
        """Lazy-loaded search service."""
        if not hasattr(self, '_search_service'):
            self._search_service = SearchService()
        return self._search_service
    
    async def search_products(self, query: str) -> List[Product]:
        # Search service only initialized when needed
        return await self.search_service.search(query)
```

<Aside type="tip">
  **Best Practice**: Keep contexts focused on a single domain (Users, Orders, Products) and use composition when contexts need to interact.
</Aside>

## Context Lifecycle

1. **Creation** - Context instantiated with dependencies
2. **Database Session** - Automatic session management
3. **Request Binding** - Access to current request/user
4. **Method Execution** - Business logic execution
5. **Cleanup** - Automatic resource cleanup

Contexts handle the complete lifecycle automatically, ensuring proper resource management and transaction handling.