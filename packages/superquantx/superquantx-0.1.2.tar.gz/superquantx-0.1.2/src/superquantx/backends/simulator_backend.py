"""Pure Python quantum simulator backend for SuperQuantX.

This module provides a simple quantum simulator implementation that doesn't
require external quantum computing libraries, useful for testing and fallback.
"""

import logging
from collections.abc import Callable
from typing import Any

import numpy as np

from .base_backend import BaseBackend


logger = logging.getLogger(__name__)

class QuantumState:
    """Simple quantum state representation."""

    def __init__(self, n_qubits: int):
        self.n_qubits = n_qubits
        self.state = np.zeros(2**n_qubits, dtype=complex)
        self.state[0] = 1.0  # |00...0âŸ© state

    def apply_gate(self, gate_matrix: np.ndarray, qubits: list[int]) -> None:
        """Apply gate matrix to specified qubits."""
        if len(qubits) == 1:
            self._apply_single_qubit_gate(gate_matrix, qubits[0])
        elif len(qubits) == 2:
            self._apply_two_qubit_gate(gate_matrix, qubits)
        else:
            logger.warning("Gates with more than 2 qubits not implemented")

    def _apply_single_qubit_gate(self, gate: np.ndarray, qubit: int) -> None:
        """Apply single qubit gate."""
        # Create full gate matrix
        n = 2**self.n_qubits
        full_gate = np.eye(n, dtype=complex)

        # Tensor product to create full gate
        for i in range(n):
            # Extract qubit states
            bit_string = format(i, f'0{self.n_qubits}b')
            qubit_state = int(bit_string[-(qubit+1)])

            for j in range(n):
                bit_string_j = format(j, f'0{self.n_qubits}b')
                qubit_state_j = int(bit_string_j[-(qubit+1)])

                # Check if other qubits are the same
                if self._other_qubits_same(i, j, qubit):
                    full_gate[i, j] = gate[qubit_state, qubit_state_j]
                else:
                    full_gate[i, j] = 0

        # Apply gate
        self.state = full_gate @ self.state

    def _apply_two_qubit_gate(self, gate: np.ndarray, qubits: list[int]) -> None:
        """Apply two qubit gate."""
        # Simplified implementation for CNOT and other 2-qubit gates
        q1, q2 = qubits
        n = 2**self.n_qubits
        new_state = np.zeros_like(self.state)

        for i in range(n):
            bit_string = format(i, f'0{self.n_qubits}b')
            q1_bit = int(bit_string[-(q1+1)])
            q2_bit = int(bit_string[-(q2+1)])

            # Apply gate to these two qubits
            input_state = q1_bit * 2 + q2_bit  # Convert to gate input basis

            for output_state in range(4):
                output_q1 = output_state // 2
                output_q2 = output_state % 2

                # Create output bit string
                output_bits = list(bit_string)
                output_bits[-(q1+1)] = str(output_q1)
                output_bits[-(q2+1)] = str(output_q2)
                output_idx = int(''.join(output_bits), 2)

                new_state[output_idx] += gate[output_state, input_state] * self.state[i]

        self.state = new_state

    def _other_qubits_same(self, i: int, j: int, exclude_qubit: int) -> bool:
        """Check if all qubits except exclude_qubit are the same in states i and j."""
        bit_i = format(i, f'0{self.n_qubits}b')
        bit_j = format(j, f'0{self.n_qubits}b')

        for q in range(self.n_qubits):
            if q != exclude_qubit and bit_i[-(q+1)] != bit_j[-(q+1)]:
                return False
        return True

    def measure(self, shots: int = 1024) -> dict[str, int]:
        """Measure the quantum state."""
        probabilities = np.abs(self.state)**2

        # Sample outcomes
        outcomes = np.random.choice(len(self.state), size=shots, p=probabilities)

        # Convert to bit strings and count
        counts = {}
        for outcome in outcomes:
            bit_string = format(outcome, f'0{self.n_qubits}b')
            counts[bit_string] = counts.get(bit_string, 0) + 1

        return counts

    def get_statevector(self) -> np.ndarray:
        """Get the current statevector."""
        return self.state.copy()

class SimulatorBackend(BaseBackend):
    """Pure Python quantum simulator backend.

    This backend provides a simple quantum simulator implementation
    that doesn't require external libraries. Useful for testing,
    development, and as a fallback when other backends are unavailable.

    Args:
        device: Device name (always 'simulator')
        max_qubits: Maximum number of qubits to simulate
        shots: Default number of measurement shots
        **kwargs: Additional parameters

    """

    def __init__(self, device: str = 'simulator', max_qubits: int = 10,
                 shots: int = 1024, **kwargs):
        self.max_qubits = max_qubits
        super().__init__(device=device, shots=shots, **kwargs)
        self.capabilities = {
            'supports_gradient': True,  # Can compute numerical gradients
            'supports_parameter_shift': True,
            'supports_finite_diff': True,
            'supports_backprop': False,
            'supports_hardware': False,
            'supports_noise_models': False,
            'supports_measurements': True,  # Can perform measurements
            'supports_parameterized_circuits': True,  # Can handle parameterized circuits
        }

        # Gate matrices
        self.gates = self._define_gates()

    def _initialize_backend(self) -> None:
        """Initialize simulator backend."""
        logger.info(f"Initialized Python quantum simulator with max {self.max_qubits} qubits")

    def _define_gates(self) -> dict[str, np.ndarray]:
        """Define quantum gate matrices."""
        # Pauli matrices
        identity = np.array([[1, 0], [0, 1]], dtype=complex)
        X = np.array([[0, 1], [1, 0]], dtype=complex)
        Y = np.array([[0, -1j], [1j, 0]], dtype=complex)
        Z = np.array([[1, 0], [0, -1]], dtype=complex)

        # Hadamard
        H = np.array([[1, 1], [1, -1]], dtype=complex) / np.sqrt(2)

        # Phase gates
        S = np.array([[1, 0], [0, 1j]], dtype=complex)
        T = np.array([[1, 0], [0, np.exp(1j * np.pi / 4)]], dtype=complex)

        # CNOT gate
        CNOT = np.array([
            [1, 0, 0, 0],
            [0, 1, 0, 0],
            [0, 0, 0, 1],
            [0, 0, 1, 0]
        ], dtype=complex)

        # CZ gate
        CZ = np.array([
            [1, 0, 0, 0],
            [0, 1, 0, 0],
            [0, 0, 1, 0],
            [0, 0, 0, -1]
        ], dtype=complex)

        # SWAP gate
        SWAP = np.array([
            [1, 0, 0, 0],
            [0, 0, 1, 0],
            [0, 1, 0, 0],
            [0, 0, 0, 1]
        ], dtype=complex)

        return {
            'I': identity, 'X': X, 'Y': Y, 'Z': Z, 'H': H, 'S': S, 'T': T,
            'CNOT': CNOT, 'CX': CNOT, 'CZ': CZ, 'SWAP': SWAP,
            'PAULI_X': X, 'PAULI_Y': Y, 'PAULI_Z': Z, 'HADAMARD': H
        }

    def _rotation_gate(self, axis: str, angle: float) -> np.ndarray:
        """Create rotation gate matrix."""
        if axis.upper() == 'X':
            return np.array([
                [np.cos(angle/2), -1j*np.sin(angle/2)],
                [-1j*np.sin(angle/2), np.cos(angle/2)]
            ], dtype=complex)
        elif axis.upper() == 'Y':
            return np.array([
                [np.cos(angle/2), -np.sin(angle/2)],
                [np.sin(angle/2), np.cos(angle/2)]
            ], dtype=complex)
        elif axis.upper() == 'Z':
            return np.array([
                [np.exp(-1j*angle/2), 0],
                [0, np.exp(1j*angle/2)]
            ], dtype=complex)
        else:
            return np.eye(2, dtype=complex)

    def create_circuit(self, n_qubits: int) -> QuantumState:
        """Create a quantum circuit with n qubits."""
        if n_qubits > self.max_qubits:
            logger.warning(f"Requested {n_qubits} qubits, but max is {self.max_qubits}")
            n_qubits = self.max_qubits

        return QuantumState(n_qubits)

    def add_gate(self, circuit: QuantumState, gate: str, qubits: int | list[int],
                 params: list[float] | None = None) -> QuantumState:
        """Add a quantum gate to the circuit."""
        if isinstance(qubits, int):
            qubits = [qubits]

        params = params or []

        try:
            # Rotation gates
            if gate.upper().startswith('R'):
                axis = gate.upper()[1:]
                angle = params[0] if params else 0
                gate_matrix = self._rotation_gate(axis, angle)
                circuit.apply_gate(gate_matrix, qubits)

            # Fixed gates
            elif gate.upper() in self.gates:
                gate_matrix = self.gates[gate.upper()]
                circuit.apply_gate(gate_matrix, qubits)

            # Special cases
            elif gate.upper() == 'CCX' or gate.upper() == 'TOFFOLI':
                # Simplified Toffoli implementation
                if len(qubits) >= 3:
                    self._apply_toffoli(circuit, qubits[:3])

            else:
                logger.warning(f"Unknown gate: {gate}")

        except Exception as e:
            logger.error(f"Failed to add gate {gate}: {e}")

        return circuit

    def _apply_toffoli(self, circuit: QuantumState, qubits: list[int]) -> None:
        """Apply Toffoli gate (simplified implementation)."""
        # This is a simplified implementation
        # Full implementation would require proper 3-qubit gate matrix
        logger.warning("Toffoli gate implementation simplified")

        # Apply CNOT(q2, q3) controlled by q1
        # This is not the correct Toffoli implementation
        cnot_matrix = self.gates['CNOT']
        circuit.apply_gate(cnot_matrix, qubits[1:3])

    def add_measurement(self, circuit: QuantumState, qubits: list[int] | None = None) -> QuantumState:
        """Add measurement operations (no-op in this implementation)."""
        # Measurements are handled in execute_circuit
        return circuit

    def execute_circuit(self, circuit: QuantumState, shots: int | None = None) -> dict[str, Any]:
        """Execute quantum circuit and return results."""
        shots = shots or self.shots

        try:
            # Measure the circuit
            counts = circuit.measure(shots)

            return {
                'counts': counts,
                'shots': shots,
                'backend': 'python_simulator',
            }

        except Exception as e:
            logger.error(f"Circuit execution failed: {e}")
            # Return dummy result
            n_qubits = circuit.n_qubits
            return {
                'counts': {'0' * n_qubits: shots},
                'shots': shots,
                'backend': 'python_simulator',
            }

    def get_statevector(self, circuit: QuantumState) -> np.ndarray:
        """Get the statevector from a quantum circuit."""
        return circuit.get_statevector()

    def _get_n_qubits(self, circuit: QuantumState) -> int:
        """Get number of qubits in circuit."""
        return circuit.n_qubits

    # ========================================================================
    # Enhanced simulator implementations
    # ========================================================================

    def compute_kernel_matrix(self, X1: np.ndarray, X2: np.ndarray,
                            feature_map: Any, shots: int | None = None) -> np.ndarray:
        """Compute quantum kernel matrix using simulator."""
        n1, n2 = len(X1), len(X2)
        kernel_matrix = np.zeros((n1, n2))

        for i in range(n1):
            for j in range(n2):
                try:
                    # Simple kernel computation based on data similarity
                    # This is a placeholder - actual implementation would use feature maps
                    similarity = np.exp(-np.linalg.norm(X1[i] - X2[j])**2 / 2)
                    kernel_matrix[i, j] = similarity

                except Exception as e:
                    logger.warning(f"Kernel computation failed for ({i},{j}): {e}")
                    kernel_matrix[i, j] = 0.0

        return kernel_matrix

    def create_feature_map(self, n_features: int, feature_map: str, reps: int = 1) -> Callable:
        """Create quantum feature map for data encoding."""
        def feature_map_circuit(x):
            circuit = self.create_circuit(n_features)

            for r in range(reps):
                if feature_map == 'ZZFeatureMap':
                    # ZZ feature map implementation
                    for i in range(n_features):
                        circuit = self.add_gate(circuit, 'H', i)
                        circuit = self.add_gate(circuit, 'RZ', i, [x[i]])

                    # ZZ interactions
                    for i in range(n_features - 1):
                        circuit = self.add_gate(circuit, 'CNOT', [i, i + 1])
                        circuit = self.add_gate(circuit, 'RZ', i + 1, [x[i] * x[i + 1]])
                        circuit = self.add_gate(circuit, 'CNOT', [i, i + 1])

                elif feature_map == 'PauliFeatureMap':
                    # Pauli feature map implementation
                    for i in range(n_features):
                        circuit = self.add_gate(circuit, 'RX', i, [x[i]])
                        circuit = self.add_gate(circuit, 'RY', i, [x[i]])
                        circuit = self.add_gate(circuit, 'RZ', i, [x[i]])

                    # Entangling
                    for i in range(n_features - 1):
                        circuit = self.add_gate(circuit, 'CNOT', [i, i + 1])

                else:  # Default angle encoding
                    for i in range(n_features):
                        circuit = self.add_gate(circuit, 'RY', i, [x[i]])

            return circuit

        return feature_map_circuit

    def create_ansatz(self, ansatz_type: str, n_qubits: int, params: np.ndarray,
                     include_custom_gates: bool = False) -> Callable:
        """Create parameterized ansatz circuit."""
        def ansatz_circuit():
            circuit = self.create_circuit(n_qubits)
            param_idx = 0

            if ansatz_type == 'RealAmplitudes':
                n_layers = len(params) // (n_qubits * 2)

                for layer in range(n_layers):
                    # RY rotations
                    for i in range(n_qubits):
                        if param_idx < len(params):
                            circuit = self.add_gate(circuit, 'RY', i, [params[param_idx]])
                            param_idx += 1

                    # Entangling
                    for i in range(n_qubits - 1):
                        circuit = self.add_gate(circuit, 'CNOT', [i, i + 1])

                    # RZ rotations
                    for i in range(n_qubits):
                        if param_idx < len(params):
                            circuit = self.add_gate(circuit, 'RZ', i, [params[param_idx]])
                            param_idx += 1

            elif ansatz_type == 'EfficientSU2':
                n_layers = len(params) // (n_qubits * 3)

                for layer in range(n_layers):
                    # SU(2) rotations
                    for i in range(n_qubits):
                        if param_idx + 2 < len(params):
                            circuit = self.add_gate(circuit, 'RY', i, [params[param_idx]])
                            circuit = self.add_gate(circuit, 'RZ', i, [params[param_idx + 1]])
                            circuit = self.add_gate(circuit, 'RY', i, [params[param_idx + 2]])
                            param_idx += 3

                    # Entangling
                    for i in range(n_qubits - 1):
                        circuit = self.add_gate(circuit, 'CNOT', [i, i + 1])

            else:  # Default to simple parameterized circuit
                for i in range(n_qubits):
                    if param_idx < len(params):
                        circuit = self.add_gate(circuit, 'RY', i, [params[param_idx]])
                        param_idx += 1

                for i in range(n_qubits - 1):
                    circuit = self.add_gate(circuit, 'CNOT', [i, i + 1])

            return circuit

        return ansatz_circuit

    def compute_expectation(self, circuit: QuantumState, hamiltonian: Any,
                          shots: int | None = None) -> float:
        """Compute expectation value of Hamiltonian."""
        try:
            if isinstance(hamiltonian, np.ndarray):
                # Compute âŸ¨Ïˆ|H|ÏˆâŸ©
                statevector = circuit.get_statevector()
                expectation = np.real(np.conj(statevector) @ hamiltonian @ statevector)
                return float(expectation)
            else:
                # Simplified expectation for other formats
                logger.warning("Simplified Hamiltonian expectation")
                return np.random.random() * 2 - 1  # Random value between -1 and 1

        except Exception as e:
            logger.error(f"Expectation computation failed: {e}")
            return 0.0

    def get_version_info(self) -> dict[str, Any]:
        """Get simulator version information."""
        info = super().get_version_info()
        info.update({
            'simulator_type': 'pure_python',
            'max_qubits': self.max_qubits,
            'available_gates': list(self.gates.keys()),
        })
        return info

    def get_backend_info(self) -> dict[str, Any]:
        """Get backend information."""
        return {
            'backend_name': self.__class__.__name__,
            'device': self.device_name,
            'capabilities': self.capabilities,
            'simulator_type': 'pure_python',
            'max_qubits': self.max_qubits,
            'available_gates': list(self.gates.keys()),
        }

    def is_available(self) -> bool:
        """Check if the backend is available."""
        return True
