#!/usr/bin/env python3
"""
Exploitability Analysis Module

Analyzes vulnerabilities to determine if public exploits exist using SearchSploit
and other exploit databases, producing structured JSON records for each CVE.
"""

import subprocess
import json
import re
import os
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, asdict
from datetime import datetime


@dataclass
class ExploitInfo:
    """Information about a specific exploit"""
    title: str
    path: str
    date: Optional[str] = None
    author: Optional[str] = None
    type: Optional[str] = None
    platform: Optional[str] = None
    exploit_db_id: Optional[str] = None


@dataclass
class ExploitabilityAnalysis:
    """Complete exploitability analysis for a vulnerability"""
    cve_id: str
    component_name: str
    component_version: str
    severity: str
    cvss_score: Optional[float]
    exploits_found: List[ExploitInfo]
    exploit_count: int
    has_public_exploits: bool
    exploit_risk_level: str  # CRITICAL, HIGH, MEDIUM, LOW, NONE
    analysis_timestamp: str
    searchsploit_available: bool
    error_message: Optional[str] = None


class ExploitabilityAnalyzer:
    """Analyzes vulnerabilities for public exploit availability"""

    def __init__(self):
        self.searchsploit_path = self._find_searchsploit()
        self.exploit_db_path = self._find_exploit_db()

    def _find_searchsploit(self) -> Optional[str]:
        """Find searchsploit executable"""
        import shutil
        return shutil.which('searchsploit')

    def _find_exploit_db(self) -> Optional[str]:
        """Find exploit database path"""
        common_paths = [
            "/usr/share/exploitdb",
            "/opt/exploitdb",
            "~/.searchsploit/exploitdb",
            "/var/lib/exploitdb"
        ]
        
        for path in common_paths:
            expanded_path = os.path.expanduser(path)
            if os.path.exists(expanded_path):
                return expanded_path
        return None

    def check_prerequisites(self) -> Dict[str, Any]:
        """Check if required tools are available"""
        return {
            "searchsploit_available": self.searchsploit_path is not None,
            "searchsploit_path": self.searchsploit_path,
            "exploit_db_path": self.exploit_db_path,
            "exploit_db_available": self.exploit_db_path is not None
        }

    def search_exploits_for_cve(self, cve_id: str) -> List[ExploitInfo]:
        """Search for exploits using CVE ID"""
        exploits = []
        
        if not self.searchsploit_path:
            return exploits

        try:
            # Search using searchsploit with JSON output
            cmd = [self.searchsploit_path, "-j", cve_id]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            
            if result.returncode == 0 and result.stdout.strip():
                try:
                    data = json.loads(result.stdout)
                    if "RESULTS_EXPLOIT" in data:
                        for exploit in data["RESULTS_EXPLOIT"]:
                            exploit_info = ExploitInfo(
                                title=exploit.get("Title", "").strip(),
                                path=exploit.get("Path", "").strip(),
                                date=exploit.get("Date_Published", "").strip(),
                                author=exploit.get("Author", "").strip(),
                                type=exploit.get("Type", "").strip(),
                                platform=exploit.get("Platform", "").strip(),
                                exploit_db_id=exploit.get("EDB-ID", "").strip()
                            )
                            exploits.append(exploit_info)
                except json.JSONDecodeError:
                    # Fallback to parsing text output
                    exploits = self._parse_searchsploit_text_output(result.stdout)
            
        except subprocess.TimeoutExpired:
            print(f"⚠️  SearchSploit timeout for {cve_id}")
        except Exception as e:
            print(f"⚠️  SearchSploit error for {cve_id}: {e}")

        return exploits

    def search_exploits_for_component(self, component_name: str, version: str = None) -> List[ExploitInfo]:
        """Search for exploits using component name and version"""
        exploits = []
        
        if not self.searchsploit_path:
            return exploits

        try:
            # Build search terms
            search_terms = [component_name]
            if version:
                search_terms.extend([f"{component_name} {version}", version])

            for term in search_terms:
                cmd = [self.searchsploit_path, "-j", term]
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
                
                if result.returncode == 0 and result.stdout.strip():
                    try:
                        data = json.loads(result.stdout)
                        if "RESULTS_EXPLOIT" in data:
                            for exploit in data["RESULTS_EXPLOIT"]:
                                exploit_info = ExploitInfo(
                                    title=exploit.get("Title", "").strip(),
                                    path=exploit.get("Path", "").strip(),
                                    date=exploit.get("Date_Published", "").strip(),
                                    author=exploit.get("Author", "").strip(),
                                    type=exploit.get("Type", "").strip(),
                                    platform=exploit.get("Platform", "").strip(),
                                    exploit_db_id=exploit.get("EDB-ID", "").strip()
                                )
                                # Avoid duplicates
                                if not any(e.title == exploit_info.title and e.path == exploit_info.path for e in exploits):
                                    exploits.append(exploit_info)
                    except json.JSONDecodeError:
                        continue
                        
        except Exception as e:
            print(f"⚠️  Component search error for {component_name}: {e}")

        return exploits

    def _parse_searchsploit_text_output(self, output: str) -> List[ExploitInfo]:
        """Parse searchsploit text output as fallback"""
        exploits = []
        lines = output.strip().split('\n')
        
        for line in lines:
            if '|' in line and not line.startswith('-'):
                parts = [part.strip() for part in line.split('|')]
                if len(parts) >= 3:
                    exploit_info = ExploitInfo(
                        title=parts[0],
                        path=parts[-1],
                        date=parts[1] if len(parts) > 3 else None
                    )
                    exploits.append(exploit_info)
        
        return exploits

    def _calculate_exploit_risk_level(self, exploit_count: int, severity: str, cvss_score: Optional[float]) -> str:
        """Calculate exploit risk level based on various factors"""
        if exploit_count == 0:
            return "NONE"
        
        # Base risk on severity and CVSS score
        base_risk = 0
        if severity.upper() == "CRITICAL":
            base_risk = 4
        elif severity.upper() == "HIGH":
            base_risk = 3
        elif severity.upper() == "MEDIUM":
            base_risk = 2
        else:
            base_risk = 1

        # Adjust based on CVSS score if available
        if cvss_score:
            if cvss_score >= 9.0:
                base_risk = max(base_risk, 4)
            elif cvss_score >= 7.0:
                base_risk = max(base_risk, 3)
            elif cvss_score >= 4.0:
                base_risk = max(base_risk, 2)

        # Adjust based on number of exploits
        if exploit_count >= 5:
            base_risk = min(base_risk + 1, 4)
        elif exploit_count >= 10:
            base_risk = 4

        risk_levels = {1: "LOW", 2: "MEDIUM", 3: "HIGH", 4: "CRITICAL"}
        return risk_levels.get(base_risk, "LOW")

    def analyze_vulnerability(self, cve_id: str, component_name: str, component_version: str, 
                            severity: str, cvss_score: Optional[float] = None) -> ExploitabilityAnalysis:
        """Perform complete exploitability analysis for a vulnerability"""
        
        # Search for exploits using both CVE ID and component name
        cve_exploits = self.search_exploits_for_cve(cve_id)
        component_exploits = self.search_exploits_for_component(component_name, component_version)
        
        # Combine and deduplicate exploits
        all_exploits = cve_exploits + component_exploits
        unique_exploits = []
        seen = set()
        
        for exploit in all_exploits:
            identifier = (exploit.title, exploit.path)
            if identifier not in seen:
                seen.add(identifier)
                unique_exploits.append(exploit)

        exploit_count = len(unique_exploits)
        has_exploits = exploit_count > 0
        risk_level = self._calculate_exploit_risk_level(exploit_count, severity, cvss_score)

        return ExploitabilityAnalysis(
            cve_id=cve_id,
            component_name=component_name,
            component_version=component_version,
            severity=severity,
            cvss_score=cvss_score,
            exploits_found=unique_exploits,
            exploit_count=exploit_count,
            has_public_exploits=has_exploits,
            exploit_risk_level=risk_level,
            analysis_timestamp=datetime.now().isoformat(),
            searchsploit_available=self.searchsploit_path is not None
        )

    def analyze_vulnerability_batch(self, vulnerabilities: List[Dict[str, Any]]) -> List[ExploitabilityAnalysis]:
        """Analyze multiple vulnerabilities for exploitability"""
        results = []
        
        print(f"🔍 Analyzing {len(vulnerabilities)} vulnerabilities for public exploits...")
        
        for i, vuln in enumerate(vulnerabilities, 1):
            print(f"📊 Analyzing {i}/{len(vulnerabilities)}: {vuln.get('vulnerability_id', 'Unknown')}")
            
            analysis = self.analyze_vulnerability(
                cve_id=vuln.get('vulnerability_id', ''),
                component_name=vuln.get('pkg_name', ''),
                component_version=vuln.get('pkg_version', ''),
                severity=vuln.get('severity', ''),
                cvss_score=vuln.get('cvss_score')
            )
            results.append(analysis)
        
        return results

    def generate_exploitability_report(self, analyses: List[ExploitabilityAnalysis], 
                                     output_path: str) -> Dict[str, Any]:
        """Generate comprehensive exploitability report"""
        
        # Calculate summary statistics
        total_vulns = len(analyses)
        exploitable_vulns = sum(1 for a in analyses if a.has_public_exploits)
        critical_exploitable = sum(1 for a in analyses if a.exploit_risk_level == "CRITICAL")
        high_exploitable = sum(1 for a in analyses if a.exploit_risk_level == "HIGH")
        
        risk_breakdown = {
            "CRITICAL": sum(1 for a in analyses if a.exploit_risk_level == "CRITICAL"),
            "HIGH": sum(1 for a in analyses if a.exploit_risk_level == "HIGH"),
            "MEDIUM": sum(1 for a in analyses if a.exploit_risk_level == "MEDIUM"),
            "LOW": sum(1 for a in analyses if a.exploit_risk_level == "LOW"),
            "NONE": sum(1 for a in analyses if a.exploit_risk_level == "NONE")
        }

        # Create report structure
        report = {
            "metadata": {
                "analysis_timestamp": datetime.now().isoformat(),
                "tool_version": "vulnreach-exploitability-1.0",
                "searchsploit_available": self.searchsploit_path is not None,
                "total_vulnerabilities_analyzed": total_vulns
            },
            "summary": {
                "total_vulnerabilities": total_vulns,
                "vulnerabilities_with_exploits": exploitable_vulns,
                "exploit_availability_rate": round((exploitable_vulns / total_vulns * 100), 2) if total_vulns > 0 else 0,
                "critical_exploitable": critical_exploitable,
                "high_exploitable": high_exploitable,
                "exploit_risk_breakdown": risk_breakdown
            },
            "vulnerability_analyses": [asdict(analysis) for analysis in analyses],
            "high_priority_vulnerabilities": [
                asdict(analysis) for analysis in analyses 
                if analysis.exploit_risk_level in ["CRITICAL", "HIGH"]
            ]
        }

        # Write report to file
        with open(output_path, 'w') as f:
            json.dump(report, f, indent=2, default=str)
        
        print(f"📄 Exploitability report saved to: {output_path}")
        return report

    def print_exploitability_summary(self, analyses: List[ExploitabilityAnalysis]):
        """Print summary of exploitability analysis"""
        total_vulns = len(analyses)
        exploitable_vulns = sum(1 for a in analyses if a.has_public_exploits)
        
        print(f"\n🎯 EXPLOITABILITY ANALYSIS SUMMARY")
        print("=" * 60)
        print(f"📊 Total vulnerabilities analyzed: {total_vulns}")
        print(f"💥 Vulnerabilities with public exploits: {exploitable_vulns}")
        print(f"📈 Exploit availability rate: {(exploitable_vulns/total_vulns*100):.1f}%" if total_vulns > 0 else "0%")
        
        # Risk level breakdown
        risk_counts = {}
        for analysis in analyses:
            risk_counts[analysis.exploit_risk_level] = risk_counts.get(analysis.exploit_risk_level, 0) + 1
        
        print(f"\n🚨 EXPLOIT RISK BREAKDOWN:")
        for level in ["CRITICAL", "HIGH", "MEDIUM", "LOW", "NONE"]:
            count = risk_counts.get(level, 0)
            if count > 0:
                emoji = {"CRITICAL": "🔴", "HIGH": "🟠", "MEDIUM": "🟡", "LOW": "🟢", "NONE": "⚪"}
                print(f"   {emoji[level]} {level}: {count}")

        # Show top exploitable vulnerabilities
        high_risk = [a for a in analyses if a.exploit_risk_level in ["CRITICAL", "HIGH"] and a.has_public_exploits]
        if high_risk:
            print(f"\n🎯 TOP EXPLOITABLE VULNERABILITIES:")
            print("-" * 60)
            for analysis in high_risk[:5]:  # Show top 5
                print(f"🔴 {analysis.cve_id} - {analysis.component_name}@{analysis.component_version}")
                print(f"   Risk: {analysis.exploit_risk_level} | Exploits: {analysis.exploit_count}")
                if analysis.exploits_found:
                    print(f"   Latest: {analysis.exploits_found[0].title}")
                print()