# coding: utf-8

"""
    All API Endpoints

    *Query params are case insensitive in all the APIs Endpoints.*

    The version of the OpenAPI document: v1
    Contact: ljofre2146@gmail.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Optional, Union
from typing_extensions import Annotated
from hyblock_capital_sdk.models.anchored_binance_global_accounts import AnchoredBinanceGlobalAccounts
from hyblock_capital_sdk.models.anchored_binance_top_trader_accounts import AnchoredBinanceTopTraderAccounts
from hyblock_capital_sdk.models.anchored_binance_top_trader_positions import AnchoredBinanceTopTraderPositions
from hyblock_capital_sdk.models.anchored_binance_whale_retail_delta import AnchoredBinanceWhaleRetailDelta
from hyblock_capital_sdk.models.anchored_cls import AnchoredCLS
from hyblock_capital_sdk.models.anchored_clsd import AnchoredCLSD
from hyblock_capital_sdk.models.binance_global_accounts import BinanceGlobalAccounts
from hyblock_capital_sdk.models.binance_top_trader_accounts import BinanceTopTraderAccounts
from hyblock_capital_sdk.models.binance_top_trader_positions import BinanceTopTraderPositions
from hyblock_capital_sdk.models.binance_true_retail_long_short import BinanceTrueRetailLongShort
from hyblock_capital_sdk.models.binance_whale_retail_delta import BinanceWhaleRetailDelta
from hyblock_capital_sdk.models.bybit_global_accounts import BybitGlobalAccounts
from hyblock_capital_sdk.models.huobi_top_trader_accounts import HuobiTopTraderAccounts
from hyblock_capital_sdk.models.huobi_top_trader_positions import HuobiTopTraderPositions
from hyblock_capital_sdk.models.net_long_short import NetLongShort
from hyblock_capital_sdk.models.net_long_short_delta import NetLongShortDelta
from hyblock_capital_sdk.models.okx_global_accounts import OkxGlobalAccounts
from hyblock_capital_sdk.models.okx_top_trader_accounts import OkxTopTraderAccounts
from hyblock_capital_sdk.models.okx_whale_retail_delta import OkxWhaleRetailDelta
from hyblock_capital_sdk.models.trader_sentiment_gap import TraderSentimentGap
from hyblock_capital_sdk.models.whale_position_dominance import WhalePositionDominance

from hyblock_capital_sdk.api_client import ApiClient, RequestSerialized
from hyblock_capital_sdk.api_response import ApiResponse
from hyblock_capital_sdk.rest import RESTResponseType


class LongsAndShortsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def anchored_binance_global_accounts_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        anchor: Annotated[Optional[StrictStr], Field(description="Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AnchoredBinanceGlobalAccounts:
        """anchored_binance_global_accounts_get

        Measures global accounts, anchored daily, 4-hourly, or hourly (UTC timezone), capturing the total number of Binance accounts holding long or short positions. Each account is counted as a single 'vote' to determine the percentage of accounts that are net long or net short. For example, if Binance has 1,000,000 active accounts and 600,000 are net long, the global accounts long percentage is 60%, and the short percentage is 40%. This endpoint provides insights into market sentiment and directional bias among Binance users.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param exchange: Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param anchor: Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.
        :type anchor: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._anchored_binance_global_accounts_get_serialize(
            coin=coin,
            exchange=exchange,
            timeframe=timeframe,
            anchor=anchor,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnchoredBinanceGlobalAccounts",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def anchored_binance_global_accounts_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        anchor: Annotated[Optional[StrictStr], Field(description="Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AnchoredBinanceGlobalAccounts]:
        """anchored_binance_global_accounts_get

        Measures global accounts, anchored daily, 4-hourly, or hourly (UTC timezone), capturing the total number of Binance accounts holding long or short positions. Each account is counted as a single 'vote' to determine the percentage of accounts that are net long or net short. For example, if Binance has 1,000,000 active accounts and 600,000 are net long, the global accounts long percentage is 60%, and the short percentage is 40%. This endpoint provides insights into market sentiment and directional bias among Binance users.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param exchange: Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param anchor: Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.
        :type anchor: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._anchored_binance_global_accounts_get_serialize(
            coin=coin,
            exchange=exchange,
            timeframe=timeframe,
            anchor=anchor,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnchoredBinanceGlobalAccounts",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def anchored_binance_global_accounts_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        anchor: Annotated[Optional[StrictStr], Field(description="Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """anchored_binance_global_accounts_get

        Measures global accounts, anchored daily, 4-hourly, or hourly (UTC timezone), capturing the total number of Binance accounts holding long or short positions. Each account is counted as a single 'vote' to determine the percentage of accounts that are net long or net short. For example, if Binance has 1,000,000 active accounts and 600,000 are net long, the global accounts long percentage is 60%, and the short percentage is 40%. This endpoint provides insights into market sentiment and directional bias among Binance users.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param exchange: Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param anchor: Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.
        :type anchor: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._anchored_binance_global_accounts_get_serialize(
            coin=coin,
            exchange=exchange,
            timeframe=timeframe,
            anchor=anchor,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnchoredBinanceGlobalAccounts",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _anchored_binance_global_accounts_get_serialize(
        self,
        coin,
        exchange,
        timeframe,
        anchor,
        sort,
        start_time,
        end_time,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if anchor is not None:
            
            _query_params.append(('anchor', anchor))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/anchoredBinanceGlobalAccounts',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def anchored_binance_top_trader_accounts_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        anchor: Annotated[Optional[StrictStr], Field(description="Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AnchoredBinanceTopTraderAccounts:
        """anchored_binance_top_trader_accounts_get

        Measures top trader accounts, anchored daily, 4-hourly, or hourly (UTC timezone), capturing the total number of top trader accounts on Binance holding long or short positions. Top trader accounts are defined as those within the top 20% in terms of margin or balance, as classified by Binance, and do not necessarily represent the best traders or those with the highest profits. Each top trader account is counted as a single 'vote' to determine the percentage of accounts that are net long or net short. For example, if there are 100,000 top trader accounts and 60,000 are net long, the top trader accounts long percentage is 60%, and the short percentage is 40%. This endpoint provides insights into the market sentiment and directional bias among Binance's top trader accounts.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param exchange: Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param anchor: Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.
        :type anchor: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._anchored_binance_top_trader_accounts_get_serialize(
            coin=coin,
            exchange=exchange,
            timeframe=timeframe,
            anchor=anchor,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnchoredBinanceTopTraderAccounts",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def anchored_binance_top_trader_accounts_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        anchor: Annotated[Optional[StrictStr], Field(description="Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AnchoredBinanceTopTraderAccounts]:
        """anchored_binance_top_trader_accounts_get

        Measures top trader accounts, anchored daily, 4-hourly, or hourly (UTC timezone), capturing the total number of top trader accounts on Binance holding long or short positions. Top trader accounts are defined as those within the top 20% in terms of margin or balance, as classified by Binance, and do not necessarily represent the best traders or those with the highest profits. Each top trader account is counted as a single 'vote' to determine the percentage of accounts that are net long or net short. For example, if there are 100,000 top trader accounts and 60,000 are net long, the top trader accounts long percentage is 60%, and the short percentage is 40%. This endpoint provides insights into the market sentiment and directional bias among Binance's top trader accounts.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param exchange: Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param anchor: Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.
        :type anchor: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._anchored_binance_top_trader_accounts_get_serialize(
            coin=coin,
            exchange=exchange,
            timeframe=timeframe,
            anchor=anchor,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnchoredBinanceTopTraderAccounts",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def anchored_binance_top_trader_accounts_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        anchor: Annotated[Optional[StrictStr], Field(description="Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """anchored_binance_top_trader_accounts_get

        Measures top trader accounts, anchored daily, 4-hourly, or hourly (UTC timezone), capturing the total number of top trader accounts on Binance holding long or short positions. Top trader accounts are defined as those within the top 20% in terms of margin or balance, as classified by Binance, and do not necessarily represent the best traders or those with the highest profits. Each top trader account is counted as a single 'vote' to determine the percentage of accounts that are net long or net short. For example, if there are 100,000 top trader accounts and 60,000 are net long, the top trader accounts long percentage is 60%, and the short percentage is 40%. This endpoint provides insights into the market sentiment and directional bias among Binance's top trader accounts.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param exchange: Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param anchor: Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.
        :type anchor: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._anchored_binance_top_trader_accounts_get_serialize(
            coin=coin,
            exchange=exchange,
            timeframe=timeframe,
            anchor=anchor,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnchoredBinanceTopTraderAccounts",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _anchored_binance_top_trader_accounts_get_serialize(
        self,
        coin,
        exchange,
        timeframe,
        anchor,
        sort,
        start_time,
        end_time,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if anchor is not None:
            
            _query_params.append(('anchor', anchor))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/anchoredBinanceTopTraderAccounts',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def anchored_binance_top_trader_positions_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        anchor: Annotated[Optional[StrictStr], Field(description="Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AnchoredBinanceTopTraderPositions:
        """anchored_binance_top_trader_positions_get

        Measures top trader positions, anchored daily, 4-hourly, or hourly (UTC timezone), capturing the total number of top trader positions on Binance that are long or short. Top trader positions are defined as those within the top 20% in terms of margin or balance, as classified by Binance. Unlike account-based metrics, this endpoint focuses on individual positions (size). For example, if top trader positions hold $100,000 positions and $60,000 are long, the top trader positions long percentage is 60%, and the short percentage is 40%. This endpoint provides insights into the market sentiment and directional bias reflected in the positions of Binance's top traders.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param exchange: Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param anchor: Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.
        :type anchor: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._anchored_binance_top_trader_positions_get_serialize(
            coin=coin,
            exchange=exchange,
            timeframe=timeframe,
            anchor=anchor,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnchoredBinanceTopTraderPositions",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def anchored_binance_top_trader_positions_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        anchor: Annotated[Optional[StrictStr], Field(description="Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AnchoredBinanceTopTraderPositions]:
        """anchored_binance_top_trader_positions_get

        Measures top trader positions, anchored daily, 4-hourly, or hourly (UTC timezone), capturing the total number of top trader positions on Binance that are long or short. Top trader positions are defined as those within the top 20% in terms of margin or balance, as classified by Binance. Unlike account-based metrics, this endpoint focuses on individual positions (size). For example, if top trader positions hold $100,000 positions and $60,000 are long, the top trader positions long percentage is 60%, and the short percentage is 40%. This endpoint provides insights into the market sentiment and directional bias reflected in the positions of Binance's top traders.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param exchange: Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param anchor: Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.
        :type anchor: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._anchored_binance_top_trader_positions_get_serialize(
            coin=coin,
            exchange=exchange,
            timeframe=timeframe,
            anchor=anchor,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnchoredBinanceTopTraderPositions",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def anchored_binance_top_trader_positions_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        anchor: Annotated[Optional[StrictStr], Field(description="Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """anchored_binance_top_trader_positions_get

        Measures top trader positions, anchored daily, 4-hourly, or hourly (UTC timezone), capturing the total number of top trader positions on Binance that are long or short. Top trader positions are defined as those within the top 20% in terms of margin or balance, as classified by Binance. Unlike account-based metrics, this endpoint focuses on individual positions (size). For example, if top trader positions hold $100,000 positions and $60,000 are long, the top trader positions long percentage is 60%, and the short percentage is 40%. This endpoint provides insights into the market sentiment and directional bias reflected in the positions of Binance's top traders.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param exchange: Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param anchor: Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.
        :type anchor: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._anchored_binance_top_trader_positions_get_serialize(
            coin=coin,
            exchange=exchange,
            timeframe=timeframe,
            anchor=anchor,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnchoredBinanceTopTraderPositions",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _anchored_binance_top_trader_positions_get_serialize(
        self,
        coin,
        exchange,
        timeframe,
        anchor,
        sort,
        start_time,
        end_time,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if anchor is not None:
            
            _query_params.append(('anchor', anchor))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/anchoredBinanceTopTraderPositions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def anchored_binance_whale_retail_delta_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        anchor: Annotated[Optional[StrictStr], Field(description="Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AnchoredBinanceWhaleRetailDelta:
        """anchored_binance_whale_retail_delta_get

        Measures whale vs retail delta anchored daily, 4-hourly, or hourly (UTC timezone), calculating the difference between the long percentage of top trader positions ('whales') and the long percentage of global accounts ('retail') on Binance. Top trader positions are those within the top 20% in terms of margin or balance, as classified by Binance. For example, if top trader positions have a long percentage of 65% and global accounts have a long percentage of 55%, the whale-retail delta is +10. This endpoint provides insights into the divergence in market sentiment between Binance's top traders positions and the broader retail account base.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param exchange: Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param anchor: Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.
        :type anchor: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._anchored_binance_whale_retail_delta_get_serialize(
            coin=coin,
            exchange=exchange,
            timeframe=timeframe,
            anchor=anchor,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnchoredBinanceWhaleRetailDelta",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def anchored_binance_whale_retail_delta_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        anchor: Annotated[Optional[StrictStr], Field(description="Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AnchoredBinanceWhaleRetailDelta]:
        """anchored_binance_whale_retail_delta_get

        Measures whale vs retail delta anchored daily, 4-hourly, or hourly (UTC timezone), calculating the difference between the long percentage of top trader positions ('whales') and the long percentage of global accounts ('retail') on Binance. Top trader positions are those within the top 20% in terms of margin or balance, as classified by Binance. For example, if top trader positions have a long percentage of 65% and global accounts have a long percentage of 55%, the whale-retail delta is +10. This endpoint provides insights into the divergence in market sentiment between Binance's top traders positions and the broader retail account base.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param exchange: Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param anchor: Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.
        :type anchor: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._anchored_binance_whale_retail_delta_get_serialize(
            coin=coin,
            exchange=exchange,
            timeframe=timeframe,
            anchor=anchor,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnchoredBinanceWhaleRetailDelta",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def anchored_binance_whale_retail_delta_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        anchor: Annotated[Optional[StrictStr], Field(description="Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """anchored_binance_whale_retail_delta_get

        Measures whale vs retail delta anchored daily, 4-hourly, or hourly (UTC timezone), calculating the difference between the long percentage of top trader positions ('whales') and the long percentage of global accounts ('retail') on Binance. Top trader positions are those within the top 20% in terms of margin or balance, as classified by Binance. For example, if top trader positions have a long percentage of 65% and global accounts have a long percentage of 55%, the whale-retail delta is +10. This endpoint provides insights into the divergence in market sentiment between Binance's top traders positions and the broader retail account base.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param exchange: Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param anchor: Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.
        :type anchor: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._anchored_binance_whale_retail_delta_get_serialize(
            coin=coin,
            exchange=exchange,
            timeframe=timeframe,
            anchor=anchor,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnchoredBinanceWhaleRetailDelta",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _anchored_binance_whale_retail_delta_get_serialize(
        self,
        coin,
        exchange,
        timeframe,
        anchor,
        sort,
        start_time,
        end_time,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if anchor is not None:
            
            _query_params.append(('anchor', anchor))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/anchoredBinanceWhaleRetailDelta',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def anchored_cls_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        anchor: Annotated[Optional[StrictStr], Field(description="Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AnchoredCLS:
        """anchored_cls_get

        Tracks the cumulative sum of net longs and shorts (CLS) with a daily, 4-hourly, or hourly anchor (UTC timezone), allowing clearer insights into net long versus short positioning trends over time.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param anchor: Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.
        :type anchor: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._anchored_cls_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            anchor=anchor,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnchoredCLS",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def anchored_cls_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        anchor: Annotated[Optional[StrictStr], Field(description="Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AnchoredCLS]:
        """anchored_cls_get

        Tracks the cumulative sum of net longs and shorts (CLS) with a daily, 4-hourly, or hourly anchor (UTC timezone), allowing clearer insights into net long versus short positioning trends over time.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param anchor: Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.
        :type anchor: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._anchored_cls_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            anchor=anchor,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnchoredCLS",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def anchored_cls_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        anchor: Annotated[Optional[StrictStr], Field(description="Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """anchored_cls_get

        Tracks the cumulative sum of net longs and shorts (CLS) with a daily, 4-hourly, or hourly anchor (UTC timezone), allowing clearer insights into net long versus short positioning trends over time.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param anchor: Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.
        :type anchor: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._anchored_cls_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            anchor=anchor,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnchoredCLS",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _anchored_cls_get_serialize(
        self,
        coin,
        timeframe,
        exchange,
        anchor,
        sort,
        start_time,
        end_time,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if anchor is not None:
            
            _query_params.append(('anchor', anchor))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/anchoredCLS',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def anchored_clsd_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        anchor: Annotated[Optional[StrictStr], Field(description="Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AnchoredCLSD:
        """anchored_clsd_get

         Tracks the cumulative sum of net longs and shorts delta (CLSD) with a daily, 4-hourly, or hourly anchor (UTC timezone), allowing clearer insights into net long versus short positioning trends over time.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param anchor: Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.
        :type anchor: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._anchored_clsd_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            anchor=anchor,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnchoredCLSD",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def anchored_clsd_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        anchor: Annotated[Optional[StrictStr], Field(description="Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AnchoredCLSD]:
        """anchored_clsd_get

         Tracks the cumulative sum of net longs and shorts delta (CLSD) with a daily, 4-hourly, or hourly anchor (UTC timezone), allowing clearer insights into net long versus short positioning trends over time.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param anchor: Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.
        :type anchor: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._anchored_clsd_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            anchor=anchor,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnchoredCLSD",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def anchored_clsd_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        anchor: Annotated[Optional[StrictStr], Field(description="Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """anchored_clsd_get

         Tracks the cumulative sum of net longs and shorts delta (CLSD) with a daily, 4-hourly, or hourly anchor (UTC timezone), allowing clearer insights into net long versus short positioning trends over time.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param anchor: Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.
        :type anchor: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._anchored_clsd_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            anchor=anchor,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnchoredCLSD",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _anchored_clsd_get_serialize(
        self,
        coin,
        timeframe,
        exchange,
        anchor,
        sort,
        start_time,
        end_time,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if anchor is not None:
            
            _query_params.append(('anchor', anchor))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/anchoredCLSD',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def binance_global_accounts_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BinanceGlobalAccounts:
        """binance_global_accounts_get

        This measures the total number of *accounts* that are long or short on Binance. So for example, if there are 1million accounts on Binance and 600k of them are net long, then the global accounts long% is 60% (and short% = 40%). Each account gets one 'vote'.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param exchange: Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._binance_global_accounts_get_serialize(
            coin=coin,
            exchange=exchange,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BinanceGlobalAccounts",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def binance_global_accounts_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BinanceGlobalAccounts]:
        """binance_global_accounts_get

        This measures the total number of *accounts* that are long or short on Binance. So for example, if there are 1million accounts on Binance and 600k of them are net long, then the global accounts long% is 60% (and short% = 40%). Each account gets one 'vote'.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param exchange: Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._binance_global_accounts_get_serialize(
            coin=coin,
            exchange=exchange,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BinanceGlobalAccounts",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def binance_global_accounts_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """binance_global_accounts_get

        This measures the total number of *accounts* that are long or short on Binance. So for example, if there are 1million accounts on Binance and 600k of them are net long, then the global accounts long% is 60% (and short% = 40%). Each account gets one 'vote'.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param exchange: Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._binance_global_accounts_get_serialize(
            coin=coin,
            exchange=exchange,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BinanceGlobalAccounts",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _binance_global_accounts_get_serialize(
        self,
        coin,
        exchange,
        timeframe,
        sort,
        start_time,
        end_time,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/binanceGlobalAccounts',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def binance_top_trader_accounts_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BinanceTopTraderAccounts:
        """binance_top_trader_accounts_get

        This measures the total number of *top trader accounts* that are long (or short) on Binance. Note, top traders do not necessarily mean the best traders or those with the highest profits, but rather Binance classifies top traders as accounts with the top20% in margin (or balance). This indicator is similar to Global Long Accounts with the only difference being that it focuses on the top 20% accounts.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param exchange: Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._binance_top_trader_accounts_get_serialize(
            coin=coin,
            exchange=exchange,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BinanceTopTraderAccounts",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def binance_top_trader_accounts_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BinanceTopTraderAccounts]:
        """binance_top_trader_accounts_get

        This measures the total number of *top trader accounts* that are long (or short) on Binance. Note, top traders do not necessarily mean the best traders or those with the highest profits, but rather Binance classifies top traders as accounts with the top20% in margin (or balance). This indicator is similar to Global Long Accounts with the only difference being that it focuses on the top 20% accounts.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param exchange: Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._binance_top_trader_accounts_get_serialize(
            coin=coin,
            exchange=exchange,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BinanceTopTraderAccounts",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def binance_top_trader_accounts_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """binance_top_trader_accounts_get

        This measures the total number of *top trader accounts* that are long (or short) on Binance. Note, top traders do not necessarily mean the best traders or those with the highest profits, but rather Binance classifies top traders as accounts with the top20% in margin (or balance). This indicator is similar to Global Long Accounts with the only difference being that it focuses on the top 20% accounts.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param exchange: Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._binance_top_trader_accounts_get_serialize(
            coin=coin,
            exchange=exchange,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BinanceTopTraderAccounts",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _binance_top_trader_accounts_get_serialize(
        self,
        coin,
        exchange,
        timeframe,
        sort,
        start_time,
        end_time,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/binanceTopTraderAccounts',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def binance_top_trader_positions_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BinanceTopTraderPositions:
        """binance_top_trader_positions_get

        This measures the total number of *top trader positions* that are long (or short) on Binance. The key difference here is that instead of looking at accounts, it instead looks at positions.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param exchange: Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._binance_top_trader_positions_get_serialize(
            coin=coin,
            exchange=exchange,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BinanceTopTraderPositions",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def binance_top_trader_positions_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BinanceTopTraderPositions]:
        """binance_top_trader_positions_get

        This measures the total number of *top trader positions* that are long (or short) on Binance. The key difference here is that instead of looking at accounts, it instead looks at positions.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param exchange: Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._binance_top_trader_positions_get_serialize(
            coin=coin,
            exchange=exchange,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BinanceTopTraderPositions",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def binance_top_trader_positions_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """binance_top_trader_positions_get

        This measures the total number of *top trader positions* that are long (or short) on Binance. The key difference here is that instead of looking at accounts, it instead looks at positions.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param exchange: Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._binance_top_trader_positions_get_serialize(
            coin=coin,
            exchange=exchange,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BinanceTopTraderPositions",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _binance_top_trader_positions_get_serialize(
        self,
        coin,
        exchange,
        timeframe,
        sort,
        start_time,
        end_time,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/binanceTopTraderPositions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def binance_true_retail_long_short_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BinanceTrueRetailLongShort:
        """binance_true_retail_long_short_get

        This metric shows the percentage of retail accounts in long versus short positions, with each account equally contributing one vote, regardless of position size.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param exchange: Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._binance_true_retail_long_short_get_serialize(
            coin=coin,
            exchange=exchange,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BinanceTrueRetailLongShort",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def binance_true_retail_long_short_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BinanceTrueRetailLongShort]:
        """binance_true_retail_long_short_get

        This metric shows the percentage of retail accounts in long versus short positions, with each account equally contributing one vote, regardless of position size.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param exchange: Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._binance_true_retail_long_short_get_serialize(
            coin=coin,
            exchange=exchange,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BinanceTrueRetailLongShort",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def binance_true_retail_long_short_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """binance_true_retail_long_short_get

        This metric shows the percentage of retail accounts in long versus short positions, with each account equally contributing one vote, regardless of position size.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param exchange: Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._binance_true_retail_long_short_get_serialize(
            coin=coin,
            exchange=exchange,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BinanceTrueRetailLongShort",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _binance_true_retail_long_short_get_serialize(
        self,
        coin,
        exchange,
        timeframe,
        sort,
        start_time,
        end_time,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/binanceTrueRetailLongShort',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def binance_whale_retail_delta_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BinanceWhaleRetailDelta:
        """binance_whale_retail_delta_get

        This is the difference between top trader positions long% ('whales') and global accounts long% ('retail').

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param exchange: Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._binance_whale_retail_delta_get_serialize(
            coin=coin,
            exchange=exchange,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BinanceWhaleRetailDelta",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def binance_whale_retail_delta_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BinanceWhaleRetailDelta]:
        """binance_whale_retail_delta_get

        This is the difference between top trader positions long% ('whales') and global accounts long% ('retail').

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param exchange: Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._binance_whale_retail_delta_get_serialize(
            coin=coin,
            exchange=exchange,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BinanceWhaleRetailDelta",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def binance_whale_retail_delta_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """binance_whale_retail_delta_get

        This is the difference between top trader positions long% ('whales') and global accounts long% ('retail').

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param exchange: Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._binance_whale_retail_delta_get_serialize(
            coin=coin,
            exchange=exchange,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BinanceWhaleRetailDelta",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _binance_whale_retail_delta_get_serialize(
        self,
        coin,
        exchange,
        timeframe,
        sort,
        start_time,
        end_time,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/binanceWhaleRetailDelta',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def bybit_global_accounts_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BybitGlobalAccounts:
        """bybit_global_accounts_get

        This measures the total number of accounts that are long or short on Bybit. So for example, if there are 1 million accounts on Bybit and 600k of them are net long, then the global accounts long% is 60% (and short% = 40%). Each account gets one 'vote'.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._bybit_global_accounts_get_serialize(
            coin=coin,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BybitGlobalAccounts",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def bybit_global_accounts_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BybitGlobalAccounts]:
        """bybit_global_accounts_get

        This measures the total number of accounts that are long or short on Bybit. So for example, if there are 1 million accounts on Bybit and 600k of them are net long, then the global accounts long% is 60% (and short% = 40%). Each account gets one 'vote'.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._bybit_global_accounts_get_serialize(
            coin=coin,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BybitGlobalAccounts",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def bybit_global_accounts_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """bybit_global_accounts_get

        This measures the total number of accounts that are long or short on Bybit. So for example, if there are 1 million accounts on Bybit and 600k of them are net long, then the global accounts long% is 60% (and short% = 40%). Each account gets one 'vote'.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._bybit_global_accounts_get_serialize(
            coin=coin,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BybitGlobalAccounts",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _bybit_global_accounts_get_serialize(
        self,
        coin,
        timeframe,
        sort,
        start_time,
        end_time,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/bybitGlobalAccounts',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def huobi_top_trader_accounts_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> HuobiTopTraderAccounts:
        """huobi_top_trader_accounts_get

        This measures the total number of *top trader accounts* that are long (or short) on Huobi. Note, top traders do not necessarily mean the best traders or those with the highest profits, but rather Huobi classifies top traders: 'top traders are those part of exclusive, invite-only club meant for quantitative, institutional investors and other elite level traders participating in Huobi’s platform.'

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._huobi_top_trader_accounts_get_serialize(
            coin=coin,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "HuobiTopTraderAccounts",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def huobi_top_trader_accounts_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[HuobiTopTraderAccounts]:
        """huobi_top_trader_accounts_get

        This measures the total number of *top trader accounts* that are long (or short) on Huobi. Note, top traders do not necessarily mean the best traders or those with the highest profits, but rather Huobi classifies top traders: 'top traders are those part of exclusive, invite-only club meant for quantitative, institutional investors and other elite level traders participating in Huobi’s platform.'

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._huobi_top_trader_accounts_get_serialize(
            coin=coin,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "HuobiTopTraderAccounts",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def huobi_top_trader_accounts_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """huobi_top_trader_accounts_get

        This measures the total number of *top trader accounts* that are long (or short) on Huobi. Note, top traders do not necessarily mean the best traders or those with the highest profits, but rather Huobi classifies top traders: 'top traders are those part of exclusive, invite-only club meant for quantitative, institutional investors and other elite level traders participating in Huobi’s platform.'

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._huobi_top_trader_accounts_get_serialize(
            coin=coin,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "HuobiTopTraderAccounts",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _huobi_top_trader_accounts_get_serialize(
        self,
        coin,
        timeframe,
        sort,
        start_time,
        end_time,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/huobiTopTraderAccounts',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def huobi_top_trader_positions_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> HuobiTopTraderPositions:
        """huobi_top_trader_positions_get

        This measures the total number of *top trader positions* that are long (or short) on Huobi. The key difference here is that instead of looking at accounts, it instead looks at positions. Note, top traders do not necessarily mean the best traders or those with the highest profits, but rather Huobi classifies top traders: 'top traders are those part of exclusive, invite-only club meant for quantitative, institutional investors and other elite level traders participating in Huobi’s platform.'

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._huobi_top_trader_positions_get_serialize(
            coin=coin,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "HuobiTopTraderPositions",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def huobi_top_trader_positions_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[HuobiTopTraderPositions]:
        """huobi_top_trader_positions_get

        This measures the total number of *top trader positions* that are long (or short) on Huobi. The key difference here is that instead of looking at accounts, it instead looks at positions. Note, top traders do not necessarily mean the best traders or those with the highest profits, but rather Huobi classifies top traders: 'top traders are those part of exclusive, invite-only club meant for quantitative, institutional investors and other elite level traders participating in Huobi’s platform.'

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._huobi_top_trader_positions_get_serialize(
            coin=coin,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "HuobiTopTraderPositions",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def huobi_top_trader_positions_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """huobi_top_trader_positions_get

        This measures the total number of *top trader positions* that are long (or short) on Huobi. The key difference here is that instead of looking at accounts, it instead looks at positions. Note, top traders do not necessarily mean the best traders or those with the highest profits, but rather Huobi classifies top traders: 'top traders are those part of exclusive, invite-only club meant for quantitative, institutional investors and other elite level traders participating in Huobi’s platform.'

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._huobi_top_trader_positions_get_serialize(
            coin=coin,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "HuobiTopTraderPositions",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _huobi_top_trader_positions_get_serialize(
        self,
        coin,
        timeframe,
        sort,
        start_time,
        end_time,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/huobiTopTraderPositions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def net_long_short_delta_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> NetLongShortDelta:
        """net_long_short_delta_get

        The difference between Net Longs and Net Shorts.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._net_long_short_delta_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NetLongShortDelta",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def net_long_short_delta_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[NetLongShortDelta]:
        """net_long_short_delta_get

        The difference between Net Longs and Net Shorts.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._net_long_short_delta_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NetLongShortDelta",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def net_long_short_delta_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """net_long_short_delta_get

        The difference between Net Longs and Net Shorts.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._net_long_short_delta_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NetLongShortDelta",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _net_long_short_delta_get_serialize(
        self,
        coin,
        timeframe,
        exchange,
        sort,
        start_time,
        end_time,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/netLongShortDelta',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def net_long_short_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> NetLongShort:
        """net_long_short_get

        Estimated net longs and net shorts derived from taker orders & open interest.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._net_long_short_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NetLongShort",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def net_long_short_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[NetLongShort]:
        """net_long_short_get

        Estimated net longs and net shorts derived from taker orders & open interest.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._net_long_short_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NetLongShort",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def net_long_short_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """net_long_short_get

        Estimated net longs and net shorts derived from taker orders & open interest.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._net_long_short_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NetLongShort",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _net_long_short_get_serialize(
        self,
        coin,
        timeframe,
        exchange,
        sort,
        start_time,
        end_time,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/netLongShort',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def okx_global_accounts_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OkxGlobalAccounts:
        """okx_global_accounts_get

        This measures the total number of *accounts* that are long (or short) on Okx. So for example, if there are 1million accounts on Okx and 600k of them are net long, then the global accounts long% is 60% (and short% = 40%). Each account gets one 'vote'

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._okx_global_accounts_get_serialize(
            coin=coin,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OkxGlobalAccounts",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def okx_global_accounts_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OkxGlobalAccounts]:
        """okx_global_accounts_get

        This measures the total number of *accounts* that are long (or short) on Okx. So for example, if there are 1million accounts on Okx and 600k of them are net long, then the global accounts long% is 60% (and short% = 40%). Each account gets one 'vote'

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._okx_global_accounts_get_serialize(
            coin=coin,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OkxGlobalAccounts",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def okx_global_accounts_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """okx_global_accounts_get

        This measures the total number of *accounts* that are long (or short) on Okx. So for example, if there are 1million accounts on Okx and 600k of them are net long, then the global accounts long% is 60% (and short% = 40%). Each account gets one 'vote'

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._okx_global_accounts_get_serialize(
            coin=coin,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OkxGlobalAccounts",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _okx_global_accounts_get_serialize(
        self,
        coin,
        timeframe,
        sort,
        start_time,
        end_time,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/okxGlobalAccounts',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def okx_top_trader_accounts_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OkxTopTraderAccounts:
        """okx_top_trader_accounts_get

        This measures the total number of top trader accounts that are long (or short) on Okx. Note, top traders do not necessarily mean the best traders or those with the highest profits, but rather Okx classifies top traders as the top 5% of traders. This indicator is similar to Global Long Accounts with the only difference being that it focuses on the top 5% of trader account (based on size), instead of all accounts.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._okx_top_trader_accounts_get_serialize(
            coin=coin,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OkxTopTraderAccounts",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def okx_top_trader_accounts_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OkxTopTraderAccounts]:
        """okx_top_trader_accounts_get

        This measures the total number of top trader accounts that are long (or short) on Okx. Note, top traders do not necessarily mean the best traders or those with the highest profits, but rather Okx classifies top traders as the top 5% of traders. This indicator is similar to Global Long Accounts with the only difference being that it focuses on the top 5% of trader account (based on size), instead of all accounts.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._okx_top_trader_accounts_get_serialize(
            coin=coin,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OkxTopTraderAccounts",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def okx_top_trader_accounts_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """okx_top_trader_accounts_get

        This measures the total number of top trader accounts that are long (or short) on Okx. Note, top traders do not necessarily mean the best traders or those with the highest profits, but rather Okx classifies top traders as the top 5% of traders. This indicator is similar to Global Long Accounts with the only difference being that it focuses on the top 5% of trader account (based on size), instead of all accounts.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._okx_top_trader_accounts_get_serialize(
            coin=coin,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OkxTopTraderAccounts",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _okx_top_trader_accounts_get_serialize(
        self,
        coin,
        timeframe,
        sort,
        start_time,
        end_time,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/okxTopTraderAccounts',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def okx_whale_retail_delta_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OkxWhaleRetailDelta:
        """okx_whale_retail_delta_get

        This is the difference between top trader accounts long% ('whales') and global accounts long% ('retail').

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._okx_whale_retail_delta_get_serialize(
            coin=coin,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OkxWhaleRetailDelta",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def okx_whale_retail_delta_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OkxWhaleRetailDelta]:
        """okx_whale_retail_delta_get

        This is the difference between top trader accounts long% ('whales') and global accounts long% ('retail').

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._okx_whale_retail_delta_get_serialize(
            coin=coin,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OkxWhaleRetailDelta",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def okx_whale_retail_delta_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """okx_whale_retail_delta_get

        This is the difference between top trader accounts long% ('whales') and global accounts long% ('retail').

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._okx_whale_retail_delta_get_serialize(
            coin=coin,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OkxWhaleRetailDelta",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _okx_whale_retail_delta_get_serialize(
        self,
        coin,
        timeframe,
        sort,
        start_time,
        end_time,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/okxWhaleRetailDelta',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def trader_sentiment_gap_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TraderSentimentGap:
        """trader_sentiment_gap_get

        Highlights the sentiment divergence between larger, more influential accounts and smaller retail accounts. Provides a measure of how positioning sentiment differs between these two groups, offering insights into whether they are aligned or moving in opposite directions. Helps identify potential behavioral patterns across different trader segments, revealing shifts in market sentiment that may not be immediately apparent from broader metrics.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._trader_sentiment_gap_get_serialize(
            coin=coin,
            exchange=exchange,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TraderSentimentGap",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def trader_sentiment_gap_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TraderSentimentGap]:
        """trader_sentiment_gap_get

        Highlights the sentiment divergence between larger, more influential accounts and smaller retail accounts. Provides a measure of how positioning sentiment differs between these two groups, offering insights into whether they are aligned or moving in opposite directions. Helps identify potential behavioral patterns across different trader segments, revealing shifts in market sentiment that may not be immediately apparent from broader metrics.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._trader_sentiment_gap_get_serialize(
            coin=coin,
            exchange=exchange,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TraderSentimentGap",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def trader_sentiment_gap_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """trader_sentiment_gap_get

        Highlights the sentiment divergence between larger, more influential accounts and smaller retail accounts. Provides a measure of how positioning sentiment differs between these two groups, offering insights into whether they are aligned or moving in opposite directions. Helps identify potential behavioral patterns across different trader segments, revealing shifts in market sentiment that may not be immediately apparent from broader metrics.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._trader_sentiment_gap_get_serialize(
            coin=coin,
            exchange=exchange,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TraderSentimentGap",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _trader_sentiment_gap_get_serialize(
        self,
        coin,
        exchange,
        timeframe,
        sort,
        start_time,
        end_time,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/traderSentimentGap',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def whale_position_dominance_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> WhalePositionDominance:
        """whale_position_dominance_get

        Evaluates the influence of larger positions in the market compared to broader account-level sentiment among prominent traders. Offers insights into whether larger positions are exerting outsized influence on the market relative to the overall positioning of significant accounts. Serves as a proxy for whale activity, helping users understand how concentrated larger positions are and whether they align with broader sentiment trends.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._whale_position_dominance_get_serialize(
            coin=coin,
            exchange=exchange,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WhalePositionDominance",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def whale_position_dominance_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[WhalePositionDominance]:
        """whale_position_dominance_get

        Evaluates the influence of larger positions in the market compared to broader account-level sentiment among prominent traders. Offers insights into whether larger positions are exerting outsized influence on the market relative to the overall positioning of significant accounts. Serves as a proxy for whale activity, helping users understand how concentrated larger positions are and whether they align with broader sentiment trends.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._whale_position_dominance_get_serialize(
            coin=coin,
            exchange=exchange,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WhalePositionDominance",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def whale_position_dominance_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """whale_position_dominance_get

        Evaluates the influence of larger positions in the market compared to broader account-level sentiment among prominent traders. Offers insights into whether larger positions are exerting outsized influence on the market relative to the overall positioning of significant accounts. Serves as a proxy for whale activity, helping users understand how concentrated larger positions are and whether they align with broader sentiment trends.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._whale_position_dominance_get_serialize(
            coin=coin,
            exchange=exchange,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WhalePositionDominance",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _whale_position_dominance_get_serialize(
        self,
        coin,
        exchange,
        timeframe,
        sort,
        start_time,
        end_time,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/whalePositionDominance',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


