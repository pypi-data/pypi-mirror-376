# coding: utf-8

"""
    All API Endpoints

    *Query params are case insensitive in all the APIs Endpoints.*

    The version of the OpenAPI document: v1
    Contact: ljofre2146@gmail.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Optional, Union
from typing_extensions import Annotated
from hyblock_capital_sdk.models.anchored_cvd import AnchoredCVD
from hyblock_capital_sdk.models.bot_tracker import BotTracker
from hyblock_capital_sdk.models.buy_volume import BuyVolume
from hyblock_capital_sdk.models.klines import Klines
from hyblock_capital_sdk.models.market_order_average_size import MarketOrderAverageSize
from hyblock_capital_sdk.models.market_order_count import MarketOrderCount
from hyblock_capital_sdk.models.participationratio import Participationratio
from hyblock_capital_sdk.models.pd_levels import PdLevels
from hyblock_capital_sdk.models.pm_levels import PmLevels
from hyblock_capital_sdk.models.pw_levels import PwLevels
from hyblock_capital_sdk.models.sell_volume import SellVolume
from hyblock_capital_sdk.models.slippage import Slippage
from hyblock_capital_sdk.models.transferofcontracts import Transferofcontracts
from hyblock_capital_sdk.models.volume_delta import VolumeDelta

from hyblock_capital_sdk.api_client import ApiClient, RequestSerialized
from hyblock_capital_sdk.api_response import ApiResponse
from hyblock_capital_sdk.rest import RESTResponseType


class OrderflowApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def anchored_cvd_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        anchor: Annotated[Optional[StrictStr], Field(description="Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        bucket: Annotated[Optional[StrictStr], Field(description="You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AnchoredCVD:
        """anchored_cvd_get

        Calculates the Cumulative Volume Delta (CVD), anchored daily, 4-hourly, or hourly (UTC timezone), enabling users to easily track volume shifts relative to previous periods for trend analysis.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param anchor: Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.
        :type anchor: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param bucket: You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All
        :type bucket: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._anchored_cvd_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            anchor=anchor,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            bucket=bucket,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnchoredCVD",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def anchored_cvd_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        anchor: Annotated[Optional[StrictStr], Field(description="Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        bucket: Annotated[Optional[StrictStr], Field(description="You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AnchoredCVD]:
        """anchored_cvd_get

        Calculates the Cumulative Volume Delta (CVD), anchored daily, 4-hourly, or hourly (UTC timezone), enabling users to easily track volume shifts relative to previous periods for trend analysis.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param anchor: Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.
        :type anchor: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param bucket: You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All
        :type bucket: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._anchored_cvd_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            anchor=anchor,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            bucket=bucket,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnchoredCVD",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def anchored_cvd_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        anchor: Annotated[Optional[StrictStr], Field(description="Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        bucket: Annotated[Optional[StrictStr], Field(description="You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """anchored_cvd_get

        Calculates the Cumulative Volume Delta (CVD), anchored daily, 4-hourly, or hourly (UTC timezone), enabling users to easily track volume shifts relative to previous periods for trend analysis.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param anchor: Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.
        :type anchor: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param bucket: You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All
        :type bucket: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._anchored_cvd_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            anchor=anchor,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            bucket=bucket,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnchoredCVD",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _anchored_cvd_get_serialize(
        self,
        coin,
        timeframe,
        exchange,
        market_types,
        anchor,
        sort,
        start_time,
        end_time,
        bucket,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if market_types is not None:
            
            _query_params.append(('marketTypes', market_types))
            
        if anchor is not None:
            
            _query_params.append(('anchor', anchor))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if bucket is not None:
            
            _query_params.append(('bucket', bucket))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/anchoredCVD',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def bot_tracker_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BotTracker:
        """bot_tracker_get

        This indicator detects potential bot activity by tracking unique order sizes that repeat frequently within short time frames. For instance, if a market order of size $57,889 appears five times in one minute, it is flagged as bot activity.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._bot_tracker_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BotTracker",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def bot_tracker_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BotTracker]:
        """bot_tracker_get

        This indicator detects potential bot activity by tracking unique order sizes that repeat frequently within short time frames. For instance, if a market order of size $57,889 appears five times in one minute, it is flagged as bot activity.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._bot_tracker_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BotTracker",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def bot_tracker_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """bot_tracker_get

        This indicator detects potential bot activity by tracking unique order sizes that repeat frequently within short time frames. For instance, if a market order of size $57,889 appears five times in one minute, it is flagged as bot activity.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._bot_tracker_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BotTracker",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _bot_tracker_get_serialize(
        self,
        coin,
        timeframe,
        exchange,
        market_types,
        sort,
        start_time,
        end_time,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if market_types is not None:
            
            _query_params.append(('marketTypes', market_types))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/botTracker',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def buy_volume_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        bucket: Annotated[Optional[StrictStr], Field(description="You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BuyVolume:
        """buy_volume_get

        Aggregates the volume from market buy orders, summing the size of every market order on the buy side to reflect buying pressure.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param bucket: You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All
        :type bucket: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._buy_volume_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            bucket=bucket,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BuyVolume",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def buy_volume_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        bucket: Annotated[Optional[StrictStr], Field(description="You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BuyVolume]:
        """buy_volume_get

        Aggregates the volume from market buy orders, summing the size of every market order on the buy side to reflect buying pressure.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param bucket: You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All
        :type bucket: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._buy_volume_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            bucket=bucket,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BuyVolume",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def buy_volume_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        bucket: Annotated[Optional[StrictStr], Field(description="You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """buy_volume_get

        Aggregates the volume from market buy orders, summing the size of every market order on the buy side to reflect buying pressure.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param bucket: You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All
        :type bucket: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._buy_volume_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            bucket=bucket,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BuyVolume",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _buy_volume_get_serialize(
        self,
        coin,
        timeframe,
        exchange,
        market_types,
        sort,
        start_time,
        end_time,
        bucket,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if market_types is not None:
            
            _query_params.append(('marketTypes', market_types))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if bucket is not None:
            
            _query_params.append(('bucket', bucket))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/buyVolume',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def klines_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Klines:
        """klines_get

        Candlestick price chart data. Open is the first price during the time period (candle), high is the highest price, low is the lowest price, and close is the last price.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._klines_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Klines",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def klines_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Klines]:
        """klines_get

        Candlestick price chart data. Open is the first price during the time period (candle), high is the highest price, low is the lowest price, and close is the last price.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._klines_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Klines",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def klines_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """klines_get

        Candlestick price chart data. Open is the first price during the time period (candle), high is the highest price, low is the lowest price, and close is the last price.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._klines_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Klines",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _klines_get_serialize(
        self,
        coin,
        timeframe,
        exchange,
        sort,
        start_time,
        end_time,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/klines',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def limit_order_average_size_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        bucket: Annotated[Optional[StrictStr], Field(description="You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> MarketOrderAverageSize:
        """limit_order_average_size_get

        This metric calculates the average size of limit orders for a given ticker over a specified time period or candle, providing insight into typical limit order size during that interval.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param bucket: You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All
        :type bucket: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._limit_order_average_size_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            bucket=bucket,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MarketOrderAverageSize",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def limit_order_average_size_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        bucket: Annotated[Optional[StrictStr], Field(description="You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[MarketOrderAverageSize]:
        """limit_order_average_size_get

        This metric calculates the average size of limit orders for a given ticker over a specified time period or candle, providing insight into typical limit order size during that interval.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param bucket: You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All
        :type bucket: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._limit_order_average_size_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            bucket=bucket,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MarketOrderAverageSize",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def limit_order_average_size_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        bucket: Annotated[Optional[StrictStr], Field(description="You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """limit_order_average_size_get

        This metric calculates the average size of limit orders for a given ticker over a specified time period or candle, providing insight into typical limit order size during that interval.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param bucket: You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All
        :type bucket: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._limit_order_average_size_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            bucket=bucket,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MarketOrderAverageSize",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _limit_order_average_size_get_serialize(
        self,
        coin,
        timeframe,
        exchange,
        market_types,
        bucket,
        sort,
        start_time,
        end_time,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if market_types is not None:
            
            _query_params.append(('marketTypes', market_types))
            
        if bucket is not None:
            
            _query_params.append(('bucket', bucket))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/limitOrderAverageSize',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def limit_order_count_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        bucket: Annotated[Optional[StrictStr], Field(description="You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> MarketOrderCount:
        """limit_order_count_get

        This indicator measures the count (number) of limit orders executed for a specific ticker within a set time period, providing insights into passive buying or selling pressure.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param bucket: You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All
        :type bucket: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._limit_order_count_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            bucket=bucket,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MarketOrderCount",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def limit_order_count_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        bucket: Annotated[Optional[StrictStr], Field(description="You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[MarketOrderCount]:
        """limit_order_count_get

        This indicator measures the count (number) of limit orders executed for a specific ticker within a set time period, providing insights into passive buying or selling pressure.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param bucket: You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All
        :type bucket: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._limit_order_count_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            bucket=bucket,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MarketOrderCount",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def limit_order_count_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        bucket: Annotated[Optional[StrictStr], Field(description="You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """limit_order_count_get

        This indicator measures the count (number) of limit orders executed for a specific ticker within a set time period, providing insights into passive buying or selling pressure.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param bucket: You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All
        :type bucket: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._limit_order_count_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            bucket=bucket,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MarketOrderCount",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _limit_order_count_get_serialize(
        self,
        coin,
        timeframe,
        exchange,
        market_types,
        bucket,
        sort,
        start_time,
        end_time,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if market_types is not None:
            
            _query_params.append(('marketTypes', market_types))
            
        if bucket is not None:
            
            _query_params.append(('bucket', bucket))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/limitOrderCount',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def market_order_average_size_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        bucket: Annotated[Optional[StrictStr], Field(description="You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> MarketOrderAverageSize:
        """market_order_average_size_get

        This metric calculates the average size of market orders for a given ticker over a specified time period or candle, providing insight into typical market order size during that interval.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param bucket: You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All
        :type bucket: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._market_order_average_size_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            bucket=bucket,
            start_time=start_time,
            end_time=end_time,
            sort=sort,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MarketOrderAverageSize",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def market_order_average_size_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        bucket: Annotated[Optional[StrictStr], Field(description="You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[MarketOrderAverageSize]:
        """market_order_average_size_get

        This metric calculates the average size of market orders for a given ticker over a specified time period or candle, providing insight into typical market order size during that interval.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param bucket: You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All
        :type bucket: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._market_order_average_size_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            bucket=bucket,
            start_time=start_time,
            end_time=end_time,
            sort=sort,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MarketOrderAverageSize",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def market_order_average_size_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        bucket: Annotated[Optional[StrictStr], Field(description="You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """market_order_average_size_get

        This metric calculates the average size of market orders for a given ticker over a specified time period or candle, providing insight into typical market order size during that interval.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param bucket: You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All
        :type bucket: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._market_order_average_size_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            bucket=bucket,
            start_time=start_time,
            end_time=end_time,
            sort=sort,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MarketOrderAverageSize",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _market_order_average_size_get_serialize(
        self,
        coin,
        timeframe,
        exchange,
        market_types,
        bucket,
        start_time,
        end_time,
        sort,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if market_types is not None:
            
            _query_params.append(('marketTypes', market_types))
            
        if bucket is not None:
            
            _query_params.append(('bucket', bucket))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/marketOrderAverageSize',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def market_order_count_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        bucket: Annotated[Optional[StrictStr], Field(description="You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> MarketOrderCount:
        """market_order_count_get

        This indicator measures the count (number) of market orders executed for a specific ticker within a set time period, providing insights into aggressive buying or selling pressure.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param bucket: You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All
        :type bucket: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._market_order_count_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            bucket=bucket,
            start_time=start_time,
            end_time=end_time,
            sort=sort,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MarketOrderCount",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def market_order_count_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        bucket: Annotated[Optional[StrictStr], Field(description="You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[MarketOrderCount]:
        """market_order_count_get

        This indicator measures the count (number) of market orders executed for a specific ticker within a set time period, providing insights into aggressive buying or selling pressure.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param bucket: You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All
        :type bucket: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._market_order_count_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            bucket=bucket,
            start_time=start_time,
            end_time=end_time,
            sort=sort,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MarketOrderCount",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def market_order_count_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        bucket: Annotated[Optional[StrictStr], Field(description="You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """market_order_count_get

        This indicator measures the count (number) of market orders executed for a specific ticker within a set time period, providing insights into aggressive buying or selling pressure.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param bucket: You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All
        :type bucket: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._market_order_count_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            bucket=bucket,
            start_time=start_time,
            end_time=end_time,
            sort=sort,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MarketOrderCount",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _market_order_count_get_serialize(
        self,
        coin,
        timeframe,
        exchange,
        market_types,
        bucket,
        start_time,
        end_time,
        sort,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if market_types is not None:
            
            _query_params.append(('marketTypes', market_types))
            
        if bucket is not None:
            
            _query_params.append(('bucket', bucket))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/marketOrderCount',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def participationratio_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Participationratio:
        """participationratio_get

        This metric indicates the percentage of volume attributed to net position openings by dividing OI Delta by Volume, showing the share of total volume represented by open interest changes.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._participationratio_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Participationratio",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def participationratio_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Participationratio]:
        """participationratio_get

        This metric indicates the percentage of volume attributed to net position openings by dividing OI Delta by Volume, showing the share of total volume represented by open interest changes.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._participationratio_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Participationratio",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def participationratio_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """participationratio_get

        This metric indicates the percentage of volume attributed to net position openings by dividing OI Delta by Volume, showing the share of total volume represented by open interest changes.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._participationratio_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Participationratio",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _participationratio_get_serialize(
        self,
        coin,
        timeframe,
        exchange,
        sort,
        start_time,
        end_time,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/participationratio',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def pd_levels_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PdLevels:
        """pd_levels_get

        Tracks key technical levels from the previous day (UTC). These key levels are previous day high, previous day low, previous day open, and previous day equilibrium (which is the average of high and low).

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pd_levels_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PdLevels",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def pd_levels_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PdLevels]:
        """pd_levels_get

        Tracks key technical levels from the previous day (UTC). These key levels are previous day high, previous day low, previous day open, and previous day equilibrium (which is the average of high and low).

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pd_levels_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PdLevels",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def pd_levels_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """pd_levels_get

        Tracks key technical levels from the previous day (UTC). These key levels are previous day high, previous day low, previous day open, and previous day equilibrium (which is the average of high and low).

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pd_levels_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PdLevels",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _pd_levels_get_serialize(
        self,
        coin,
        timeframe,
        exchange,
        sort,
        start_time,
        end_time,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/pdLevels',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def pm_levels_get(
        self,
        coin: StrictStr,
        timeframe: Annotated[StrictStr, Field(description="Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PmLevels:
        """pm_levels_get

        Tracks key technical levels from the previous month (UTC). These key levels are previous month high, previous month low, previous month open, and previous month equilibrium (which is the average of high and low).

        :param coin: (required)
        :type coin: str
        :param timeframe: Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pm_levels_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PmLevels",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def pm_levels_get_with_http_info(
        self,
        coin: StrictStr,
        timeframe: Annotated[StrictStr, Field(description="Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PmLevels]:
        """pm_levels_get

        Tracks key technical levels from the previous month (UTC). These key levels are previous month high, previous month low, previous month open, and previous month equilibrium (which is the average of high and low).

        :param coin: (required)
        :type coin: str
        :param timeframe: Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pm_levels_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PmLevels",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def pm_levels_get_without_preload_content(
        self,
        coin: StrictStr,
        timeframe: Annotated[StrictStr, Field(description="Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """pm_levels_get

        Tracks key technical levels from the previous month (UTC). These key levels are previous month high, previous month low, previous month open, and previous month equilibrium (which is the average of high and low).

        :param coin: (required)
        :type coin: str
        :param timeframe: Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pm_levels_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PmLevels",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _pm_levels_get_serialize(
        self,
        coin,
        timeframe,
        exchange,
        sort,
        start_time,
        end_time,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/pmLevels',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def pw_levels_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PwLevels:
        """pw_levels_get

        Tracks key technical levels from the previous week (UTC). These key levels are previous week high, previous week low, previous week open, and previous week equilibrium (which is the average of high and low).

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pw_levels_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PwLevels",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def pw_levels_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PwLevels]:
        """pw_levels_get

        Tracks key technical levels from the previous week (UTC). These key levels are previous week high, previous week low, previous week open, and previous week equilibrium (which is the average of high and low).

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pw_levels_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PwLevels",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def pw_levels_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """pw_levels_get

        Tracks key technical levels from the previous week (UTC). These key levels are previous week high, previous week low, previous week open, and previous week equilibrium (which is the average of high and low).

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter only single exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pw_levels_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PwLevels",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _pw_levels_get_serialize(
        self,
        coin,
        timeframe,
        exchange,
        sort,
        start_time,
        end_time,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/pwLevels',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def sell_volume_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        bucket: Annotated[Optional[StrictStr], Field(description="You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SellVolume:
        """sell_volume_get

        Aggregates the volume from market sell orders, summing the size of every market order on the sell side to reflect selling pressure.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param bucket: You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All
        :type bucket: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._sell_volume_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            bucket=bucket,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SellVolume",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def sell_volume_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        bucket: Annotated[Optional[StrictStr], Field(description="You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SellVolume]:
        """sell_volume_get

        Aggregates the volume from market sell orders, summing the size of every market order on the sell side to reflect selling pressure.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param bucket: You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All
        :type bucket: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._sell_volume_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            bucket=bucket,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SellVolume",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def sell_volume_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        bucket: Annotated[Optional[StrictStr], Field(description="You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """sell_volume_get

        Aggregates the volume from market sell orders, summing the size of every market order on the sell side to reflect selling pressure.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param bucket: You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All
        :type bucket: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._sell_volume_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            bucket=bucket,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SellVolume",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _sell_volume_get_serialize(
        self,
        coin,
        timeframe,
        exchange,
        market_types,
        sort,
        start_time,
        end_time,
        bucket,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if market_types is not None:
            
            _query_params.append(('marketTypes', market_types))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if bucket is not None:
            
            _query_params.append(('bucket', bucket))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/sellVolume',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def slippage_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        trade_type: Annotated[Optional[StrictStr], Field(description="Please select valid tradeType By default 'all'.")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Slippage:
        """slippage_get

        Slippage is the difference between the expected price of a trade and the actual price at which the trade is executed, which can occur due to delays or insufficient liquidity in the market.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param trade_type: Please select valid tradeType By default 'all'.
        :type trade_type: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._slippage_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            trade_type=trade_type,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Slippage",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def slippage_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        trade_type: Annotated[Optional[StrictStr], Field(description="Please select valid tradeType By default 'all'.")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Slippage]:
        """slippage_get

        Slippage is the difference between the expected price of a trade and the actual price at which the trade is executed, which can occur due to delays or insufficient liquidity in the market.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param trade_type: Please select valid tradeType By default 'all'.
        :type trade_type: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._slippage_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            trade_type=trade_type,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Slippage",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def slippage_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        trade_type: Annotated[Optional[StrictStr], Field(description="Please select valid tradeType By default 'all'.")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """slippage_get

        Slippage is the difference between the expected price of a trade and the actual price at which the trade is executed, which can occur due to delays or insufficient liquidity in the market.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param trade_type: Please select valid tradeType By default 'all'.
        :type trade_type: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._slippage_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            trade_type=trade_type,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Slippage",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _slippage_get_serialize(
        self,
        coin,
        timeframe,
        exchange,
        market_types,
        sort,
        start_time,
        end_time,
        trade_type,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if market_types is not None:
            
            _query_params.append(('marketTypes', market_types))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if trade_type is not None:
            
            _query_params.append(('tradeType', trade_type))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/slippage',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def transferofcontracts_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Transferofcontracts:
        """transferofcontracts_get

        This metric captures the absolute difference between volume and open interest, highlighting the volume involved in contract transfers that do not alter the net open interest.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._transferofcontracts_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Transferofcontracts",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def transferofcontracts_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Transferofcontracts]:
        """transferofcontracts_get

        This metric captures the absolute difference between volume and open interest, highlighting the volume involved in contract transfers that do not alter the net open interest.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._transferofcontracts_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Transferofcontracts",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def transferofcontracts_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """transferofcontracts_get

        This metric captures the absolute difference between volume and open interest, highlighting the volume involved in contract transfers that do not alter the net open interest.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._transferofcontracts_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Transferofcontracts",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _transferofcontracts_get_serialize(
        self,
        coin,
        timeframe,
        exchange,
        sort,
        start_time,
        end_time,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/transferofcontracts',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def volume_delta_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        bucket: Annotated[Optional[StrictStr], Field(description="You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> VolumeDelta:
        """volume_delta_get

        Calculates the difference between buy and sell volume, revealing which side (buy or sell) holds dominance in the market.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param bucket: You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All
        :type bucket: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._volume_delta_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            bucket=bucket,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VolumeDelta",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def volume_delta_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        bucket: Annotated[Optional[StrictStr], Field(description="You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[VolumeDelta]:
        """volume_delta_get

        Calculates the difference between buy and sell volume, revealing which side (buy or sell) holds dominance in the market.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param bucket: You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All
        :type bucket: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._volume_delta_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            bucket=bucket,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VolumeDelta",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def volume_delta_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        bucket: Annotated[Optional[StrictStr], Field(description="You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """volume_delta_get

        Calculates the difference between buy and sell volume, revealing which side (buy or sell) holds dominance in the market.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param bucket: You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All
        :type bucket: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._volume_delta_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            bucket=bucket,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VolumeDelta",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _volume_delta_get_serialize(
        self,
        coin,
        timeframe,
        exchange,
        market_types,
        sort,
        start_time,
        end_time,
        bucket,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if market_types is not None:
            
            _query_params.append(('marketTypes', market_types))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if bucket is not None:
            
            _query_params.append(('bucket', bucket))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/volumeDelta',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


