# coding: utf-8

"""
    All API Endpoints

    *Query params are case insensitive in all the APIs Endpoints.*

    The version of the OpenAPI document: v1
    Contact: ljofre2146@gmail.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Optional, Union
from typing_extensions import Annotated
from hyblock_capital_sdk.models.asks_increase_decrease import AsksIncreaseDecrease
from hyblock_capital_sdk.models.bid_ask import BidAsk
from hyblock_capital_sdk.models.bid_ask_delta import BidAskDelta
from hyblock_capital_sdk.models.bid_ask_ratio import BidAskRatio
from hyblock_capital_sdk.models.bid_ask_ratio_diff import BidAskRatioDiff
from hyblock_capital_sdk.models.bids_ask_spread import BidsAskSpread
from hyblock_capital_sdk.models.bids_increase_decrease import BidsIncreaseDecrease
from hyblock_capital_sdk.models.combined_book import CombinedBook

from hyblock_capital_sdk.api_client import ApiClient, RequestSerialized
from hyblock_capital_sdk.api_response import ApiResponse
from hyblock_capital_sdk.rest import RESTResponseType


class OrderbookApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def asks_increase_decrease_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin, All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.<br/> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        depth: Annotated[Optional[StrictStr], Field(description="Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20). If no depth entered.</br> Default: (0,full)")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AsksIncreaseDecrease:
        """asks_increase_decrease_get

        Change in orderbook Asks over a specific time period. The mathematical formula is Current Ask - Previous Ask

        :param coin: Please enter the valid coin, All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.<br/> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: float
        :param depth: Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20). If no depth entered.</br> Default: (0,full)
        :type depth: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._asks_increase_decrease_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            depth=depth,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AsksIncreaseDecrease",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def asks_increase_decrease_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin, All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.<br/> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        depth: Annotated[Optional[StrictStr], Field(description="Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20). If no depth entered.</br> Default: (0,full)")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AsksIncreaseDecrease]:
        """asks_increase_decrease_get

        Change in orderbook Asks over a specific time period. The mathematical formula is Current Ask - Previous Ask

        :param coin: Please enter the valid coin, All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.<br/> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: float
        :param depth: Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20). If no depth entered.</br> Default: (0,full)
        :type depth: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._asks_increase_decrease_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            depth=depth,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AsksIncreaseDecrease",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def asks_increase_decrease_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin, All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.<br/> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        depth: Annotated[Optional[StrictStr], Field(description="Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20). If no depth entered.</br> Default: (0,full)")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """asks_increase_decrease_get

        Change in orderbook Asks over a specific time period. The mathematical formula is Current Ask - Previous Ask

        :param coin: Please enter the valid coin, All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.<br/> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: float
        :param depth: Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20). If no depth entered.</br> Default: (0,full)
        :type depth: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._asks_increase_decrease_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            depth=depth,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AsksIncreaseDecrease",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _asks_increase_decrease_get_serialize(
        self,
        coin,
        timeframe,
        exchange,
        market_types,
        sort,
        start_time,
        end_time,
        depth,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if market_types is not None:
            
            _query_params.append(('marketTypes', market_types))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if depth is not None:
            
            _query_params.append(('depth', depth))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/asksIncreaseDecrease',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def bid_ask_delta_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        depth: Annotated[Optional[StrictStr], Field(description="Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20).If no depth entered.</br> Default: (0,full).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BidAskDelta:
        """bid_ask_delta_get

        Evaluate the immediate disparity between buy and sell orders.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param depth: Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20).If no depth entered.</br> Default: (0,full).
        :type depth: str
        :param limit: Please enter limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._bid_ask_delta_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            depth=depth,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BidAskDelta",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def bid_ask_delta_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        depth: Annotated[Optional[StrictStr], Field(description="Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20).If no depth entered.</br> Default: (0,full).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BidAskDelta]:
        """bid_ask_delta_get

        Evaluate the immediate disparity between buy and sell orders.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param depth: Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20).If no depth entered.</br> Default: (0,full).
        :type depth: str
        :param limit: Please enter limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._bid_ask_delta_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            depth=depth,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BidAskDelta",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def bid_ask_delta_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        depth: Annotated[Optional[StrictStr], Field(description="Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20).If no depth entered.</br> Default: (0,full).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """bid_ask_delta_get

        Evaluate the immediate disparity between buy and sell orders.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param depth: Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20).If no depth entered.</br> Default: (0,full).
        :type depth: str
        :param limit: Please enter limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._bid_ask_delta_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            depth=depth,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BidAskDelta",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _bid_ask_delta_get_serialize(
        self,
        coin,
        timeframe,
        exchange,
        market_types,
        sort,
        start_time,
        end_time,
        depth,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if market_types is not None:
            
            _query_params.append(('marketTypes', market_types))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if depth is not None:
            
            _query_params.append(('depth', depth))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/bidAskDelta',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def bid_ask_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin, All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.<br/> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        depth: Annotated[Optional[StrictStr], Field(description="Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20). If no depth entered.</br> Default: (0,full)")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BidAsk:
        """bid_ask_get

        A bid (or limit buy) is a “passive” buyer who advertises the price and size they would like to buy at. An asks (or limit sell) is a “passive” seller who advertises the price and size they would like to sell at.

        :param coin: Please enter the valid coin, All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.<br/> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: float
        :param depth: Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20). If no depth entered.</br> Default: (0,full)
        :type depth: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._bid_ask_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            depth=depth,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BidAsk",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def bid_ask_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin, All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.<br/> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        depth: Annotated[Optional[StrictStr], Field(description="Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20). If no depth entered.</br> Default: (0,full)")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BidAsk]:
        """bid_ask_get

        A bid (or limit buy) is a “passive” buyer who advertises the price and size they would like to buy at. An asks (or limit sell) is a “passive” seller who advertises the price and size they would like to sell at.

        :param coin: Please enter the valid coin, All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.<br/> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: float
        :param depth: Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20). If no depth entered.</br> Default: (0,full)
        :type depth: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._bid_ask_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            depth=depth,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BidAsk",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def bid_ask_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin, All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.<br/> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        depth: Annotated[Optional[StrictStr], Field(description="Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20). If no depth entered.</br> Default: (0,full)")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """bid_ask_get

        A bid (or limit buy) is a “passive” buyer who advertises the price and size they would like to buy at. An asks (or limit sell) is a “passive” seller who advertises the price and size they would like to sell at.

        :param coin: Please enter the valid coin, All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.<br/> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: float
        :param depth: Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20). If no depth entered.</br> Default: (0,full)
        :type depth: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._bid_ask_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            depth=depth,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BidAsk",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _bid_ask_get_serialize(
        self,
        coin,
        timeframe,
        exchange,
        market_types,
        sort,
        start_time,
        end_time,
        depth,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if market_types is not None:
            
            _query_params.append(('marketTypes', market_types))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if depth is not None:
            
            _query_params.append(('depth', depth))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/bidAsk',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def bid_ask_ratio_diff_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        depth: Annotated[Optional[StrictStr], Field(description="Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20).If no depth entered.</br> Default: (0,full).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BidAskRatioDiff:
        """bid_ask_ratio_diff_get

        Change in orderbook bid ask ratio over a specified period of time

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param depth: Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20).If no depth entered.</br> Default: (0,full).
        :type depth: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._bid_ask_ratio_diff_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            depth=depth,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BidAskRatioDiff",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def bid_ask_ratio_diff_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        depth: Annotated[Optional[StrictStr], Field(description="Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20).If no depth entered.</br> Default: (0,full).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BidAskRatioDiff]:
        """bid_ask_ratio_diff_get

        Change in orderbook bid ask ratio over a specified period of time

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param depth: Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20).If no depth entered.</br> Default: (0,full).
        :type depth: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._bid_ask_ratio_diff_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            depth=depth,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BidAskRatioDiff",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def bid_ask_ratio_diff_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        depth: Annotated[Optional[StrictStr], Field(description="Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20).If no depth entered.</br> Default: (0,full).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """bid_ask_ratio_diff_get

        Change in orderbook bid ask ratio over a specified period of time

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param depth: Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20).If no depth entered.</br> Default: (0,full).
        :type depth: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._bid_ask_ratio_diff_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            depth=depth,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BidAskRatioDiff",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _bid_ask_ratio_diff_get_serialize(
        self,
        coin,
        timeframe,
        exchange,
        market_types,
        sort,
        start_time,
        end_time,
        depth,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if market_types is not None:
            
            _query_params.append(('marketTypes', market_types))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if depth is not None:
            
            _query_params.append(('depth', depth))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/bidAskRatioDiff',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def bid_ask_ratio_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please enter the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        depth: Annotated[Optional[StrictStr], Field(description="Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20).If no depth entered.</br> Default: (0,full).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BidAskRatio:
        """bid_ask_ratio_get

        Bid Ask Ratio is an oscillator that ranges from -1 to 1. The mathematical formula is (Bids - Asks) / (Bids + Asks).

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please enter the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param depth: Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20).If no depth entered.</br> Default: (0,full).
        :type depth: str
        :param limit: Please enter limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._bid_ask_ratio_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            depth=depth,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BidAskRatio",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def bid_ask_ratio_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please enter the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        depth: Annotated[Optional[StrictStr], Field(description="Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20).If no depth entered.</br> Default: (0,full).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BidAskRatio]:
        """bid_ask_ratio_get

        Bid Ask Ratio is an oscillator that ranges from -1 to 1. The mathematical formula is (Bids - Asks) / (Bids + Asks).

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please enter the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param depth: Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20).If no depth entered.</br> Default: (0,full).
        :type depth: str
        :param limit: Please enter limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._bid_ask_ratio_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            depth=depth,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BidAskRatio",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def bid_ask_ratio_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please enter the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        depth: Annotated[Optional[StrictStr], Field(description="Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20).If no depth entered.</br> Default: (0,full).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """bid_ask_ratio_get

        Bid Ask Ratio is an oscillator that ranges from -1 to 1. The mathematical formula is (Bids - Asks) / (Bids + Asks).

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please enter the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param depth: Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20).If no depth entered.</br> Default: (0,full).
        :type depth: str
        :param limit: Please enter limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._bid_ask_ratio_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            depth=depth,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BidAskRatio",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _bid_ask_ratio_get_serialize(
        self,
        coin,
        timeframe,
        exchange,
        market_types,
        sort,
        start_time,
        end_time,
        depth,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if market_types is not None:
            
            _query_params.append(('marketTypes', market_types))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if depth is not None:
            
            _query_params.append(('depth', depth))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/bidAskRatio',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def bids_ask_spread_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BidsAskSpread:
        """bids_ask_spread_get

        Anchored Liq Level Count shows the number of buying and selling by dividing the OI Delta from Volume.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._bids_ask_spread_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BidsAskSpread",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def bids_ask_spread_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BidsAskSpread]:
        """bids_ask_spread_get

        Anchored Liq Level Count shows the number of buying and selling by dividing the OI Delta from Volume.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._bids_ask_spread_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BidsAskSpread",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def bids_ask_spread_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """bids_ask_spread_get

        Anchored Liq Level Count shows the number of buying and selling by dividing the OI Delta from Volume.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._bids_ask_spread_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BidsAskSpread",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _bids_ask_spread_get_serialize(
        self,
        coin,
        timeframe,
        exchange,
        market_types,
        sort,
        start_time,
        end_time,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if market_types is not None:
            
            _query_params.append(('marketTypes', market_types))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/bidsAskSpread',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def bids_increase_decrease_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin, All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.<br/> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        depth: Annotated[Optional[StrictStr], Field(description="Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20). If no depth entered.</br> Default: (0,full)")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BidsIncreaseDecrease:
        """bids_increase_decrease_get

        Change in orderbook Bids over a specific time period. The mathematical formula is Current Bid - Previous Bid

        :param coin: Please enter the valid coin, All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.<br/> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: float
        :param depth: Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20). If no depth entered.</br> Default: (0,full)
        :type depth: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._bids_increase_decrease_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            depth=depth,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BidsIncreaseDecrease",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def bids_increase_decrease_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin, All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.<br/> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        depth: Annotated[Optional[StrictStr], Field(description="Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20). If no depth entered.</br> Default: (0,full)")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BidsIncreaseDecrease]:
        """bids_increase_decrease_get

        Change in orderbook Bids over a specific time period. The mathematical formula is Current Bid - Previous Bid

        :param coin: Please enter the valid coin, All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.<br/> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: float
        :param depth: Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20). If no depth entered.</br> Default: (0,full)
        :type depth: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._bids_increase_decrease_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            depth=depth,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BidsIncreaseDecrease",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def bids_increase_decrease_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin, All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.<br/> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        depth: Annotated[Optional[StrictStr], Field(description="Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20). If no depth entered.</br> Default: (0,full)")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """bids_increase_decrease_get

        Change in orderbook Bids over a specific time period. The mathematical formula is Current Bid - Previous Bid

        :param coin: Please enter the valid coin, All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.<br/> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: float
        :param depth: Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20). If no depth entered.</br> Default: (0,full)
        :type depth: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._bids_increase_decrease_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            depth=depth,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BidsIncreaseDecrease",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _bids_increase_decrease_get_serialize(
        self,
        coin,
        timeframe,
        exchange,
        market_types,
        sort,
        start_time,
        end_time,
        depth,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if market_types is not None:
            
            _query_params.append(('marketTypes', market_types))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if depth is not None:
            
            _query_params.append(('depth', depth))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/bidsIncreaseDecrease',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def combined_book_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        depth: Annotated[Optional[StrictStr], Field(description="Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20).If no depth entered.</br> Default: (0,full).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CombinedBook:
        """combined_book_get

        A consolidated perspective of the market's orderbook dynamics.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param depth: Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20).If no depth entered.</br> Default: (0,full).
        :type depth: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._combined_book_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            depth=depth,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CombinedBook",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def combined_book_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        depth: Annotated[Optional[StrictStr], Field(description="Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20).If no depth entered.</br> Default: (0,full).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CombinedBook]:
        """combined_book_get

        A consolidated perspective of the market's orderbook dynamics.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param depth: Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20).If no depth entered.</br> Default: (0,full).
        :type depth: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._combined_book_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            depth=depth,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CombinedBook",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def combined_book_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        market_types: Annotated[Optional[StrictStr], Field(description="Please select the valid marketTypes (e.g. All, Spot, Perpetuals).")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        depth: Annotated[Optional[StrictStr], Field(description="Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20).If no depth entered.</br> Default: (0,full).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """combined_book_get

        A consolidated perspective of the market's orderbook dynamics.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param market_types: Please select the valid marketTypes (e.g. All, Spot, Perpetuals).
        :type market_types: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: str
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: str
        :param depth: Required depth in tuple with two paremeters. All the valid tuples are [0, quote, 1, 2, 5, 10, 20, full]. If we pass depth '0,full' in the depth tuple then we will get all the depth from (quote, 1, 5, 10, 20, full) and if we pass depth 'quote,20' in the depth tuple then we will get all the depth from (quote, 1, 2, 5, 10, 20).If no depth entered.</br> Default: (0,full).
        :type depth: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._combined_book_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            market_types=market_types,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            depth=depth,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CombinedBook",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _combined_book_get_serialize(
        self,
        coin,
        timeframe,
        exchange,
        market_types,
        sort,
        start_time,
        end_time,
        depth,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if market_types is not None:
            
            _query_params.append(('marketTypes', market_types))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if depth is not None:
            
            _query_params.append(('depth', depth))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/combinedBook',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


