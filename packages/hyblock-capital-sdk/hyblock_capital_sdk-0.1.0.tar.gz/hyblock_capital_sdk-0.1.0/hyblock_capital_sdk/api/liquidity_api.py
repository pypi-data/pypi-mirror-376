# coding: utf-8

"""
    All API Endpoints

    *Query params are case insensitive in all the APIs Endpoints.*

    The version of the OpenAPI document: v1
    Contact: ljofre2146@gmail.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Optional, Union
from typing_extensions import Annotated
from hyblock_capital_sdk.models.anchored_liq_levels_count import AnchoredLiqLevelsCount
from hyblock_capital_sdk.models.anchored_liq_levels_size import AnchoredLiqLevelsSize
from hyblock_capital_sdk.models.average_leverage_delta import AverageLeverageDelta
from hyblock_capital_sdk.models.average_leverage_used import AverageLeverageUsed
from hyblock_capital_sdk.models.cumulative_liq_level import CumulativeLiqLevel
from hyblock_capital_sdk.models.liquidation import Liquidation
from hyblock_capital_sdk.models.liquidation_heatmap import LiquidationHeatmap
from hyblock_capital_sdk.models.liquidation_levels import LiquidationLevels

from hyblock_capital_sdk.api_client import ApiClient, RequestSerialized
from hyblock_capital_sdk.api_response import ApiResponse
from hyblock_capital_sdk.rest import RESTResponseType


class LiquidityApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def anchored_liq_levels_count_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        level: Annotated[Optional[StrictStr], Field(description="Please enter the level long or short. If you do not enter any value the default will be 'long'")] = None,
        anchor: Annotated[Optional[StrictStr], Field(description="Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AnchoredLiqLevelsCount:
        """anchored_liq_levels_count_get

        Measures liquidation level count, anchored daily, 4-hourly, or hourly (UTC timezone), providing the count of predicted liquidation levels for open long liquidation levels and short liquidation levels. The endpoint outputs the number of long liquidation levels, short liquidation levels, and the delta between them. This endpoint helps users understand the imbalance between the number of open long and short liquidations levels.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param level: Please enter the level long or short. If you do not enter any value the default will be 'long'
        :type level: str
        :param anchor: Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'
        :type anchor: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._anchored_liq_levels_count_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            level=level,
            anchor=anchor,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnchoredLiqLevelsCount",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def anchored_liq_levels_count_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        level: Annotated[Optional[StrictStr], Field(description="Please enter the level long or short. If you do not enter any value the default will be 'long'")] = None,
        anchor: Annotated[Optional[StrictStr], Field(description="Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AnchoredLiqLevelsCount]:
        """anchored_liq_levels_count_get

        Measures liquidation level count, anchored daily, 4-hourly, or hourly (UTC timezone), providing the count of predicted liquidation levels for open long liquidation levels and short liquidation levels. The endpoint outputs the number of long liquidation levels, short liquidation levels, and the delta between them. This endpoint helps users understand the imbalance between the number of open long and short liquidations levels.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param level: Please enter the level long or short. If you do not enter any value the default will be 'long'
        :type level: str
        :param anchor: Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'
        :type anchor: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._anchored_liq_levels_count_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            level=level,
            anchor=anchor,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnchoredLiqLevelsCount",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def anchored_liq_levels_count_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        level: Annotated[Optional[StrictStr], Field(description="Please enter the level long or short. If you do not enter any value the default will be 'long'")] = None,
        anchor: Annotated[Optional[StrictStr], Field(description="Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """anchored_liq_levels_count_get

        Measures liquidation level count, anchored daily, 4-hourly, or hourly (UTC timezone), providing the count of predicted liquidation levels for open long liquidation levels and short liquidation levels. The endpoint outputs the number of long liquidation levels, short liquidation levels, and the delta between them. This endpoint helps users understand the imbalance between the number of open long and short liquidations levels.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param level: Please enter the level long or short. If you do not enter any value the default will be 'long'
        :type level: str
        :param anchor: Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'
        :type anchor: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._anchored_liq_levels_count_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            level=level,
            anchor=anchor,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnchoredLiqLevelsCount",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _anchored_liq_levels_count_get_serialize(
        self,
        coin,
        timeframe,
        exchange,
        sort,
        start_time,
        end_time,
        limit,
        level,
        anchor,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if level is not None:
            
            _query_params.append(('level', level))
            
        if anchor is not None:
            
            _query_params.append(('anchor', anchor))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/anchoredLiqLevelsCount',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def anchored_liq_levels_size_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        level: Annotated[Optional[StrictStr], Field(description="Please enter the level long or short. If you do not enter any value the default will be 'long'.")] = None,
        anchor: Annotated[Optional[StrictStr], Field(description="Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AnchoredLiqLevelsSize:
        """anchored_liq_levels_size_get

        Measures liquidation level size, anchored daily, 4-hourly, or hourly (UTC timezone), providing the count of predicted liquidation size for open long liquidation levels and short liquidation levels. The endpoint total size of long liquidation levels, short liquidation levels, and the delta between them. This endpoint helps users understand the imbalance between the size of open long and short liquidations levels.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param level: Please enter the level long or short. If you do not enter any value the default will be 'long'.
        :type level: str
        :param anchor: Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.
        :type anchor: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._anchored_liq_levels_size_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            level=level,
            anchor=anchor,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnchoredLiqLevelsSize",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def anchored_liq_levels_size_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        level: Annotated[Optional[StrictStr], Field(description="Please enter the level long or short. If you do not enter any value the default will be 'long'.")] = None,
        anchor: Annotated[Optional[StrictStr], Field(description="Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AnchoredLiqLevelsSize]:
        """anchored_liq_levels_size_get

        Measures liquidation level size, anchored daily, 4-hourly, or hourly (UTC timezone), providing the count of predicted liquidation size for open long liquidation levels and short liquidation levels. The endpoint total size of long liquidation levels, short liquidation levels, and the delta between them. This endpoint helps users understand the imbalance between the size of open long and short liquidations levels.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param level: Please enter the level long or short. If you do not enter any value the default will be 'long'.
        :type level: str
        :param anchor: Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.
        :type anchor: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._anchored_liq_levels_size_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            level=level,
            anchor=anchor,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnchoredLiqLevelsSize",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def anchored_liq_levels_size_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        level: Annotated[Optional[StrictStr], Field(description="Please enter the level long or short. If you do not enter any value the default will be 'long'.")] = None,
        anchor: Annotated[Optional[StrictStr], Field(description="Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """anchored_liq_levels_size_get

        Measures liquidation level size, anchored daily, 4-hourly, or hourly (UTC timezone), providing the count of predicted liquidation size for open long liquidation levels and short liquidation levels. The endpoint total size of long liquidation levels, short liquidation levels, and the delta between them. This endpoint helps users understand the imbalance between the size of open long and short liquidations levels.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236035).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param level: Please enter the level long or short. If you do not enter any value the default will be 'long'.
        :type level: str
        :param anchor: Please enter the anchor period (e.g. 1d, 1h, 4h). If you do not enter any value the default will be '1d'.
        :type anchor: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._anchored_liq_levels_size_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            level=level,
            anchor=anchor,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnchoredLiqLevelsSize",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _anchored_liq_levels_size_get_serialize(
        self,
        coin,
        timeframe,
        exchange,
        sort,
        start_time,
        end_time,
        limit,
        level,
        anchor,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if level is not None:
            
            _query_params.append(('level', level))
            
        if anchor is not None:
            
            _query_params.append(('anchor', anchor))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/anchoredLiqLevelsSize',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def average_leverage_delta_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime (e.g. 1661236035).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AverageLeverageDelta:
        """average_leverage_delta_get

         This metric captures the difference between the average leverage used in long and short positions by top traders, highlighting which side is utilizing more leverage.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime (e.g. 1661236035).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._average_leverage_delta_get_serialize(
            coin=coin,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AverageLeverageDelta",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def average_leverage_delta_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime (e.g. 1661236035).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AverageLeverageDelta]:
        """average_leverage_delta_get

         This metric captures the difference between the average leverage used in long and short positions by top traders, highlighting which side is utilizing more leverage.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime (e.g. 1661236035).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._average_leverage_delta_get_serialize(
            coin=coin,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AverageLeverageDelta",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def average_leverage_delta_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime (e.g. 1661236035).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """average_leverage_delta_get

         This metric captures the difference between the average leverage used in long and short positions by top traders, highlighting which side is utilizing more leverage.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime (e.g. 1661236035).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._average_leverage_delta_get_serialize(
            coin=coin,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AverageLeverageDelta",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _average_leverage_delta_get_serialize(
        self,
        coin,
        timeframe,
        sort,
        start_time,
        end_time,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/averageLeverageDelta',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def average_leverage_used_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AverageLeverageUsed:
        """average_leverage_used_get

        This metric shows the average leverage used in long and short positions by top traders, identified as those within the top percentage holding the largest open position values.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._average_leverage_used_get_serialize(
            coin=coin,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AverageLeverageUsed",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def average_leverage_used_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AverageLeverageUsed]:
        """average_leverage_used_get

        This metric shows the average leverage used in long and short positions by top traders, identified as those within the top percentage holding the largest open position values.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._average_leverage_used_get_serialize(
            coin=coin,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AverageLeverageUsed",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def average_leverage_used_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d).")],
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """average_leverage_used_get

        This metric shows the average leverage used in long and short positions by top traders, identified as those within the top percentage holding the largest open position values.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the valid timeframe By Default 1m (e.g. 1m, 5m, 15m, 1h, 4h, 1d). (required)
        :type timeframe: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._average_leverage_used_get_serialize(
            coin=coin,
            timeframe=timeframe,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AverageLeverageUsed",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _average_leverage_used_get_serialize(
        self,
        coin,
        timeframe,
        sort,
        start_time,
        end_time,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/averageLeverageUsed',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def cumulative_liq_level_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin, All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        timestamp: Annotated[Optional[StrictStr], Field(description="Please enter the valid timestamp.If you do not enter any timestamp the default will be the current time (e.g. 1661236020).")] = None,
        leverage: Annotated[Optional[StrictStr], Field(description="Please enter the valid leverage.You can entered single or multiple parementers with comma seprated (e.g. 25,50,100,all).")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CumulativeLiqLevel:
        """cumulative_liq_level_get

        Shows the general statistics of predicted liquidation levels, including the number of open long and short liquidation levels by size and count and the differences between them.

        :param coin: Please enter the valid coin, All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param exchange: Please enter the valid exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param timestamp: Please enter the valid timestamp.If you do not enter any timestamp the default will be the current time (e.g. 1661236020).
        :type timestamp: str
        :param leverage: Please enter the valid leverage.You can entered single or multiple parementers with comma seprated (e.g. 25,50,100,all).
        :type leverage: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cumulative_liq_level_get_serialize(
            coin=coin,
            exchange=exchange,
            timestamp=timestamp,
            leverage=leverage,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CumulativeLiqLevel",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cumulative_liq_level_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin, All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        timestamp: Annotated[Optional[StrictStr], Field(description="Please enter the valid timestamp.If you do not enter any timestamp the default will be the current time (e.g. 1661236020).")] = None,
        leverage: Annotated[Optional[StrictStr], Field(description="Please enter the valid leverage.You can entered single or multiple parementers with comma seprated (e.g. 25,50,100,all).")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CumulativeLiqLevel]:
        """cumulative_liq_level_get

        Shows the general statistics of predicted liquidation levels, including the number of open long and short liquidation levels by size and count and the differences between them.

        :param coin: Please enter the valid coin, All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param exchange: Please enter the valid exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param timestamp: Please enter the valid timestamp.If you do not enter any timestamp the default will be the current time (e.g. 1661236020).
        :type timestamp: str
        :param leverage: Please enter the valid leverage.You can entered single or multiple parementers with comma seprated (e.g. 25,50,100,all).
        :type leverage: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cumulative_liq_level_get_serialize(
            coin=coin,
            exchange=exchange,
            timestamp=timestamp,
            leverage=leverage,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CumulativeLiqLevel",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cumulative_liq_level_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin, All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        timestamp: Annotated[Optional[StrictStr], Field(description="Please enter the valid timestamp.If you do not enter any timestamp the default will be the current time (e.g. 1661236020).")] = None,
        leverage: Annotated[Optional[StrictStr], Field(description="Please enter the valid leverage.You can entered single or multiple parementers with comma seprated (e.g. 25,50,100,all).")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """cumulative_liq_level_get

        Shows the general statistics of predicted liquidation levels, including the number of open long and short liquidation levels by size and count and the differences between them.

        :param coin: Please enter the valid coin, All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param exchange: Please enter the valid exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param timestamp: Please enter the valid timestamp.If you do not enter any timestamp the default will be the current time (e.g. 1661236020).
        :type timestamp: str
        :param leverage: Please enter the valid leverage.You can entered single or multiple parementers with comma seprated (e.g. 25,50,100,all).
        :type leverage: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cumulative_liq_level_get_serialize(
            coin=coin,
            exchange=exchange,
            timestamp=timestamp,
            leverage=leverage,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CumulativeLiqLevel",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cumulative_liq_level_get_serialize(
        self,
        coin,
        exchange,
        timestamp,
        leverage,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if timestamp is not None:
            
            _query_params.append(('timestamp', timestamp))
            
        if leverage is not None:
            
            _query_params.append(('leverage', leverage))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/cumulativeLiqLevel',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def liquidation_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the timeframe.")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        bucket: Annotated[Optional[StrictStr], Field(description="You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Liquidation:
        """liquidation_get

        Event where a trader’s leveraged position is forced to close, due to margin not being enough to cover the loss.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the timeframe. (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param bucket: You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All
        :type bucket: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._liquidation_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            bucket=bucket,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Liquidation",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def liquidation_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the timeframe.")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        bucket: Annotated[Optional[StrictStr], Field(description="You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Liquidation]:
        """liquidation_get

        Event where a trader’s leveraged position is forced to close, due to margin not being enough to cover the loss.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the timeframe. (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param bucket: You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All
        :type bucket: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._liquidation_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            bucket=bucket,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Liquidation",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def liquidation_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        timeframe: Annotated[StrictStr, Field(description="Please select the timeframe.")],
        exchange: Annotated[Optional[StrictStr], Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="If desc, will sort results newest first.")] = None,
        start_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).")] = None,
        end_time: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).")] = None,
        bucket: Annotated[Optional[StrictStr], Field(description="You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Please select the limit size.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """liquidation_get

        Event where a trader’s leveraged position is forced to close, due to margin not being enough to cover the loss.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param timeframe: Please select the timeframe. (required)
        :type timeframe: str
        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.</br> Default: All exchanges
        :type exchange: str
        :param sort: If desc, will sort results newest first.
        :type sort: str
        :param start_time: Please enter the valid startTime.If you do not enter any startTime the default will be the current time (e.g. 1661236020).
        :type start_time: float
        :param end_time: Please enter the valid endTime.If you do not enter any endTime the default will be the current time (e.g. 1661236020).
        :type end_time: float
        :param bucket: You can enter one or multiple buckets with comma seperated, you can add the buckets. so if user types in 1,2,3 it will do 1+2+3 as a sum.  1 = 0-100 2=100-1k 3 = 1k-10k 4=10k-100k 5= 100k-1m 6=1m-10m 7= >10m.</br> Default: All
        :type bucket: str
        :param limit: Please select the limit size.
        :type limit: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._liquidation_get_serialize(
            coin=coin,
            timeframe=timeframe,
            exchange=exchange,
            sort=sort,
            start_time=start_time,
            end_time=end_time,
            bucket=bucket,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Liquidation",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _liquidation_get_serialize(
        self,
        coin,
        timeframe,
        exchange,
        sort,
        start_time,
        end_time,
        bucket,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if bucket is not None:
            
            _query_params.append(('bucket', bucket))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/liquidation',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def liquidation_heatmap_get(
        self,
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        lookback: Annotated[StrictStr, Field(description="Please select valid lookback (e.g. 12h, 7d, 1m, 3m, 6m, 1y, 2y).")],
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        ohlcgraph: Annotated[Optional[StrictStr], Field(description="Please enter the valid OHLCGraph, Defaults to the first exchange or only exchange input.")] = None,
        leverage: Annotated[Optional[StrictStr], Field(description="Please enter the valid leverage. By default: [L1, L2, L3, L4, L5]")] = None,
        timestamp: Annotated[Optional[StrictStr], Field(description="Please enter the valid timestamp.If you do not enter any timestamp the default will be the current time (e.g. 1661236020).")] = None,
        scaling: Annotated[Optional[StrictStr], Field(description="Please select valid scale, Default is 'relative'.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> LiquidationHeatmap:
        """liquidation_heatmap_get

        The Liquidation Heatmap calculates the liquidation levels based on market data and different leverage amounts. The calculated levels are then added to a price bucket on the chart.

        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param lookback: Please select valid lookback (e.g. 12h, 7d, 1m, 3m, 6m, 1y, 2y). (required)
        :type lookback: str
        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param ohlcgraph: Please enter the valid OHLCGraph, Defaults to the first exchange or only exchange input.
        :type ohlcgraph: str
        :param leverage: Please enter the valid leverage. By default: [L1, L2, L3, L4, L5]
        :type leverage: str
        :param timestamp: Please enter the valid timestamp.If you do not enter any timestamp the default will be the current time (e.g. 1661236020).
        :type timestamp: str
        :param scaling: Please select valid scale, Default is 'relative'.
        :type scaling: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._liquidation_heatmap_get_serialize(
            exchange=exchange,
            lookback=lookback,
            coin=coin,
            ohlcgraph=ohlcgraph,
            leverage=leverage,
            timestamp=timestamp,
            scaling=scaling,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LiquidationHeatmap",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def liquidation_heatmap_get_with_http_info(
        self,
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        lookback: Annotated[StrictStr, Field(description="Please select valid lookback (e.g. 12h, 7d, 1m, 3m, 6m, 1y, 2y).")],
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        ohlcgraph: Annotated[Optional[StrictStr], Field(description="Please enter the valid OHLCGraph, Defaults to the first exchange or only exchange input.")] = None,
        leverage: Annotated[Optional[StrictStr], Field(description="Please enter the valid leverage. By default: [L1, L2, L3, L4, L5]")] = None,
        timestamp: Annotated[Optional[StrictStr], Field(description="Please enter the valid timestamp.If you do not enter any timestamp the default will be the current time (e.g. 1661236020).")] = None,
        scaling: Annotated[Optional[StrictStr], Field(description="Please select valid scale, Default is 'relative'.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[LiquidationHeatmap]:
        """liquidation_heatmap_get

        The Liquidation Heatmap calculates the liquidation levels based on market data and different leverage amounts. The calculated levels are then added to a price bucket on the chart.

        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param lookback: Please select valid lookback (e.g. 12h, 7d, 1m, 3m, 6m, 1y, 2y). (required)
        :type lookback: str
        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param ohlcgraph: Please enter the valid OHLCGraph, Defaults to the first exchange or only exchange input.
        :type ohlcgraph: str
        :param leverage: Please enter the valid leverage. By default: [L1, L2, L3, L4, L5]
        :type leverage: str
        :param timestamp: Please enter the valid timestamp.If you do not enter any timestamp the default will be the current time (e.g. 1661236020).
        :type timestamp: str
        :param scaling: Please select valid scale, Default is 'relative'.
        :type scaling: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._liquidation_heatmap_get_serialize(
            exchange=exchange,
            lookback=lookback,
            coin=coin,
            ohlcgraph=ohlcgraph,
            leverage=leverage,
            timestamp=timestamp,
            scaling=scaling,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LiquidationHeatmap",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def liquidation_heatmap_get_without_preload_content(
        self,
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        lookback: Annotated[StrictStr, Field(description="Please select valid lookback (e.g. 12h, 7d, 1m, 3m, 6m, 1y, 2y).")],
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        ohlcgraph: Annotated[Optional[StrictStr], Field(description="Please enter the valid OHLCGraph, Defaults to the first exchange or only exchange input.")] = None,
        leverage: Annotated[Optional[StrictStr], Field(description="Please enter the valid leverage. By default: [L1, L2, L3, L4, L5]")] = None,
        timestamp: Annotated[Optional[StrictStr], Field(description="Please enter the valid timestamp.If you do not enter any timestamp the default will be the current time (e.g. 1661236020).")] = None,
        scaling: Annotated[Optional[StrictStr], Field(description="Please select valid scale, Default is 'relative'.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """liquidation_heatmap_get

        The Liquidation Heatmap calculates the liquidation levels based on market data and different leverage amounts. The calculated levels are then added to a price bucket on the chart.

        :param exchange: Please enter the valid exchange, you can enter single or multiple exchanges with comma seperated, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param lookback: Please select valid lookback (e.g. 12h, 7d, 1m, 3m, 6m, 1y, 2y). (required)
        :type lookback: str
        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param ohlcgraph: Please enter the valid OHLCGraph, Defaults to the first exchange or only exchange input.
        :type ohlcgraph: str
        :param leverage: Please enter the valid leverage. By default: [L1, L2, L3, L4, L5]
        :type leverage: str
        :param timestamp: Please enter the valid timestamp.If you do not enter any timestamp the default will be the current time (e.g. 1661236020).
        :type timestamp: str
        :param scaling: Please select valid scale, Default is 'relative'.
        :type scaling: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._liquidation_heatmap_get_serialize(
            exchange=exchange,
            lookback=lookback,
            coin=coin,
            ohlcgraph=ohlcgraph,
            leverage=leverage,
            timestamp=timestamp,
            scaling=scaling,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LiquidationHeatmap",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _liquidation_heatmap_get_serialize(
        self,
        exchange,
        lookback,
        coin,
        ohlcgraph,
        leverage,
        timestamp,
        scaling,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if lookback is not None:
            
            _query_params.append(('lookback', lookback))
            
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if ohlcgraph is not None:
            
            _query_params.append(('ohlcgraph', ohlcgraph))
            
        if leverage is not None:
            
            _query_params.append(('leverage', leverage))
            
        if timestamp is not None:
            
            _query_params.append(('timestamp', timestamp))
            
        if scaling is not None:
            
            _query_params.append(('scaling', scaling))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/liquidationHeatmap',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def liquidation_levels_get(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        timestamp: Annotated[Optional[StrictStr], Field(description="Please enter the valid timestamp.If you do not enter any timestamp the default will be the current time (e.g. 1661236020).")] = None,
        leverage: Annotated[Optional[StrictStr], Field(description="Please select the valid leverage.You can entered single or multiple parementers with comma seprated (e.g. 25,50,100,all).")] = None,
        position: Annotated[Optional[StrictStr], Field(description="Please select the valid position.You can entered only single parementer (e.g. long,short,all).")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> LiquidationLevels:
        """liquidation_levels_get

        Liquidation Levels are estimates of potential price levels where liquidation events may occur.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param exchange: Please enter the valid exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param timestamp: Please enter the valid timestamp.If you do not enter any timestamp the default will be the current time (e.g. 1661236020).
        :type timestamp: str
        :param leverage: Please select the valid leverage.You can entered single or multiple parementers with comma seprated (e.g. 25,50,100,all).
        :type leverage: str
        :param position: Please select the valid position.You can entered only single parementer (e.g. long,short,all).
        :type position: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._liquidation_levels_get_serialize(
            coin=coin,
            exchange=exchange,
            timestamp=timestamp,
            leverage=leverage,
            position=position,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LiquidationLevels",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def liquidation_levels_get_with_http_info(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        timestamp: Annotated[Optional[StrictStr], Field(description="Please enter the valid timestamp.If you do not enter any timestamp the default will be the current time (e.g. 1661236020).")] = None,
        leverage: Annotated[Optional[StrictStr], Field(description="Please select the valid leverage.You can entered single or multiple parementers with comma seprated (e.g. 25,50,100,all).")] = None,
        position: Annotated[Optional[StrictStr], Field(description="Please select the valid position.You can entered only single parementer (e.g. long,short,all).")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[LiquidationLevels]:
        """liquidation_levels_get

        Liquidation Levels are estimates of potential price levels where liquidation events may occur.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param exchange: Please enter the valid exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param timestamp: Please enter the valid timestamp.If you do not enter any timestamp the default will be the current time (e.g. 1661236020).
        :type timestamp: str
        :param leverage: Please select the valid leverage.You can entered single or multiple parementers with comma seprated (e.g. 25,50,100,all).
        :type leverage: str
        :param position: Please select the valid position.You can entered only single parementer (e.g. long,short,all).
        :type position: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._liquidation_levels_get_serialize(
            coin=coin,
            exchange=exchange,
            timestamp=timestamp,
            leverage=leverage,
            position=position,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LiquidationLevels",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def liquidation_levels_get_without_preload_content(
        self,
        coin: Annotated[StrictStr, Field(description="Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint.")],
        exchange: Annotated[StrictStr, Field(description="Please enter the valid exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint.")],
        timestamp: Annotated[Optional[StrictStr], Field(description="Please enter the valid timestamp.If you do not enter any timestamp the default will be the current time (e.g. 1661236020).")] = None,
        leverage: Annotated[Optional[StrictStr], Field(description="Please select the valid leverage.You can entered single or multiple parementers with comma seprated (e.g. 25,50,100,all).")] = None,
        position: Annotated[Optional[StrictStr], Field(description="Please select the valid position.You can entered only single parementer (e.g. long,short,all).")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """liquidation_levels_get

        Liquidation Levels are estimates of potential price levels where liquidation events may occur.

        :param coin: Please enter the valid coin. All the supported coins with their respective exchanges can be fetched via “/catalog” endpoint. (required)
        :type coin: str
        :param exchange: Please enter the valid exchange, All the supported exchanges with their respective coins can be fetched via “/catalog” endpoint. (required)
        :type exchange: str
        :param timestamp: Please enter the valid timestamp.If you do not enter any timestamp the default will be the current time (e.g. 1661236020).
        :type timestamp: str
        :param leverage: Please select the valid leverage.You can entered single or multiple parementers with comma seprated (e.g. 25,50,100,all).
        :type leverage: str
        :param position: Please select the valid position.You can entered only single parementer (e.g. long,short,all).
        :type position: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._liquidation_levels_get_serialize(
            coin=coin,
            exchange=exchange,
            timestamp=timestamp,
            leverage=leverage,
            position=position,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LiquidationLevels",
            '400': "Error400",
            '401': "Error401",
            '403': "Error403",
            '404': "Error404",
            '429': "Error429",
            '500': "Error500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _liquidation_levels_get_serialize(
        self,
        coin,
        exchange,
        timestamp,
        leverage,
        position,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if coin is not None:
            
            _query_params.append(('coin', coin))
            
        if exchange is not None:
            
            _query_params.append(('exchange', exchange))
            
        if timestamp is not None:
            
            _query_params.append(('timestamp', timestamp))
            
        if leverage is not None:
            
            _query_params.append(('leverage', leverage))
            
        if position is not None:
            
            _query_params.append(('position', position))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Api Key', 
            'Client Credentials'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/liquidationLevels',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


