{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Analyze Current ANSI Color Code Issue",
        "description": "Investigate the root cause of visible ANSI escape sequences in the safety branch warning dialog",
        "details": "Locate the safety branch warning implementation in the TunaCode codebase. Examine how ANSI color codes are being applied and why they're rendering as visible text instead of formatting. Check if the issue is in the prompt generation, color utility functions, or terminal output handling. Review related UI components to understand the expected color formatting patterns.\n<info added on 2025-07-22T21:28:22.937Z>\nRoot cause identified: The issue is in `/home/fabian/tunacode/src/tunacode/ui/tool_ui.py` in the `show_sync_confirmation` method (lines 157-159). Rich console interprets square brackets `[` and `]` as markup tags for formatting. When displaying options like `\"  [1] Yes (default)\"` using `ui.console.print()`, Rich attempts to parse `[1]` as a markup tag, fails, and displays raw ANSI escape codes instead. The solution requires escaping the square brackets or using Rich's Text object to display literal text without markup interpretation. This affects the sync confirmation dialog used when async operations aren't available.\n</info added on 2025-07-22T21:28:22.937Z>",
        "testStrategy": "Run TunaCode without a safety branch in different terminal environments to reproduce the issue. Document the exact ANSI codes being displayed and compare with working UI elements.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Fix ANSI Color Code Rendering",
        "description": "Repair the color code implementation to properly format text without visible escape sequences",
        "details": "Based on the analysis, fix the ANSI color code implementation. This may involve correcting color utility function calls, ensuring proper terminal detection, or fixing string formatting. Ensure colors are applied correctly using TunaCode's existing color system (likely using rich library). Update the safety warning dialog to use proper color formatting methods.",
        "testStrategy": "Test the fix in multiple terminal environments (bash, zsh, Windows Terminal). Verify that colors render properly and no ANSI codes are visible as text. Compare output with other TunaCode prompts for consistency.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Fix Text Alignment and Layout",
        "description": "Correct text alignment issues in the safety branch warning dialog",
        "details": "Address the misaligned 'Thinking...' text and ensure proper spacing and alignment for all elements in the safety warning dialog. Review the layout structure and adjust padding, margins, or positioning as needed. Ensure consistent indentation and visual hierarchy throughout the warning message.",
        "testStrategy": "Verify that all text elements are properly aligned and visually consistent. Test with different terminal widths to ensure responsive layout. Compare with other TunaCode dialogs for consistency.",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Standardize UI Formatting Patterns",
        "description": "Ensure the safety warning follows TunaCode's established UI patterns and conventions",
        "details": "Review existing TunaCode UI components to identify consistent patterns for warnings, confirmations, and user prompts. Apply these patterns to the safety branch warning to ensure visual consistency. This includes standardizing color usage, text formatting, spacing, and interactive element styling (like the '[1] Yes (default)' option).",
        "testStrategy": "Conduct side-by-side comparison with other TunaCode prompts and dialogs. Verify that styling, spacing, and interaction patterns match established conventions. Test user experience flow to ensure consistency.",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Comprehensive Terminal Compatibility Testing",
        "description": "Test the fixed safety warning across different terminal emulators and environments",
        "details": "Perform comprehensive testing across common terminal environments including bash, zsh, Windows Terminal, macOS Terminal, and popular terminal emulators. Verify proper rendering, color support detection, and fallback behavior for terminals with limited color support. Document any environment-specific issues and ensure graceful degradation.",
        "testStrategy": "Create a test matrix covering different terminals, operating systems, and color support levels. Test both the safety warning dialog and surrounding TunaCode functionality to ensure no regressions. Verify that the fix works consistently across all supported environments.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "cancelled",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Multi-Turn Recursive Loop for Complex Task Decomposition",
        "description": "Implement a recursive multi-turn loop system that enables TunaCode to autonomously break down complex tasks into subtasks, execute them independently, and aggregate results - similar to how Anthropic's Claude Code handles complex requests.",
        "details": "The task involves creating a RecursiveTaskExecutor class that can detect complex tasks, break them down into executable subtasks using DSPy planner, execute subtasks recursively with independent iteration budgets, and aggregate results. The system should support hierarchical task management with parent-child relationships, context inheritance, and progress tracking. Key components include: RecursiveTaskExecutor class, enhanced SessionState with recursion tracking, modified process_request() function, iteration budget management, and UI components for visual feedback.",
        "testStrategy": "1. Unit tests for task decomposition logic, iteration budget allocation, result aggregation, and recursion depth limits. 2. Integration tests for end-to-end complex task execution, context propagation across subtasks, error handling in recursive execution, and performance with deeply nested tasks. 3. Characterization tests to capture behavior of complex task handling, ensure backward compatibility, and verify deterministic decomposition.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Create RecursiveTaskExecutor Core Class",
            "description": "Implement the main RecursiveTaskExecutor class that serves as the orchestrator for recursive task decomposition and execution",
            "dependencies": [],
            "details": "Create src/tunacode/core/recursive/executor.py with RecursiveTaskExecutor class. Include methods for task complexity detection, subtask generation using DSPy planner, execution orchestration, and result aggregation. Implement recursive depth tracking and iteration budget management. The class should handle parent-child task relationships and maintain execution context throughout the recursive process.\n<info added on 2025-07-24T02:15:13.895Z>\nUpdate the RecursiveTaskExecutor implementation to remove DSPy planner dependency. The class should integrate with TunaCode's existing agent system for task analysis and decomposition. Replace DSPy planner method calls with agent-based task breakdown using the main agent's reasoning capabilities and the existing tool system. The task complexity detection and subtask generation should leverage the current pydantic-ai agent architecture instead of external DSPy components.\n</info added on 2025-07-24T02:15:13.895Z>",
            "status": "done",
            "testStrategy": "Unit tests for task detection logic, recursion depth limits, budget allocation, and basic execution flow without actual tool calls"
          },
          {
            "id": 2,
            "title": "Enhance SessionState for Recursion Tracking",
            "description": "Extend the existing SessionState class to support recursive execution context and hierarchy tracking",
            "dependencies": [
              "6.1"
            ],
            "details": "Modify src/tunacode/core/state.py to add recursion-specific fields: current_recursion_depth, max_recursion_depth, parent_task_id, task_hierarchy, iteration_budgets, and recursive_context_stack. Add methods for managing recursive state transitions, context inheritance, and cleanup. Ensure thread-safety for concurrent subtask execution.",
            "status": "done",
            "testStrategy": "Unit tests for state transitions, context inheritance, recursion depth tracking, and concurrent access safety"
          },
          {
            "id": 3,
            "title": "Implement Task Decomposition Engine",
            "description": "Create the intelligent task breakdown system using DSPy planner to analyze complex tasks and generate executable subtasks",
            "dependencies": [
              "6.1"
            ],
            "details": "Implement src/tunacode/core/recursive/decomposer.py with TaskDecomposer class. Use DSPy ChainOfThought module to analyze task complexity, identify decomposition patterns, and generate structured subtasks with proper dependencies. Include heuristics for determining when a task should be decomposed versus executed directly. Integrate with existing agent tools and maintain context awareness.\n<info added on 2025-07-24T02:15:27.100Z>\nBased on the current subtask details and the user request, here is the new text to be appended:\n\n**UPDATED IMPLEMENTATION APPROACH**: Remove DSPy dependency and replace with pydantic-ai agent integration. The TaskDecomposer class should utilize the existing main agent (from core/agents/main.py) for task analysis and decomposition. Implement complexity analysis through structured prompts to the agent, requesting it to evaluate task scope, identify natural breakpoints, and generate subtasks with dependencies. Leverage the agent's existing tool ecosystem and maintain consistency with the current architecture. The decomposer should use agent conversations to determine decomposition strategies rather than separate ML modules.\n</info added on 2025-07-24T02:15:27.100Z>",
            "status": "done",
            "testStrategy": "Unit tests for complexity detection algorithms, subtask generation quality, dependency resolution, and integration with DSPy modules"
          },
          {
            "id": 4,
            "title": "Build Hierarchical Task Management System",
            "description": "Implement the data structures and management logic for maintaining parent-child task relationships and execution state",
            "dependencies": [
              "6.2"
            ],
            "details": "Create src/tunacode/core/recursive/hierarchy.py with TaskHierarchy class. Implement tree-based task storage, parent-child relationship tracking, dependency resolution, and execution order determination. Add methods for context propagation between parent and child tasks, result aggregation, and error propagation handling. Support dynamic task addition during execution.",
            "status": "done",
            "testStrategy": "Unit tests for hierarchy operations, dependency resolution algorithms, context propagation, and error handling scenarios"
          },
          {
            "id": 5,
            "title": "Integrate Recursive Execution into Main Process Loop",
            "description": "Modify the main request processing pipeline to detect and handle recursive task execution",
            "dependencies": [
              "6.2",
              "6.3",
              "6.4"
            ],
            "details": "Enhance src/tunacode/core/main.py process_request() function to integrate RecursiveTaskExecutor. Add complexity detection logic to determine when to trigger recursive execution versus direct processing. Implement handoff mechanisms between normal and recursive execution modes while preserving existing functionality and tool access patterns.",
            "status": "done",
            "testStrategy": "Integration tests for request routing, mode switching, backward compatibility, and end-to-end complex task execution"
          },
          {
            "id": 6,
            "title": "Implement Iteration Budget Management",
            "description": "Create a sophisticated budget allocation and tracking system for managing computational resources across recursive executions",
            "dependencies": [
              "6.1",
              "6.4"
            ],
            "details": "Develop src/tunacode/core/recursive/budget.py with BudgetManager class. Implement algorithms for distributing iteration budgets across subtasks based on complexity estimates, tracking resource consumption, and enforcing limits. Include budget inheritance from parent to child tasks, dynamic reallocation based on execution progress, and graceful degradation when budgets are exhausted.",
            "status": "done",
            "testStrategy": "Unit tests for budget allocation algorithms, consumption tracking accuracy, limit enforcement, and resource optimization strategies"
          },
          {
            "id": 7,
            "title": "Build Result Aggregation and Context Management",
            "description": "Implement sophisticated result collection and context synthesis from distributed subtask executions",
            "dependencies": [
              "6.4",
              "6.5"
            ],
            "details": "Create src/tunacode/core/recursive/aggregator.py with ResultAggregator class. Implement intelligent result merging strategies, context synthesis from multiple execution branches, conflict resolution for contradictory results, and final output generation. Handle partial results from failed subtasks and maintain execution traceability for debugging.",
            "status": "done",
            "testStrategy": "Unit tests for result merging algorithms, context synthesis quality, conflict resolution, and partial failure handling"
          },
          {
            "id": 8,
            "title": "Add Visual Feedback and Progress Tracking UI",
            "description": "Implement comprehensive user interface components for visualizing recursive execution progress and hierarchy",
            "dependencies": [
              "6.5",
              "6.7"
            ],
            "details": "Enhance src/tunacode/ui/ components to display recursive execution progress. Add hierarchical task tree visualization, real-time progress indicators, budget consumption tracking, and execution depth indicators. Implement interactive progress display using rich library components, with ability to collapse/expand subtask details and show execution timelines.",
            "status": "done",
            "testStrategy": "Integration tests for UI rendering, progress accuracy, user interaction flows, and visual consistency across different terminal environments"
          }
        ]
      },
      {
        "id": 7,
        "title": "Implement automatic retry logic for tool batching failures",
        "description": "When tool batching JSON parsing fails in parse_json_tool_calls() and extract_and_execute_tool_calls() functions, the system should automatically retry up to 10 times before reporting the error to the user. The error is generated by the LLM returning malformed JSON, not from TunaCode source code.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "The issue occurs when the model returns invalid JSON for batched tool calls. The JSON parsing happens in parse_json_tool_calls() and extract_and_execute_tool_calls() in utils.py, where JSONDecodeError is currently caught silently without retry logic. Implementation needed:\n1. Add retry mechanism with exponential backoff specifically for JSON parsing failures\n2. Maximum of 10 retry attempts for JSONDecodeError exceptions\n3. Clear error message after all retries exhausted stating 'The model is having issues with tool batching'\n4. Log each retry attempt for debugging\n5. Preserve the original error context for troubleshooting\n6. Focus on utils.py functions: parse_json_tool_calls() and extract_and_execute_tool_calls()",
        "testStrategy": "1. Unit tests for retry logic with mocked JSONDecodeError failures in utils.py functions\n2. Integration test simulating malformed JSON from LLM responses\n3. Test exponential backoff timing for JSON parsing retries\n4. Verify error message after max retries exhausted\n5. Test successful recovery within retry limit\n6. Mock LLM responses with invalid JSON to trigger retry mechanism",
        "subtasks": [
          {
            "id": 1,
            "title": "Analyze parse_json_tool_calls() function in utils.py",
            "description": "Examine the current JSONDecodeError handling in parse_json_tool_calls() function",
            "status": "done",
            "dependencies": [],
            "details": "Review how JSONDecodeError is currently caught and handled silently. Identify the exact location where retry logic should be added.",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Analyze extract_and_execute_tool_calls() function in utils.py",
            "description": "Examine the current JSONDecodeError handling in extract_and_execute_tool_calls() function",
            "status": "done",
            "dependencies": [],
            "details": "Review how JSONDecodeError is currently caught and handled silently. Identify the exact location where retry logic should be added.",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement exponential backoff retry decorator",
            "description": "Create a reusable retry decorator with exponential backoff for JSON parsing failures",
            "status": "done",
            "dependencies": [],
            "details": "Implement a decorator that can be applied to JSON parsing operations with configurable max retries (default 10) and exponential backoff timing.",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Add retry logic to parse_json_tool_calls()",
            "description": "Integrate retry mechanism into parse_json_tool_calls() function",
            "status": "done",
            "dependencies": [],
            "details": "Replace silent JSONDecodeError handling with retry logic that attempts up to 10 times with exponential backoff before failing.",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Add retry logic to extract_and_execute_tool_calls()",
            "description": "Integrate retry mechanism into extract_and_execute_tool_calls() function",
            "status": "done",
            "dependencies": [],
            "details": "Replace silent JSONDecodeError handling with retry logic that attempts up to 10 times with exponential backoff before failing.",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Implement comprehensive logging for retry attempts",
            "description": "Add detailed logging for each retry attempt to aid debugging",
            "status": "done",
            "dependencies": [],
            "details": "Log retry attempt number, delay time, original error, and context information for troubleshooting malformed JSON issues.",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Add final error message after retry exhaustion",
            "description": "Display clear user-facing error message when all retries are exhausted",
            "status": "done",
            "dependencies": [],
            "details": "After 10 failed retry attempts, show the message 'The model is having issues with tool batching' while preserving original error context for debugging.",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 8,
        "title": "Create unit tests for RecursiveTaskExecutor",
        "description": "Write comprehensive unit tests for the RecursiveTaskExecutor class including task execution, complexity analysis, and error handling scenarios",
        "details": "Create tests/unit/test_recursive_executor.py with tests for:\n- execute_task() with various complexity levels\n- _analyze_task_complexity() logic\n- _execute_with_decomposition() flow\n- _execute_directly() flow\n- _allocate_iteration_budgets() calculations\n- Error handling and edge cases\n- Max recursion depth limits\n\nIntegrate with Makefile test target to run with 'make test'",
        "testStrategy": "Use pytest with async test support. Mock the StateManager and agent interactions. Verify correct task decomposition and execution flow.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Create unit tests for TaskDecomposer and BudgetManager",
        "description": "Write unit tests for TaskDecomposer complexity analysis and BudgetManager allocation strategies",
        "details": "Create tests/unit/test_task_decomposer.py with tests for:\n- analyze_and_decompose() with various task types\n- Complexity scoring logic\n- Subtask generation\n- Confidence calculations\n\nCreate tests/unit/test_budget_manager.py with tests for:\n- allocate_budget() with different strategies (equal, weighted, adaptive, priority)\n- consume_budget() and release_budget() operations\n- Budget summary calculations\n- Edge cases (zero budget, single task, many tasks)\n\nEnsure tests run with 'make test'",
        "testStrategy": "Use pytest with mocking for external dependencies. Test various allocation strategies and edge cases. Verify mathematical correctness of budget calculations.",
        "status": "cancelled",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Create unit tests for ResultAggregator and TaskHierarchy",
        "description": "Write unit tests for ResultAggregator result combination strategies and TaskHierarchy relationship tracking",
        "details": "Create tests/unit/test_result_aggregator.py with tests for:\n- aggregate_results() with different strategies (simple, structured, intelligent)\n- _simple_aggregation() text concatenation\n- _structured_aggregation() JSON/dict merging\n- _intelligent_aggregation() with mock agent responses\n- Error handling for failed subtasks\n\nCreate tests/unit/test_task_hierarchy.py with tests for:\n- add_task() and remove_task() operations\n- get_children() and get_ancestors() queries\n- detect_cycles() for circular dependencies\n- get_execution_order() topological sorting\n- Relationship validation\n\nUpdate Makefile to include new test files in 'make test' target",
        "testStrategy": "Use pytest with fixtures for common test data. Mock agent interactions for intelligent aggregation. Test graph algorithms for hierarchy management.",
        "status": "cancelled",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Create template directory structure at ~/.config/tunacode/templates/ and ensure it exists on initialization",
        "description": "Establish a standardized template directory structure in the user's config directory and ensure it's created during TunaCode initialization process.",
        "details": "Create a template system infrastructure by:\n1. Define template directory structure at ~/.config/tunacode/templates/ with subdirectories for different template types (e.g., project/, tool/, config/)\n2. Modify the setup coordinator in core/setup.py to include template directory creation as a setup step\n3. Add template directory validation to existing setup steps, ensuring proper permissions and accessibility\n4. Create base template files or placeholder structure to demonstrate the system\n5. Update StateManager to track template directory location and availability\n6. Ensure cross-platform compatibility for config directory paths (Windows, macOS, Linux)\n7. Add error handling for cases where directory creation fails due to permissions or disk space",
        "testStrategy": "1. Unit tests for template directory creation logic with different OS environments\n2. Integration tests verifying setup coordinator properly creates template structure during initialization\n3. Test permission handling when directory creation fails\n4. Verify template directory is accessible and writable after creation\n5. Test cleanup and recreation scenarios\n6. Cross-platform path resolution testing for config directory locations\n7. End-to-end test ensuring templates are available after fresh TunaCode installation",
        "status": "done",
        "dependencies": [
          4
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Create Template dataclass and TemplateLoader class in src/tunacode/templates/loader.py",
        "description": "Implement a Template dataclass to represent template metadata and a TemplateLoader class with methods to load, list, and save JSON templates from the filesystem.",
        "details": "Create src/tunacode/templates/loader.py with:\n1. Template dataclass using @dataclass decorator with fields: name (str), description (str), category (str), content (dict), created_at (datetime), tags (list[str])\n2. TemplateLoader class with methods:\n   - load_template(name: str) -> Template: Load template from JSON file in ~/.config/tunacode/templates/\n   - list_templates() -> list[Template]: Return all available templates with metadata\n   - save_template(template: Template) -> bool: Save template to JSON file with validation\n   - delete_template(name: str) -> bool: Remove template file safely\n   - get_template_path(name: str) -> Path: Helper to construct template file paths\n3. Add proper error handling for file I/O operations, JSON parsing errors, and invalid template data\n4. Include type hints and docstrings for all methods\n5. Use pathlib.Path for file operations and ensure cross-platform compatibility\n6. Implement template validation to ensure required fields are present",
        "testStrategy": "1. Unit tests for Template dataclass validation and serialization/deserialization\n2. Unit tests for TemplateLoader methods with mocked filesystem operations\n3. Test load_template() with valid/invalid JSON files and missing files\n4. Test list_templates() with empty directory and multiple template files\n5. Test save_template() with valid templates and error conditions (permissions, disk space)\n6. Test delete_template() with existing/non-existing files\n7. Integration tests with actual template directory structure\n8. Test cross-platform path handling and file operations",
        "status": "done",
        "dependencies": [
          11
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Add active_template property and template validation to ToolHandler",
        "description": "Modify the ToolHandler class to track the currently active template and validate tool usage against the template's allowed_tools list in the should_confirm method.",
        "details": "Update src/tunacode/core/tool_handler.py to:\n1. Add active_template property to ToolHandler class to store the currently active Template instance\n2. Add setter method set_active_template(template: Template) to update the active template\n3. Modify should_confirm() method to check if the current tool is in template.allowed_tools when an active template is set\n4. If tool is not in allowed_tools, either skip confirmation (for pre-approved tools in template) or enforce confirmation (for restricted tools)\n5. Add proper type hints and documentation for the new functionality\n6. Handle edge cases where active_template is None or template has no allowed_tools defined\n7. Ensure backward compatibility when no template is active",
        "testStrategy": "1. Unit tests for set_active_template() method with valid Template objects and None values\n2. Test should_confirm() behavior with different template configurations:\n   - No active template (existing behavior preserved)\n   - Template with allowed_tools list containing the current tool\n   - Template with allowed_tools list not containing the current tool\n   - Template with empty or missing allowed_tools list\n3. Integration tests verifying tool confirmation flow with active templates\n4. Test type checking and error handling for invalid template objects",
        "status": "done",
        "dependencies": [
          12
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Create TemplateCommand class with list, load, and create subcommands",
        "description": "Implement a new TemplateCommand class in the CLI commands module to provide template management functionality through list, load, and create subcommands.",
        "details": "Create src/tunacode/cli/commands/implementations/template.py with:\n1. TemplateCommand class extending BaseCommand with matches() method recognizing '/template' prefix\n2. execute() method parsing subcommands: list, load, create\n3. _list_templates() method using TemplateLoader.list_templates() to display available templates in formatted table\n4. _load_template(name: str) method to activate a template using TemplateLoader.load_template() and ToolHandler.set_active_template()\n5. _create_template() method with interactive prompts for template creation (name, description, category, allowed_tools selection)\n6. Register the command with @CommandRegistry.register decorator\n7. Add comprehensive error handling for invalid template names, file system errors, and malformed templates\n8. Include usage help text showing available subcommands and syntax",
        "testStrategy": "1. Unit tests for TemplateCommand.matches() with various input patterns ('/template list', '/template load name', etc.)\n2. Test execute() method routing to correct subcommand handlers\n3. Mock TemplateLoader and ToolHandler dependencies to test _list_templates(), _load_template(), and _create_template() methods\n4. Test error handling for non-existent templates, invalid subcommands, and file system failures\n5. Integration tests verifying command registration and CLI interaction flow\n6. Test interactive template creation with various input scenarios",
        "status": "done",
        "dependencies": [
          12,
          13
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Create example JSON templates (web-dev.json, debug.json, refactor.json) in templates directory for common use cases",
        "description": "Create three pre-configured JSON template files in the templates directory that demonstrate common development workflows with appropriate tool restrictions and metadata.",
        "details": "Create three template files in ~/.config/tunacode/templates/:\n\n1. web-dev.json - Web development template with:\n   - allowed_tools: [\"read_file\", \"write_file\", \"update_file\", \"run_command\", \"list_dir\", \"grep\"]\n   - category: \"development\"\n   - description: \"Template for web development projects with frontend/backend tools\"\n   - tags: [\"web\", \"frontend\", \"backend\", \"javascript\", \"html\", \"css\"]\n   - content: {\"framework_preferences\": [\"react\", \"vue\", \"angular\"], \"build_tools\": [\"webpack\", \"vite\", \"parcel\"]}\n\n2. debug.json - Debugging template with:\n   - allowed_tools: [\"read_file\", \"grep\", \"list_dir\", \"run_command\"]\n   - category: \"debugging\"\n   - description: \"Template for debugging and investigation tasks with read-only focus\"\n   - tags: [\"debug\", \"investigation\", \"analysis\", \"troubleshooting\"]\n   - content: {\"log_patterns\": [\"ERROR\", \"WARN\", \"EXCEPTION\"], \"common_commands\": [\"ps aux\", \"netstat\", \"lsof\"]}\n\n3. refactor.json - Refactoring template with:\n   - allowed_tools: [\"read_file\", \"update_file\", \"grep\", \"list_dir\"]\n   - category: \"refactoring\"\n   - description: \"Template for code refactoring with controlled file modification\"\n   - tags: [\"refactor\", \"cleanup\", \"optimization\", \"restructure\"]\n   - content: {\"refactor_patterns\": [\"extract_method\", \"rename_variable\", \"move_class\"], \"safety_checks\": [\"run_tests\", \"lint_check\"]}\n\nEach template should include created_at timestamp and follow the Template dataclass structure defined in Task 12.",
        "testStrategy": "1. Verify each template file is valid JSON and can be parsed without errors\n2. Test that each template conforms to the Template dataclass schema with all required fields (name, description, category, content, created_at, tags)\n3. Validate allowed_tools arrays contain only valid tool names from the TunaCode tool system\n4. Test TemplateLoader.load_template() can successfully load each template file\n5. Verify templates appear in TemplateLoader.list_templates() output with correct metadata\n6. Test template activation through ToolHandler.set_active_template() for each template\n7. Validate that tool confirmation behavior changes appropriately when each template is active",
        "status": "done",
        "dependencies": [
          11,
          12
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Add integration tests for template system: loading templates, auto-approval of tools, and command functionality",
        "description": "Create comprehensive integration tests to verify the complete template system workflow including template loading, tool auto-approval behavior, and CLI command interactions.",
        "details": "Create integration test file tests/test_template_integration.py with comprehensive test scenarios:\n1. Template loading integration - test TemplateLoader with real filesystem operations, verify templates are loaded correctly with all metadata\n2. Tool auto-approval workflow - test ToolHandler with active templates, verify tools in allowed_tools skip confirmations while restricted tools still require confirmation\n3. CLI command integration - test TemplateCommand with StateManager and ToolHandler, verify '/template list', '/template load', and '/template create' work end-to-end\n4. Template activation flow - test complete workflow from loading template via CLI command to tool execution with template restrictions\n5. Error handling scenarios - test behavior with invalid templates, missing files, and permission issues\n6. Template persistence - verify templates remain active across multiple tool executions and state changes\n7. Integration with existing yolo mode - ensure template auto-approval works correctly with and without yolo mode enabled",
        "testStrategy": "1. Set up test fixtures with real template files in temporary directories to test actual filesystem operations\n2. Create integration test scenarios that exercise the full stack from CLI input through StateManager, TemplateCommand, TemplateLoader, and ToolHandler\n3. Test template loading and activation with real JSON files, verifying Template dataclass parsing and ToolHandler integration\n4. Verify tool confirmation behavior changes correctly when templates are active vs inactive\n5. Test CLI command parsing and execution with mock user input for all template subcommands\n6. Create scenarios testing error conditions like invalid JSON, missing templates, and permission failures\n7. Verify integration with existing permission system and yolo mode interactions\n8. Use pytest fixtures for test isolation and cleanup of temporary files and state",
        "status": "pending",
        "dependencies": [
          11,
          12,
          13,
          14,
          15
        ],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-22T21:24:36.985Z",
      "updated": "2025-08-02T18:28:08.614Z",
      "description": "Tasks for master context"
    }
  }
}
