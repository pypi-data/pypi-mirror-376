"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import ni.datamonikers.v1.data_moniker_pb2
import ni.measurements.metadata.v1.metadata_store_pb2
import ni.protobuf.types.precision_timestamp_pb2
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _Outcome:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _OutcomeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Outcome.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    OUTCOME_UNSPECIFIED: _Outcome.ValueType  # 0
    """No outcome was specified."""
    OUTCOME_PASSED: _Outcome.ValueType  # 1
    """The measurement passed."""
    OUTCOME_FAILED: _Outcome.ValueType  # 2
    """The measurement failed."""
    OUTCOME_INDETERMINATE: _Outcome.ValueType  # 3
    """The outcome is indeterminate."""

class Outcome(_Outcome, metaclass=_OutcomeEnumTypeWrapper):
    """Describes the outcome of a measurement"""

OUTCOME_UNSPECIFIED: Outcome.ValueType  # 0
"""No outcome was specified."""
OUTCOME_PASSED: Outcome.ValueType  # 1
"""The measurement passed."""
OUTCOME_FAILED: Outcome.ValueType  # 2
"""The measurement failed."""
OUTCOME_INDETERMINATE: Outcome.ValueType  # 3
"""The outcome is indeterminate."""
global___Outcome = Outcome

@typing.final
class PublishedCondition(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MONIKER_FIELD_NUMBER: builtins.int
    PUBLISHED_CONDITION_ID_FIELD_NUMBER: builtins.int
    CONDITION_NAME_FIELD_NUMBER: builtins.int
    CONDITION_TYPE_FIELD_NUMBER: builtins.int
    STEP_ID_FIELD_NUMBER: builtins.int
    TEST_RESULT_ID_FIELD_NUMBER: builtins.int
    published_condition_id: builtins.str
    """The unique identifier of the condition. This can be used
    to reference and find the condition in the data store.
    """
    condition_name: builtins.str
    """The name of the condition."""
    condition_type: builtins.str
    """The type of the condition. For example, "Setup" or "Environment"."""
    step_id: builtins.str
    """The id of the step with which this condition is associated."""
    test_result_id: builtins.str
    """The id of the test result with which this condition is associated."""
    @property
    def moniker(self) -> ni.datamonikers.v1.data_moniker_pb2.Moniker:
        """The moniker of the condition that this value is associated with.
        This moniker returns a ni.measurements.data.v1.ScalarArray
        """

    def __init__(
        self,
        *,
        moniker: ni.datamonikers.v1.data_moniker_pb2.Moniker | None = ...,
        published_condition_id: builtins.str = ...,
        condition_name: builtins.str = ...,
        condition_type: builtins.str = ...,
        step_id: builtins.str = ...,
        test_result_id: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["moniker", b"moniker"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["condition_name", b"condition_name", "condition_type", b"condition_type", "moniker", b"moniker", "published_condition_id", b"published_condition_id", "step_id", b"step_id", "test_result_id", b"test_result_id"]) -> None: ...

global___PublishedCondition = PublishedCondition

@typing.final
class PublishedMeasurement(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MONIKER_FIELD_NUMBER: builtins.int
    PUBLISHED_CONDITIONS_FIELD_NUMBER: builtins.int
    PUBLISHED_MEASUREMENT_ID_FIELD_NUMBER: builtins.int
    TEST_RESULT_ID_FIELD_NUMBER: builtins.int
    STEP_ID_FIELD_NUMBER: builtins.int
    SOFTWARE_ITEM_IDS_FIELD_NUMBER: builtins.int
    HARDWARE_ITEM_IDS_FIELD_NUMBER: builtins.int
    TEST_ADAPTER_IDS_FIELD_NUMBER: builtins.int
    MEASUREMENT_NAME_FIELD_NUMBER: builtins.int
    DATA_TYPE_FIELD_NUMBER: builtins.int
    MEASUREMENT_NOTES_FIELD_NUMBER: builtins.int
    START_DATE_TIME_FIELD_NUMBER: builtins.int
    END_DATE_TIME_FIELD_NUMBER: builtins.int
    OUTCOME_FIELD_NUMBER: builtins.int
    PARAMETRIC_INDEX_FIELD_NUMBER: builtins.int
    ERROR_INFORMATION_FIELD_NUMBER: builtins.int
    published_measurement_id: builtins.str
    """The id of the measurement."""
    test_result_id: builtins.str
    """The id of the test result with which this measurement is associated."""
    step_id: builtins.str
    """The id of the step with which this measurement is associated."""
    measurement_name: builtins.str
    """The name used to group measurements across multiple publishes."""
    data_type: builtins.str
    """The type of the measurement. This is used to filter measurements in queries."""
    measurement_notes: builtins.str
    """Any notes about the measurement."""
    outcome: global___Outcome.ValueType
    """The most 'significant' outcome that was observed when publishing to this measurement.
    Significance hierarchy: Unspecified (default) < Passed < Indeterminate < Failed
    """
    parametric_index: builtins.int
    """The index within a parametric set, or -1 if this represents the entire set."""
    @property
    def moniker(self) -> ni.datamonikers.v1.data_moniker_pb2.Moniker:
        """The moniker providing access to measurement data.
        Scalar measurements are returned as Vectors; other types are returned as published.
        """

    @property
    def published_conditions(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___PublishedCondition]:
        """The conditions associated with the test step that owns this measurement."""

    @property
    def software_item_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """The ids of the software items with which this measurement is associated."""

    @property
    def hardware_item_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """The ids of the hardware items with which this measurement is associated."""

    @property
    def test_adapter_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """The ids of the test adapters with which this measurement is associated."""

    @property
    def start_date_time(self) -> ni.protobuf.types.precision_timestamp_pb2.PrecisionTimestamp:
        """The date and time at which the measurement was first published. If the measurement represents a parametric set,
        this is the timestamp of the first measurement published to the parametric set.
        """

    @property
    def end_date_time(self) -> ni.protobuf.types.precision_timestamp_pb2.PrecisionTimestamp:
        """The date and time at which the measurement was last published. If the measurement represents a parametric set,
        this is the timestamp of the last measurement published to the parametric set.
        """

    @property
    def error_information(self) -> global___ErrorInformation:
        """Error or exception information in JSON format"""

    def __init__(
        self,
        *,
        moniker: ni.datamonikers.v1.data_moniker_pb2.Moniker | None = ...,
        published_conditions: collections.abc.Iterable[global___PublishedCondition] | None = ...,
        published_measurement_id: builtins.str = ...,
        test_result_id: builtins.str = ...,
        step_id: builtins.str = ...,
        software_item_ids: collections.abc.Iterable[builtins.str] | None = ...,
        hardware_item_ids: collections.abc.Iterable[builtins.str] | None = ...,
        test_adapter_ids: collections.abc.Iterable[builtins.str] | None = ...,
        measurement_name: builtins.str = ...,
        data_type: builtins.str = ...,
        measurement_notes: builtins.str = ...,
        start_date_time: ni.protobuf.types.precision_timestamp_pb2.PrecisionTimestamp | None = ...,
        end_date_time: ni.protobuf.types.precision_timestamp_pb2.PrecisionTimestamp | None = ...,
        outcome: global___Outcome.ValueType = ...,
        parametric_index: builtins.int = ...,
        error_information: global___ErrorInformation | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["end_date_time", b"end_date_time", "error_information", b"error_information", "moniker", b"moniker", "start_date_time", b"start_date_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["data_type", b"data_type", "end_date_time", b"end_date_time", "error_information", b"error_information", "hardware_item_ids", b"hardware_item_ids", "measurement_name", b"measurement_name", "measurement_notes", b"measurement_notes", "moniker", b"moniker", "outcome", b"outcome", "parametric_index", b"parametric_index", "published_conditions", b"published_conditions", "published_measurement_id", b"published_measurement_id", "software_item_ids", b"software_item_ids", "start_date_time", b"start_date_time", "step_id", b"step_id", "test_adapter_ids", b"test_adapter_ids", "test_result_id", b"test_result_id"]) -> None: ...

global___PublishedMeasurement = PublishedMeasurement

@typing.final
class TestResult(google.protobuf.message.Message):
    """The information about the test result with which a test step is associated."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class ExtensionsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> ni.measurements.metadata.v1.metadata_store_pb2.ExtensionValue: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: ni.measurements.metadata.v1.metadata_store_pb2.ExtensionValue | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None: ...

    TEST_RESULT_ID_FIELD_NUMBER: builtins.int
    UUT_INSTANCE_ID_FIELD_NUMBER: builtins.int
    OPERATOR_ID_FIELD_NUMBER: builtins.int
    TEST_STATION_ID_FIELD_NUMBER: builtins.int
    TEST_DESCRIPTION_ID_FIELD_NUMBER: builtins.int
    SOFTWARE_ITEM_IDS_FIELD_NUMBER: builtins.int
    HARDWARE_ITEM_IDS_FIELD_NUMBER: builtins.int
    TEST_ADAPTER_IDS_FIELD_NUMBER: builtins.int
    TEST_RESULT_NAME_FIELD_NUMBER: builtins.int
    START_DATE_TIME_FIELD_NUMBER: builtins.int
    END_DATE_TIME_FIELD_NUMBER: builtins.int
    OUTCOME_FIELD_NUMBER: builtins.int
    LINK_FIELD_NUMBER: builtins.int
    EXTENSIONS_FIELD_NUMBER: builtins.int
    SCHEMA_ID_FIELD_NUMBER: builtins.int
    test_result_id: builtins.str
    """Optional.
    If you specify an id, the value is expected to be a parsable GUID.
    If you do not specify an id, one will be generated for you, and
    returned in the response.
    """
    uut_instance_id: builtins.str
    """Optional. The id of the UUT instance associated with this test result.
    This value is expected to be a parsable GUID or an alias. It will always
    be returned from the service as a GUID.
    See ni.measurements.metadata.MetadataStoreService for more information.
    """
    operator_id: builtins.str
    """Optional. The id of the operator associated with this test result.
    This value is expected to be a parsable GUID or an alias. It will always
    be returned from the service as a GUID.
    See ni.measurements.metadata.MetadataStoreService for more information.
    """
    test_station_id: builtins.str
    """Optional. The id of the test station associated with this test result.
    This value is expected to be a parsable GUID or an alias. It will always
    be returned from the service as a GUID.
    See ni.measurements.metadata.MetadataStoreService for more information.
    """
    test_description_id: builtins.str
    """Optional. The id of the test description associated with this test result.
    This value is expected to be a parsable GUID or an alias. It will always
    be returned from the service as a GUID.
    See ni.measurements.metadata.MetadataStoreService for more information.
    """
    test_result_name: builtins.str
    """Optional.
    The name of the test result.  This value should only contain letters,
    numbers, spaces, hyphens, underscores, parentheses, periods and
    spaces. It must begin and end with a letter or number.
    Expected format: ^[\\w\\(\\)-]([\\w.\\(\\) -]*[\\w\\(\\)-])?$
    """
    outcome: global___Outcome.ValueType
    """Optional. Overall test result outcome (e.g., Passed, Failed, Indeterminate)"""
    link: builtins.str
    """Optional. A link to a resource that describes the test result.
    This value is expected to be a valid URI.
    """
    schema_id: builtins.str
    """Optional.  If any of your messages contain 'extension', you must register
    a schema, and specify the schema id here.  In that case, all metadata will
    be validated against the specified schema.
    """
    @property
    def software_item_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """Optional. The ids of the software item associated with this test result. These values are expected
        to be parsable GUIDs or aliases. They will always be returned from the service as GUIDs.
        """

    @property
    def hardware_item_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """Optional. The ids of the hardware item associated with this test result. These values are expected
        to be parsable GUIDs or aliases. They will always be returned from the service as GUIDs.
        """

    @property
    def test_adapter_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """Optional. The ids of the test adapters associated with this test result. These values are expected
        to be parsable GUIDs or aliases. They will always be returned from the service as GUIDs.
        """

    @property
    def start_date_time(self) -> ni.protobuf.types.precision_timestamp_pb2.PrecisionTimestamp:
        """Optional. Start date and time of the test execution (timestamp)"""

    @property
    def end_date_time(self) -> ni.protobuf.types.precision_timestamp_pb2.PrecisionTimestamp:
        """Optional. End date and time of the test execution (timestamp)"""

    @property
    def extensions(self) -> google.protobuf.internal.containers.MessageMap[builtins.str, ni.measurements.metadata.v1.metadata_store_pb2.ExtensionValue]:
        """Optional. Any extensions to be associated with the test result."""

    def __init__(
        self,
        *,
        test_result_id: builtins.str = ...,
        uut_instance_id: builtins.str = ...,
        operator_id: builtins.str = ...,
        test_station_id: builtins.str = ...,
        test_description_id: builtins.str = ...,
        software_item_ids: collections.abc.Iterable[builtins.str] | None = ...,
        hardware_item_ids: collections.abc.Iterable[builtins.str] | None = ...,
        test_adapter_ids: collections.abc.Iterable[builtins.str] | None = ...,
        test_result_name: builtins.str = ...,
        start_date_time: ni.protobuf.types.precision_timestamp_pb2.PrecisionTimestamp | None = ...,
        end_date_time: ni.protobuf.types.precision_timestamp_pb2.PrecisionTimestamp | None = ...,
        outcome: global___Outcome.ValueType = ...,
        link: builtins.str = ...,
        extensions: collections.abc.Mapping[builtins.str, ni.measurements.metadata.v1.metadata_store_pb2.ExtensionValue] | None = ...,
        schema_id: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["end_date_time", b"end_date_time", "start_date_time", b"start_date_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["end_date_time", b"end_date_time", "extensions", b"extensions", "hardware_item_ids", b"hardware_item_ids", "link", b"link", "operator_id", b"operator_id", "outcome", b"outcome", "schema_id", b"schema_id", "software_item_ids", b"software_item_ids", "start_date_time", b"start_date_time", "test_adapter_ids", b"test_adapter_ids", "test_description_id", b"test_description_id", "test_result_id", b"test_result_id", "test_result_name", b"test_result_name", "test_station_id", b"test_station_id", "uut_instance_id", b"uut_instance_id"]) -> None: ...

global___TestResult = TestResult

@typing.final
class Step(google.protobuf.message.Message):
    """Represents the metadata of the step that was taken"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class ExtensionsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> ni.measurements.metadata.v1.metadata_store_pb2.ExtensionValue: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: ni.measurements.metadata.v1.metadata_store_pb2.ExtensionValue | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None: ...

    STEP_ID_FIELD_NUMBER: builtins.int
    PARENT_STEP_ID_FIELD_NUMBER: builtins.int
    TEST_RESULT_ID_FIELD_NUMBER: builtins.int
    TEST_ID_FIELD_NUMBER: builtins.int
    STEP_NAME_FIELD_NUMBER: builtins.int
    STEP_TYPE_FIELD_NUMBER: builtins.int
    NOTES_FIELD_NUMBER: builtins.int
    START_DATE_TIME_FIELD_NUMBER: builtins.int
    END_DATE_TIME_FIELD_NUMBER: builtins.int
    LINK_FIELD_NUMBER: builtins.int
    EXTENSIONS_FIELD_NUMBER: builtins.int
    SCHEMA_ID_FIELD_NUMBER: builtins.int
    step_id: builtins.str
    """The unique identifier of the step
    This value should be a string representation of a UUID.
    """
    parent_step_id: builtins.str
    """The parent step identifier"""
    test_result_id: builtins.str
    """Optional.
    The id of the test result associated with this test step.
    If not specified, a test result will be created from the
    information that can be implicitly obtained.
    """
    test_id: builtins.str
    """Optional. The id of the test associated with this test step.
    This value is expected to be a parsable GUID or an alias. It will always
    be returned from the service as a GUID.
    See ni.measurements.metadata.MetadataStoreService for more information.
    """
    step_name: builtins.str
    """Required. The name of the step."""
    step_type: builtins.str
    """Step type (e.g., Setup, Action, Measurement, Cleanup)"""
    notes: builtins.str
    """Any notes about the step"""
    link: builtins.str
    """A link to a resource that describes the step.
    This value is expected to be a valid URI.
    """
    schema_id: builtins.str
    """The unique identifier of the schema that applies to this instance's extension.
    If any extension is associated with this instance, a schema_id must be provided, unless
    the test step is created within the context of a test result, in which case
    the test result must have a schema_id.
    """
    @property
    def start_date_time(self) -> ni.protobuf.types.precision_timestamp_pb2.PrecisionTimestamp:
        """Start date and time of the test step (timestamp)"""

    @property
    def end_date_time(self) -> ni.protobuf.types.precision_timestamp_pb2.PrecisionTimestamp:
        """End date and time of the test step (timestamp)"""

    @property
    def extensions(self) -> google.protobuf.internal.containers.MessageMap[builtins.str, ni.measurements.metadata.v1.metadata_store_pb2.ExtensionValue]:
        """Any extensions to be associated with the test step"""

    def __init__(
        self,
        *,
        step_id: builtins.str = ...,
        parent_step_id: builtins.str = ...,
        test_result_id: builtins.str = ...,
        test_id: builtins.str = ...,
        step_name: builtins.str = ...,
        step_type: builtins.str = ...,
        notes: builtins.str = ...,
        start_date_time: ni.protobuf.types.precision_timestamp_pb2.PrecisionTimestamp | None = ...,
        end_date_time: ni.protobuf.types.precision_timestamp_pb2.PrecisionTimestamp | None = ...,
        link: builtins.str = ...,
        extensions: collections.abc.Mapping[builtins.str, ni.measurements.metadata.v1.metadata_store_pb2.ExtensionValue] | None = ...,
        schema_id: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["end_date_time", b"end_date_time", "start_date_time", b"start_date_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["end_date_time", b"end_date_time", "extensions", b"extensions", "link", b"link", "notes", b"notes", "parent_step_id", b"parent_step_id", "schema_id", b"schema_id", "start_date_time", b"start_date_time", "step_id", b"step_id", "step_name", b"step_name", "step_type", b"step_type", "test_id", b"test_id", "test_result_id", b"test_result_id"]) -> None: ...

global___Step = Step

@typing.final
class ErrorInformation(google.protobuf.message.Message):
    """Represents an error message resulting from a failed operation"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ERROR_CODE_FIELD_NUMBER: builtins.int
    MESSAGE_FIELD_NUMBER: builtins.int
    SOURCE_FIELD_NUMBER: builtins.int
    error_code: builtins.int
    """The error code associated with the error"""
    message: builtins.str
    """The error message associated with the error"""
    source: builtins.str
    """Information about the source of the error."""
    def __init__(
        self,
        *,
        error_code: builtins.int = ...,
        message: builtins.str = ...,
        source: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["error_code", b"error_code", "message", b"message", "source", b"source"]) -> None: ...

global___ErrorInformation = ErrorInformation
