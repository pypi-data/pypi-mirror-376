llm:
  unmask_prompt:
    task_context: "You are a text completion expert. Complete the given text by filling in ALL {mask_count} blank(s) (___)."
    background_data:
      context: "Focus on generating completions related to following context: {context}"
      candidates: "Consider the following candidate words: {candidates}. Pick from these if they fit well and sort them by relevance (descending)."
    rules: |
      Generate exactly {n_completions} unique, diverse sets of completions that fit the context well and relate to the specified topic. Each completion should be either:
      1) A single word (e.g., "performance", "strategy", "goal")
      2) A possessive noun phrase (e.g., "goalkeeper's performance", "team's strategy", "player's goal")
      3) If you are given a list of candidates, you must select from them and sort by relevance (descending).

      Avoid longer phrases like "museum that I visited" or "beautiful sunset today".
    task: "Text to complete: {text}"
    thinking_step: "Consider the context before you respond. If candidates are provided, consider them one by one and select the most relevant."
    output_format: |
      Provide each set as a list with {mask_count} item(s) in order. Examples:
      - For 1 mask: [["performance"], ["strategy"], ["goal"]]
      - For 2 masks: [["game", "it"], ["performance", "food"], ["movie", "service"]]

  paraphrase_prompt:
    task_context: "You are a paraphrasing expert. Generate paraphrases of the given text."
    tone_context: "Style your paraphrases to match the following style: {style}."
    background_data: "Focus on paraphrasing text related to: {context}. Try to use terminology and phrasing common in this domain."
    rules: |
      Generate exactly {n_paraphrases} unique paraphrases that preserve the original meaning while using different words and sentence structures.
      Each paraphrase should be:
      - Each paraphrase must preserve the original meaning
      - Use different vocabulary and sentence structures
      - Preserve context and domain relevance
      - Make each paraphrase unique and natural
      - {length_instruction}
    task: "Text to paraphrase: {text}"
    thinking_step: "Consider synonyms, sentence restructuring, and varying lengths before you respond."
    output_format: |
      Provide the paraphrases as a list. Example:
      ["Paraphrase 1", "Paraphrase 2", "Paraphrase 3"]

  negation_prompt:
    task_context: "You are a negation expert. Transform sentences to express their opposite meaning while maintaining grammatical correctness and naturalness."
    background_data:
      context: "Focus on negating sentences in the context of: {context}"
      preserve_style: "Maintain the original style and formality level of the text."
    rules: |
      Generate exactly {n_variations} negated version(s) that:
      - Express the opposite meaning of the original sentence
      - Are grammatically correct and natural-sounding
      - Preserve the original style and formality level
      - Use appropriate negation words (not, never, no, don't, can't, etc.)
      - Maintain the sentence structure when possible
    task: "Original sentence to negate: {text}"
    thinking_step: "Consider the main meaning of the sentence and how to express its opposite while keeping it natural and grammatically correct."
    output_format: |
      Provide the negated sentences as a list. Example:
      ["Negated sentence 1", "Negated sentence 2", "Negated sentence 3"]

  entity_detection_prompt:
    task_context: "You are an entity detector. Identify if a text contains specific types of entities."
    background_data:
      context: "Focus on detecting entities in the context of: {context}"
    rules: |
      Rules:
      1. Only identify entities that clearly belong to the specified type
      2. List entities exactly as they appear in the text
      3. If no entities found, return empty list
      4. Be precise - don't include partial matches or ambiguous cases
    task: |
      Analyze this text for entities of type: {entity_type}

      Text: "{text}"

      Task: List ALL entities of type "{entity_type}" found in the text.
    thinking_step: "Consider each word/phrase in the text and determine if it belongs to the specified entity type."
    output_format: |
      Respond with JSON in this exact format:
      {{
        "contains_entities": true,
        "entities": ["entity1", "entity2"]
      }}
