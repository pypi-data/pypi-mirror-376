"""Common classes module."""

import abc
import collections.abc
import os
import time
from typing import Any
from typing import Callable
from typing import List
from typing import Optional
from typing import Sequence
from typing import TYPE_CHECKING
from typing import Union

import tabulate

from driverlessai import _core
from driverlessai import _enums
from driverlessai import _utils

if TYPE_CHECKING:
    import fsspec  # noqa F401


class ServerObject(abc.ABC):
    """An entity in the Driverless AI server."""

    def __init__(self, client: "_core.Client", key: Optional[str] = None) -> None:
        self._client = client
        self._key = key
        self._name: Optional[str] = None
        self._raw_info: Any = None

    @property
    def key(self) -> str:
        """Universally unique key of the entity."""
        if not self._key:
            raise RuntimeError(
                "The Driverless AI server does not provide a universally "
                "unique identifier for this object type."
            )
        return self._key

    @property
    def name(self) -> str:
        """Name of the entity."""
        if not self._name:
            self._update()
        return self._name

    def _get_raw_info(self) -> Any:
        """Returns an undefined object that contains all entity information
        generated by the Driverless AI server. The returned object usually has
        the method `dump()` to convert it to a dictionary.
        """
        if not self._raw_info:
            self._update()
        return self._raw_info

    def _set_name(self, name: str) -> None:
        """Use when name is cached before initialization."""
        self._name = name

    def _set_raw_info(self, info: Any) -> None:
        """To be used by `_update()` method."""
        self._raw_info = info

    @abc.abstractmethod
    def _update(self) -> None:
        """Updates the object's raw info, name, and properties."""
        raise NotImplementedError


class ServerJob(ServerObject):
    """Monitor the creation of an entity in the Driverless AI server."""

    def __init__(self, client: "_core.Client", key: str) -> None:
        super().__init__(client=client, key=key)

    def is_complete(self) -> bool:
        """
        Whether the job has been completed successfully.

        Returns:
            `True` if the job has been completed successfully, otherwise `False`.
        """
        return is_server_job_complete(self._status())

    def is_running(self) -> bool:
        """
        Whether the job has been scheduled or is running,
        finishing, or syncing.

        Returns:
            `True` if the job has not completed yet, otherwise `False`.
        """
        return is_server_job_running(self._status())

    def _status(self) -> _enums.JobStatus:
        self._update()
        return _enums.JobStatus(self._get_raw_info().status)

    def _wait(self, silent: bool = False) -> None:
        status_update = _utils.StatusUpdate()
        while self.is_running():
            time.sleep(1)
            if not silent:
                status_update.display(self.status(verbose=2))
        if not silent:
            status_update.display(self.status(verbose=2))
        status_update.end()
        if not self.is_complete():
            raise RuntimeError(
                self._client._backend._format_server_error(
                    message=self._get_raw_info().error
                )
            )

    @abc.abstractmethod
    def result(self, silent: bool = False) -> Any:
        """
        Awaits the job's completion before returning the created entity.

        Args:
            silent: Whether to display status updates or not.

        Returns:
            Created entity by the job.
        """
        raise NotImplementedError

    def status(self, verbose: int = 0) -> str:
        """
        Returns the status of the job.

        Args:
            verbose:
                - 0: A short description.
                - 1: A short description with a progress percentage.
                - 2: A detailed description with a progress percentage.

        Returns:
            Current status of the job.
        """
        status = self._status()
        progress = self._get_raw_info().progress
        # server doesn't always show 100% complete
        if self.is_complete():
            progress = 1
        if verbose == 1:
            return f"{status.message} {progress:.2%}"
        if verbose == 2:
            if status == _enums.JobStatus.FAILED:
                message = self._get_raw_info().error
            elif self._get_raw_info().message:
                message = self._get_raw_info().message.split("\n")[0]
            else:
                message = ""
            return f"{status.message} {progress:.2%} - {message}"
        return status.message


class ArtifactExportJob(ServerJob):
    """Monitor exporting an artifact in the Driverless AI server."""

    def __init__(
        self,
        client: "_core.Client",
        key: str,
        artifact_path: str,
        artifact_file_name: str,
        export_location: str,
    ) -> None:
        # super() calls _update() which relies on artifact_path
        self._artifact_path = artifact_path
        super().__init__(client=client, key=key)
        self._artifact_file_name = artifact_file_name
        self._export_location = export_location

    @property
    def artifact_path(self) -> str:
        """Path to exporting artifact in Driverless AI server."""
        return self._artifact_path

    @property
    def artifact_file_name(self) -> str:
        """Name of artifact file."""
        return self._artifact_file_name

    @property
    def export_location(self) -> str:
        """Location that the artifact is exported to."""
        return self._export_location

    def _update(self) -> None:
        self._set_raw_info(
            self._client._backend.get_artifact_upload_job(
                key=self.key, artifact_path=self.artifact_path
            )
        )

    def result(self, silent: bool = False) -> None:
        """
        Awaits the job's completion.

        Args:
            silent: Whether to display status updates or not.
        """
        self._wait(silent)

    def status(self, verbose: int = None) -> str:
        """
        Returns the status of the job.

        Args:
            verbose: Ignored.

        Returns:
            Current status of the job.
        """
        status = self._status()
        if status == _enums.JobStatus.FAILED:
            message = f" - {self._get_raw_info().error}"
        else:
            message = f" - Export {self.artifact_file_name} to {self.export_location}"
        return f"{status.message}{message}"


class ServerJobs:
    """Monitor multiple jobs in the Driverless AI server."""

    def __init__(self, client: "_core.Client", jobs: Sequence[ServerJob]) -> None:
        self._client = client
        self._jobs = jobs

    @property
    def jobs(self) -> Sequence[ServerJob]:
        """Monitoring jobs."""
        return self._jobs

    def is_complete(self) -> bool:
        """
        Whether all jobs have been completed successfully.

        Returns:
            `True` if all jobs have been completed successfully, otherwise `False`.
        """
        for job in self.jobs:
            if not job.is_complete():
                return False
        return True

    def is_running(self) -> bool:
        """
        Whether one or more jobs have been scheduled or is running,
        finishing, or syncing.

        Returns:
            `True` if one or more jobs have not completed yet, otherwise `False`.
        """
        for job in self.jobs:
            if job.is_running():
                return True
        return False

    def result(self, silent: bool = False) -> Any:
        """
        Awaits completion of all jobs.

        Args:
            silent: Whether to display status updates or not.
        """
        return [job.result(silent) for job in self.jobs]

    def status(self, verbose: int = 0) -> List[str]:
        """
        Returns the statuses of all jobs.

        Args:
            verbose:
                - 0: A short description.
                - 1: A short description with a progress percentage.
                - 2: A detailed description with a progress percentage.

        Returns:
            Current statuses of all jobs.
        """
        return [job.status(verbose) for job in self.jobs]


class StorageImportJob(ServerJob):
    """Monitor importing an entity from H2O Storage."""

    def __init__(self, client: "_core.Client", key: str) -> None:
        super().__init__(client=client, key=key)

    def _update(self) -> None:
        self._set_raw_info(
            self._client._backend.get_import_entity_job(key=self.key).status
        )

    def result(self, silent: bool = True) -> "StorageImportJob":
        """
        Awaits the job's completion.

        Args:
            silent: Whether to display status updates or not.

        Returns:
            This job.
        """
        self._wait(silent=silent)
        return self


class ServerLog:
    """A log in the Driverless AI server."""

    def __init__(self, client: "_core.Client", file_path: str) -> None:
        self._client = client
        self._file_name = os.path.basename(file_path)
        self._file_path = file_path

    # Do we need to deprecate and add again ?
    @property
    def file_name(self) -> str:
        """Filename of the log file."""
        return self._file_name

    def _download(
        self,
        server_path: str = "",
        dst_dir: str = ".",
        dst_file: Optional[str] = None,
        file_system: Optional["fsspec.spec.AbstractFileSystem"] = None,
        overwrite: bool = False,
        timeout: float = 30,
        download_type: _enums.DownloadType = _enums.DownloadType.FILES,
    ) -> str:
        """
        Download logs from the Driverless AI server.

        Args:
            server_path: The path of the downloaded file inside the server.
            dst_dir: The path to the directory where the downloaded file will be saved.
            dst_file: The name of the log file (overrides default file name).
            file_system: FSSPEC based file system to download to,
                instead of local file system
            overwrite: Overwrite the existing file.
            timeout: Connection timeout in seconds.
            download_type: The download type,
                whether to choose from a file, dataset, or log
        """
        if len(server_path) == 0:
            server_path = self._file_path
        return self._client._download(
            server_path=server_path,
            dst_dir=dst_dir,
            dst_file=dst_file,
            file_system=file_system,
            overwrite=overwrite,
            timeout=timeout,
            download_type=download_type,
        )

    def head(self, num_lines: int = 50) -> str:
        """
        Returns the first `n` lines of the log file.

        Args:
            num_lines: Number of lines to retrieve.
        """
        res = self._client._get_response(server_path=self._file_path, stream=True)
        lines = []
        for i, line in enumerate(res.iter_lines(decode_unicode=True)):
            if i >= num_lines:
                break
            lines.append(line.decode("utf-8") if hasattr(line, "decode") else line)
        return "\n".join(lines)

    def tail(self, num_lines: int = 50) -> str:
        """
        Returns the last `n` lines of the log file.

        Args:
            num_lines: Number of lines to retrieve.
        """
        res = self._client._get_response(server_path=self._file_path, stream=True)
        lines = []
        for line in res.iter_lines(decode_unicode=True):
            lines.append(line.decode("utf-8") if hasattr(line, "decode") else line)
            if len(lines) > num_lines:
                lines.pop(0)
        return "\n".join(lines)


class ServerObjectList(collections.abc.Sequence):
    """A lazily loaded list of entities in Driverless AI server."""

    def __init__(self, data: Any, get_method: Optional[Callable], item_class_name: str):
        self._data = data
        self._get = get_method
        self._item_class_name = item_class_name

    def __getitem__(self, index: Union[int, slice, tuple]) -> Any:
        if isinstance(index, int):
            if not hasattr(self._data[index], "_client") and self._get is not None:
                item = self._get(self._data[index].key)
                item._set_name(
                    getattr(self._data[index], "name", "")
                    or getattr(self._data[index], "description", "")
                )
                self._data.__setitem__(index, item)
            return self._data[index]
        if isinstance(index, slice):
            return ServerObjectList(self._data[index], self._get, self._item_class_name)
        if isinstance(index, tuple):
            return ServerObjectList(
                [self._data[i] for i in index], self._get, self._item_class_name
            )

    def __len__(self) -> int:
        return len(self._data)

    def __repr__(self) -> str:
        headers = ["", "Type", "Key", "Name"]
        if self._get is None:
            table = [
                [
                    i,
                    self._item_class_name,
                    None,
                    f"{getattr(d, 'name', '') or getattr(d, 'description', '')}",
                ]
                for i, d in enumerate(self._data)
            ]
        else:
            table = [
                [
                    i,
                    self._item_class_name,
                    d.key,
                    f"{getattr(d, 'name', '') or getattr(d, 'description', '')}",
                ]
                for i, d in enumerate(self._data)
            ]
        return tabulate.tabulate(table, headers=headers, tablefmt="presto")


def is_server_job_complete(server_job_status: Union[int, _enums.JobStatus]) -> bool:
    return server_job_status == _enums.JobStatus.COMPLETE


def is_server_job_failed(server_job_status: Union[int, _enums.JobStatus]) -> bool:
    return server_job_status == _enums.JobStatus.FAILED


def is_server_job_running(server_job_status: Union[int, _enums.JobStatus]) -> bool:
    return server_job_status in [
        _enums.JobStatus.FINISHING,
        _enums.JobStatus.RUNNING,
        _enums.JobStatus.SCHEDULED,
        _enums.JobStatus.SYNCING,
    ]
