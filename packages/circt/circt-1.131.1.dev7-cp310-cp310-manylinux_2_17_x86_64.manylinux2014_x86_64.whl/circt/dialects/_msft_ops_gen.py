
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_result_or_op_results as _get_op_result_or_op_results,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "msft"

@_ods_cext.register_operation(_Dialect)
class DeclPhysicalRegionOp(_ods_ir.OpView):
  OPERATION_NAME = "msft.physical_region"

  _ODS_REGIONS = (0, True)

  def __init__(self, sym_name, bounds, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["bounds"] = (bounds if (
    isinstance(bounds, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('PhysicalBoundsArray')) else
      _ods_ir.AttrBuilder.get('PhysicalBoundsArray')(bounds, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self):
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def bounds(self):
    return self.operation.attributes["bounds"]

  @bounds.setter
  def bounds(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["bounds"] = value

def physical_region(sym_name, bounds, *, loc=None, ip=None) -> _ods_ir.Operation:
  return DeclPhysicalRegionOp(sym_name=sym_name, bounds=bounds, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DynamicInstanceOp(_ods_ir.OpView):
  OPERATION_NAME = "msft.instance.dynamic"

  _ODS_REGIONS = (1, True)

  def __init__(self, instanceRef, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["instanceRef"] = (instanceRef if (
    isinstance(instanceRef, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('InnerRefAttr')) else
      _ods_ir.AttrBuilder.get('InnerRefAttr')(instanceRef, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def instanceRef(self):
    return self.operation.attributes["instanceRef"]

  @instanceRef.setter
  def instanceRef(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["instanceRef"] = value

  @builtins.property
  def body(self):
    return self.regions[0]

def instance_dynamic(instance_ref, *, loc=None, ip=None) -> _ods_ir.Operation:
  return DynamicInstanceOp(instanceRef=instance_ref, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DynamicInstanceVerbatimAttrOp(_ods_ir.OpView):
  OPERATION_NAME = "msft.instance.verb_attr"

  _ODS_REGIONS = (0, True)

  def __init__(self, name, value, *, subPath=None, ref=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(value, context=_ods_context))
    if subPath is not None: attributes["subPath"] = (subPath if (
        isinstance(subPath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(subPath, context=_ods_context))
    if ref is not None: attributes["ref"] = (ref if (
        isinstance(ref, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
          _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(ref, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def name(self):
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

  @builtins.property
  def value(self):
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def subPath(self):
    if "subPath" not in self.operation.attributes:
      return None
    return self.operation.attributes["subPath"]

  @subPath.setter
  def subPath(self, value):
    if value is not None:
      self.operation.attributes["subPath"] = value
    elif "subPath" in self.operation.attributes:
      del self.operation.attributes["subPath"]

  @subPath.deleter
  def subPath(self):
    del self.operation.attributes["subPath"]

  @builtins.property
  def ref(self):
    if "ref" not in self.operation.attributes:
      return None
    return self.operation.attributes["ref"]

  @ref.setter
  def ref(self, value):
    if value is not None:
      self.operation.attributes["ref"] = value
    elif "ref" in self.operation.attributes:
      del self.operation.attributes["ref"]

  @ref.deleter
  def ref(self):
    del self.operation.attributes["ref"]

def instance_verb_attr(name, value, *, sub_path=None, ref=None, loc=None, ip=None) -> _ods_ir.Operation:
  return DynamicInstanceVerbatimAttrOp(name=name, value=value, subPath=sub_path, ref=ref, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class InstanceHierarchyOp(_ods_ir.OpView):
  OPERATION_NAME = "msft.instance.hierarchy"

  _ODS_REGIONS = (1, True)

  def __init__(self, topModuleRef, *, instName=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["topModuleRef"] = (topModuleRef if (
    isinstance(topModuleRef, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(topModuleRef, context=_ods_context))
    if instName is not None: attributes["instName"] = (instName if (
        isinstance(instName, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(instName, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def topModuleRef(self):
    return self.operation.attributes["topModuleRef"]

  @topModuleRef.setter
  def topModuleRef(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["topModuleRef"] = value

  @builtins.property
  def instName(self):
    if "instName" not in self.operation.attributes:
      return None
    return self.operation.attributes["instName"]

  @instName.setter
  def instName(self, value):
    if value is not None:
      self.operation.attributes["instName"] = value
    elif "instName" in self.operation.attributes:
      del self.operation.attributes["instName"]

  @instName.deleter
  def instName(self):
    del self.operation.attributes["instName"]

  @builtins.property
  def body(self):
    return self.regions[0]

def instance_hierarchy(top_module_ref, *, inst_name=None, loc=None, ip=None) -> _ods_ir.Operation:
  return InstanceHierarchyOp(topModuleRef=top_module_ref, instName=inst_name, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class LinearOp(_ods_ir.OpView):
  OPERATION_NAME = "msft.hlc.linear"

  _ODS_REGIONS = (1, True)

  def __init__(self, outs, clock, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(clock)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(outs)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def clock(self):
    return self.operation.operands[0]

  @builtins.property
  def outs(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def datapath(self):
    return self.regions[0]

def hlc_linear(outs, clock, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(LinearOp(outs=outs, clock=clock, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class OutputOp(_ods_ir.OpView):
  OPERATION_NAME = "msft.output"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def output(operands_, *, loc=None, ip=None) -> _ods_ir.Operation:
  return OutputOp(operands_=operands_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class PDMulticycleOp(_ods_ir.OpView):
  OPERATION_NAME = "msft.pd.multicycle"

  _ODS_REGIONS = (0, True)

  def __init__(self, source, dest, cycles, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["source"] = (source if (
    isinstance(source, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(source, context=_ods_context))
    attributes["dest"] = (dest if (
    isinstance(dest, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(dest, context=_ods_context))
    attributes["cycles"] = (cycles if (
    isinstance(cycles, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(cycles, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    return self.operation.attributes["source"]

  @source.setter
  def source(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["source"] = value

  @builtins.property
  def dest(self):
    return self.operation.attributes["dest"]

  @dest.setter
  def dest(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dest"] = value

  @builtins.property
  def cycles(self):
    return self.operation.attributes["cycles"]

  @cycles.setter
  def cycles(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["cycles"] = value

def pd_multicycle(source, dest, cycles, *, loc=None, ip=None) -> _ods_ir.Operation:
  return PDMulticycleOp(source=source, dest=dest, cycles=cycles, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class PDPhysLocationOp(_ods_ir.OpView):
  OPERATION_NAME = "msft.pd.location"

  _ODS_REGIONS = (0, True)

  def __init__(self, loc_, *, subPath=None, ref=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["loc"] = (loc_ if (
    isinstance(loc_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('PhysLocation')) else
      _ods_ir.AttrBuilder.get('PhysLocation')(loc_, context=_ods_context))
    if subPath is not None: attributes["subPath"] = (subPath if (
        isinstance(subPath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(subPath, context=_ods_context))
    if ref is not None: attributes["ref"] = (ref if (
        isinstance(ref, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
          _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(ref, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def loc_(self):
    return self.operation.attributes["loc"]

  @loc_.setter
  def loc_(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["loc"] = value

  @builtins.property
  def subPath(self):
    if "subPath" not in self.operation.attributes:
      return None
    return self.operation.attributes["subPath"]

  @subPath.setter
  def subPath(self, value):
    if value is not None:
      self.operation.attributes["subPath"] = value
    elif "subPath" in self.operation.attributes:
      del self.operation.attributes["subPath"]

  @subPath.deleter
  def subPath(self):
    del self.operation.attributes["subPath"]

  @builtins.property
  def ref(self):
    if "ref" not in self.operation.attributes:
      return None
    return self.operation.attributes["ref"]

  @ref.setter
  def ref(self, value):
    if value is not None:
      self.operation.attributes["ref"] = value
    elif "ref" in self.operation.attributes:
      del self.operation.attributes["ref"]

  @ref.deleter
  def ref(self):
    del self.operation.attributes["ref"]

def pd_location(loc_, *, sub_path=None, ref=None, loc=None, ip=None) -> _ods_ir.Operation:
  return PDPhysLocationOp(loc_=loc_, subPath=sub_path, ref=ref, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class PDPhysRegionOp(_ods_ir.OpView):
  OPERATION_NAME = "msft.pd.physregion"

  _ODS_REGIONS = (0, True)

  def __init__(self, physRegionRef, *, subPath=None, ref=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["physRegionRef"] = (physRegionRef if (
    isinstance(physRegionRef, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(physRegionRef, context=_ods_context))
    if subPath is not None: attributes["subPath"] = (subPath if (
        isinstance(subPath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(subPath, context=_ods_context))
    if ref is not None: attributes["ref"] = (ref if (
        isinstance(ref, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
          _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(ref, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def physRegionRef(self):
    return self.operation.attributes["physRegionRef"]

  @physRegionRef.setter
  def physRegionRef(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["physRegionRef"] = value

  @builtins.property
  def subPath(self):
    if "subPath" not in self.operation.attributes:
      return None
    return self.operation.attributes["subPath"]

  @subPath.setter
  def subPath(self, value):
    if value is not None:
      self.operation.attributes["subPath"] = value
    elif "subPath" in self.operation.attributes:
      del self.operation.attributes["subPath"]

  @subPath.deleter
  def subPath(self):
    del self.operation.attributes["subPath"]

  @builtins.property
  def ref(self):
    if "ref" not in self.operation.attributes:
      return None
    return self.operation.attributes["ref"]

  @ref.setter
  def ref(self, value):
    if value is not None:
      self.operation.attributes["ref"] = value
    elif "ref" in self.operation.attributes:
      del self.operation.attributes["ref"]

  @ref.deleter
  def ref(self):
    del self.operation.attributes["ref"]

def pd_physregion(phys_region_ref, *, sub_path=None, ref=None, loc=None, ip=None) -> _ods_ir.Operation:
  return PDPhysRegionOp(physRegionRef=phys_region_ref, subPath=sub_path, ref=ref, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class PDRegPhysLocationOp(_ods_ir.OpView):
  OPERATION_NAME = "msft.pd.reg_location"

  _ODS_REGIONS = (0, True)

  def __init__(self, locs, *, ref=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["locs"] = (locs if (
    isinstance(locs, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('LocationVector')) else
      _ods_ir.AttrBuilder.get('LocationVector')(locs, context=_ods_context))
    if ref is not None: attributes["ref"] = (ref if (
        isinstance(ref, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
          _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(ref, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def locs(self):
    return self.operation.attributes["locs"]

  @locs.setter
  def locs(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["locs"] = value

  @builtins.property
  def ref(self):
    if "ref" not in self.operation.attributes:
      return None
    return self.operation.attributes["ref"]

  @ref.setter
  def ref(self, value):
    if value is not None:
      self.operation.attributes["ref"] = value
    elif "ref" in self.operation.attributes:
      del self.operation.attributes["ref"]

  @ref.deleter
  def ref(self):
    del self.operation.attributes["ref"]

def pd_reg_location(locs, *, ref=None, loc=None, ip=None) -> _ods_ir.Operation:
  return PDRegPhysLocationOp(locs=locs, ref=ref, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class PEOutputOp(_ods_ir.OpView):
  OPERATION_NAME = "msft.pe.output"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(output)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def output(self):
    return self.operation.operands[0]

def pe_output(output, *, loc=None, ip=None) -> _ods_ir.Operation:
  return PEOutputOp(output=output, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SystolicArrayOp(_ods_ir.OpView):
  OPERATION_NAME = "msft.systolic.array"

  _ODS_REGIONS = (1, True)

  def __init__(self, peOutputs, rowInputs, colInputs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(rowInputs)
    operands.append(colInputs)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(peOutputs)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def rowInputs(self):
    return self.operation.operands[0]

  @builtins.property
  def colInputs(self):
    return self.operation.operands[1]

  @builtins.property
  def peOutputs(self):
    return self.operation.results[0]

  @builtins.property
  def pe(self):
    return self.regions[0]

def systolic_array(pe_outputs, row_inputs, col_inputs, *, loc=None, ip=None) -> _ods_ir.Value:
  return SystolicArrayOp(peOutputs=pe_outputs, rowInputs=row_inputs, colInputs=col_inputs, loc=loc, ip=ip).result
