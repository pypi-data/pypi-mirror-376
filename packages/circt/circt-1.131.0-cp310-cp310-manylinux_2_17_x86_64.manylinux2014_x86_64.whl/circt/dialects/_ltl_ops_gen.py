
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_result_or_op_results as _get_op_result_or_op_results,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "ltl"

@_ods_cext.register_operation(_Dialect)
class AndOp(_ods_ir.OpView):
  OPERATION_NAME = "ltl.and"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def and_(inputs, *, loc=None, ip=None) -> _ods_ir.Value:
  return AndOp(inputs=inputs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ClockOp(_ods_ir.OpView):
  OPERATION_NAME = "ltl.clock"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, edge, clock, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(clock)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["edge"] = (edge if (
    isinstance(edge, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ClockEdgeAttr')) else
      _ods_ir.AttrBuilder.get('ClockEdgeAttr')(edge, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def clock(self):
    return self.operation.operands[1]

  @builtins.property
  def edge(self):
    return self.operation.attributes["edge"]

  @edge.setter
  def edge(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["edge"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def clock(input, edge, clock, *, loc=None, ip=None) -> _ods_ir.Value:
  return ClockOp(input=input, edge=edge, clock=clock, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConcatOp(_ods_ir.OpView):
  OPERATION_NAME = "ltl.concat"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def concat(inputs, *, loc=None, ip=None) -> _ods_ir.Value:
  return ConcatOp(inputs=inputs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DelayOp(_ods_ir.OpView):
  OPERATION_NAME = "ltl.delay"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, delay, *, length=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["delay"] = (delay if (
    isinstance(delay, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(delay, context=_ods_context))
    if length is not None: attributes["length"] = (length if (
        isinstance(length, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(length, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def delay(self):
    return self.operation.attributes["delay"]

  @delay.setter
  def delay(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["delay"] = value

  @builtins.property
  def length(self):
    if "length" not in self.operation.attributes:
      return None
    return self.operation.attributes["length"]

  @length.setter
  def length(self, value):
    if value is not None:
      self.operation.attributes["length"] = value
    elif "length" in self.operation.attributes:
      del self.operation.attributes["length"]

  @length.deleter
  def length(self):
    del self.operation.attributes["length"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def delay(input, delay, *, length=None, loc=None, ip=None) -> _ods_ir.Value:
  return DelayOp(input=input, delay=delay, length=length, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class EventuallyOp(_ods_ir.OpView):
  OPERATION_NAME = "ltl.eventually"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def eventually(input, *, loc=None, ip=None) -> _ods_ir.Value:
  return EventuallyOp(input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GoToRepeatOp(_ods_ir.OpView):
  OPERATION_NAME = "ltl.goto_repeat"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, base, more, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["base"] = (base if (
    isinstance(base, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(base, context=_ods_context))
    attributes["more"] = (more if (
    isinstance(more, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(more, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def base(self):
    return self.operation.attributes["base"]

  @base.setter
  def base(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["base"] = value

  @builtins.property
  def more(self):
    return self.operation.attributes["more"]

  @more.setter
  def more(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["more"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def goto_repeat(input, base, more, *, loc=None, ip=None) -> _ods_ir.Value:
  return GoToRepeatOp(input=input, base=base, more=more, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ImplicationOp(_ods_ir.OpView):
  OPERATION_NAME = "ltl.implication"

  _ODS_REGIONS = (0, True)

  def __init__(self, antecedent, consequent, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(antecedent)
    operands.append(consequent)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def antecedent(self):
    return self.operation.operands[0]

  @builtins.property
  def consequent(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def implication(antecedent, consequent, *, loc=None, ip=None) -> _ods_ir.Value:
  return ImplicationOp(antecedent=antecedent, consequent=consequent, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IntersectOp(_ods_ir.OpView):
  OPERATION_NAME = "ltl.intersect"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def intersect(inputs, *, loc=None, ip=None) -> _ods_ir.Value:
  return IntersectOp(inputs=inputs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class NonConsecutiveRepeatOp(_ods_ir.OpView):
  OPERATION_NAME = "ltl.non_consecutive_repeat"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, base, more, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["base"] = (base if (
    isinstance(base, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(base, context=_ods_context))
    attributes["more"] = (more if (
    isinstance(more, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(more, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def base(self):
    return self.operation.attributes["base"]

  @base.setter
  def base(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["base"] = value

  @builtins.property
  def more(self):
    return self.operation.attributes["more"]

  @more.setter
  def more(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["more"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def non_consecutive_repeat(input, base, more, *, loc=None, ip=None) -> _ods_ir.Value:
  return NonConsecutiveRepeatOp(input=input, base=base, more=more, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class NotOp(_ods_ir.OpView):
  OPERATION_NAME = "ltl.not"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def not_(input, *, loc=None, ip=None) -> _ods_ir.Value:
  return NotOp(input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class OrOp(_ods_ir.OpView):
  OPERATION_NAME = "ltl.or"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def or_(inputs, *, loc=None, ip=None) -> _ods_ir.Value:
  return OrOp(inputs=inputs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RepeatOp(_ods_ir.OpView):
  OPERATION_NAME = "ltl.repeat"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, base, *, more=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["base"] = (base if (
    isinstance(base, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(base, context=_ods_context))
    if more is not None: attributes["more"] = (more if (
        isinstance(more, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(more, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def base(self):
    return self.operation.attributes["base"]

  @base.setter
  def base(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["base"] = value

  @builtins.property
  def more(self):
    if "more" not in self.operation.attributes:
      return None
    return self.operation.attributes["more"]

  @more.setter
  def more(self, value):
    if value is not None:
      self.operation.attributes["more"] = value
    elif "more" in self.operation.attributes:
      del self.operation.attributes["more"]

  @more.deleter
  def more(self):
    del self.operation.attributes["more"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def repeat(input, base, *, more=None, loc=None, ip=None) -> _ods_ir.Value:
  return RepeatOp(input=input, base=base, more=more, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UntilOp(_ods_ir.OpView):
  OPERATION_NAME = "ltl.until"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, condition, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(condition)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def condition(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def until(input, condition, *, loc=None, ip=None) -> _ods_ir.Value:
  return UntilOp(input=input, condition=condition, loc=loc, ip=ip).result
