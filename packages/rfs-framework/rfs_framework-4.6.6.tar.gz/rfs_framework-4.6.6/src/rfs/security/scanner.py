"""
Security Scanner (RFS v4)

RFS v4 Î≥¥Ïïà Ï∑®ÏïΩÏ†ê Ïä§Ï∫êÎãù ÏãúÏä§ÌÖú
- ÏΩîÎìú Ï∑®ÏïΩÏ†ê Î∂ÑÏÑù
- ÏùòÏ°¥ÏÑ± Î≥¥Ïïà Í≤ÄÏÇ¨
- ÏÑ§Ï†ï Î≥¥Ïïà Ï†êÍ≤Ä
- ÎÑ§Ìä∏ÏõåÌÅ¨ Î≥¥Ïïà Í≤ÄÏ¶ù
"""

import ast
import asyncio
import hashlib
import json
import os
import re
import subprocess
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional, Set, Tuple

try:
    from rich.console import Console
    from rich.panel import Panel
    from rich.progress import BarColumn, Progress, SpinnerColumn, TextColumn
    from rich.table import Table
    from rich.tree import Tree

    RICH_AVAILABLE = True
except ImportError:
    RICH_AVAILABLE = False
from ..core.result import Failure, Result, Success

if RICH_AVAILABLE:
    console = Console()
else:
    console = None


class ThreatLevel(Enum):
    """ÏúÑÌòë ÏàòÏ§Ä"""

    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


class VulnerabilityType(Enum):
    """Ï∑®ÏïΩÏ†ê Ïú†Ìòï"""

    CODE_INJECTION = "code_injection"
    XSS = "xss"
    SQLI = "sql_injection"
    PATH_TRAVERSAL = "path_traversal"
    WEAK_CRYPTO = "weak_cryptography"
    INSECURE_CONFIG = "insecure_configuration"
    HARDCODED_SECRET = "hardcoded_secret"
    DEPENDENCY_VULN = "dependency_vulnerability"
    PERMISSION_ISSUE = "permission_issue"
    INFORMATION_LEAK = "information_leakage"


@dataclass
class VulnerabilityReport:
    """Ï∑®ÏïΩÏ†ê Î¶¨Ìè¨Ìä∏"""

    vuln_id: str
    vuln_type: VulnerabilityType
    threat_level: ThreatLevel
    title: str
    description: str
    file_path: Optional[str] = None
    line_number: Optional[int] = None
    code_snippet: Optional[str] = None
    cwe_id: Optional[str] = None
    cvss_score: Optional[float] = None
    remediation: List[str] = field(default_factory=list)
    references: List[str] = field(default_factory=list)
    confirmed: bool = False

    @property
    def risk_score(self) -> int:
        """ÏúÑÌóò Ï†êÏàò Í≥ÑÏÇ∞ (1-100)"""
        base_scores = {
            ThreatLevel.CRITICAL: 90,
            ThreatLevel.HIGH: 70,
            ThreatLevel.MEDIUM: 50,
            ThreatLevel.LOW: 30,
            ThreatLevel.INFO: 10,
        }
        score = base_scores.get(self.threat_level, 50)
        if self.cvss_score:
            score = int((score + self.cvss_score * 10) / 2)
        return min(100, max(1, score))


class SecurityScanner:
    """Î≥¥Ïïà Ïä§Ï∫êÎÑà Î©îÏù∏ ÌÅ¥ÎûòÏä§"""

    def __init__(self, project_path: Optional[str] = None):
        self.project_path = Path(project_path) if project_path else Path.cwd()
        self.vulnerabilities: List[VulnerabilityReport] = []
        self._load_security_patterns()

    def _load_security_patterns(self):
        """Î≥¥Ïïà Ìå®ÌÑ¥ Î°úÎìú"""
        self.dangerous_functions = {
            "eval",
            "exec",
            "compile",
            "__import__",
            "input",
            "raw_input",
            "file",
            "open",
            "subprocess.call",
            "subprocess.run",
            "os.system",
            "pickle.load",
            "pickle.loads",
            "yaml.load",
        }
        self.secret_patterns = [
            ("password\\s*=\\s*[\"\\'][^\"\\']{3,}[\"\\']", "hardcoded_password"),
            ("secret\\s*=\\s*[\"\\'][^\"\\']{10,}[\"\\']", "hardcoded_secret"),
            ("token\\s*=\\s*[\"\\'][^\"\\']{10,}[\"\\']", "hardcoded_token"),
            ("key\\s*=\\s*[\"\\'][^\"\\']{10,}[\"\\']", "hardcoded_key"),
            ("api_key\\s*=\\s*[\"\\'][^\"\\']{10,}[\"\\']", "hardcoded_api_key"),
            ("-----BEGIN [A-Z ]+-----", "embedded_certificate"),
            ("sk-[a-zA-Z0-9]{48}", "openai_api_key"),
            ("ghp_[a-zA-Z0-9]{36}", "github_token"),
            ("xoxb-[0-9]{13}-[0-9]{13}-[a-zA-Z0-9]{24}", "slack_token"),
        ]
        self.sqli_patterns = [
            "[\"\\'].*\\+.*[\"\\'].*WHERE",
            "cursor\\.execute\\s*\\(\\s*[\"\\'][^\"\\']*%[sf][^\"\\']*[\"\\']",
            "query\\s*=\\s*[\"\\'].*\\+.*[\"\\']",
            "SELECT.*FROM.*WHERE.*[\"\\'].*\\+.*[\"\\']",
        ]
        self.path_traversal_patterns = [
            "\\.\\./",
            "\\.\\.\\\\",
            "path.*\\+.*request",
            "filename.*request\\.",
            "os\\.path\\.join.*request\\.",
        ]

    async def run_security_scan(
        self, scan_types: Optional[List[str]] = None
    ) -> Result[List[VulnerabilityReport], str]:
        """Î≥¥Ïïà Ïä§Ï∫î Ïã§Ìñâ"""
        try:
            if console:
                console.print(
                    Panel(
                        f"üîí RFS v4 Î≥¥Ïïà Ïä§Ï∫î ÏãúÏûë\n\nüìÅ ÌîÑÎ°úÏ†ùÌä∏ Í≤ΩÎ°ú: {self.project_path}\nüîç Ïä§Ï∫î Ïú†Ìòï: {(', '.join(scan_types) if scan_types else 'Ï†ÑÏ≤¥ Ïä§Ï∫î')}\n‚è∞ ÏãúÏûë ÏãúÍ∞Ñ: {datetime.now().strftime('%H:%M:%S')}",
                        title="Î≥¥Ïïà Ïä§Ï∫î",
                        border_style="red",
                    )
                )
            self.vulnerabilities = []
            scan_tasks = []
            if not scan_types or "code" in scan_types:
                scan_tasks = scan_tasks + [
                    ("ÏΩîÎìú Ï∑®ÏïΩÏ†ê Î∂ÑÏÑù", self._scan_code_vulnerabilities)
                ]
            if not scan_types or "dependencies" in scan_types:
                scan_tasks = scan_tasks + [
                    ("ÏùòÏ°¥ÏÑ± Î≥¥Ïïà Í≤ÄÏÇ¨", self._scan_dependency_vulnerabilities)
                ]
            if not scan_types or "config" in scan_types:
                scan_tasks = scan_tasks + [
                    ("ÏÑ§Ï†ï Î≥¥Ïïà Ï†êÍ≤Ä", self._scan_configuration_security)
                ]
            if not scan_types or "files" in scan_types:
                scan_tasks = scan_tasks + [
                    ("ÌååÏùº Í∂åÌïú Í≤ÄÏÇ¨", self._scan_file_permissions)
                ]
            if not scan_types or "secrets" in scan_types:
                scan_tasks = scan_tasks + [
                    ("ÏãúÌÅ¨Î¶ø ÌÉêÏßÄ", self._scan_hardcoded_secrets)
                ]
            with Progress(
                SpinnerColumn(),
                TextColumn("[progress.description]{task.description}"),
                BarColumn(),
                console=console,
            ) as progress:
                for scan_name, scan_func in scan_tasks:
                    task = progress.add_task(f"{scan_name} Ï§ë...", total=100)
                    try:
                        vulnerabilities = await scan_func()
                        if vulnerabilities:
                            self.vulnerabilities = (
                                self.vulnerabilities + vulnerabilities
                            )
                    except Exception as e:
                        if console:
                            console.print(
                                f"‚ö†Ô∏è  {scan_name} Ïã§Ìå®: {str(e)}", style="yellow"
                            )
                    progress = {**progress, **task}
            self.vulnerabilities.sort(key=lambda v: v.risk_score, reverse=True)
            if console:
                await self._display_scan_results()
            return Success(self.vulnerabilities)
        except Exception as e:
            return Failure(f"Î≥¥Ïïà Ïä§Ï∫î Ïã§Ìå®: {str(e)}")

    async def _scan_code_vulnerabilities(self) -> List[VulnerabilityReport]:
        """ÏΩîÎìú Ï∑®ÏïΩÏ†ê Î∂ÑÏÑù"""
        vulnerabilities = []
        try:
            python_files = list(self.project_path.rglob("*.py"))
            for py_file in python_files:
                try:
                    content = py_file.read_text(encoding="utf-8")
                    try:
                        tree = ast.parse(content)
                        file_vulnerabilities = await self._analyze_ast_vulnerabilities(
                            tree, py_file, content
                        )
                        vulnerabilities = vulnerabilities + file_vulnerabilities
                    except SyntaxError:
                        continue
                    pattern_vulnerabilities = (
                        await self._analyze_pattern_vulnerabilities(py_file, content)
                    )
                    vulnerabilities = vulnerabilities + pattern_vulnerabilities
                except Exception as e:
                    if console:
                        console.print(
                            f"‚ö†Ô∏è  ÌååÏùº Î∂ÑÏÑù Ïã§Ìå® {py_file}: {str(e)}", style="yellow"
                        )
        except Exception as e:
            if console:
                console.print(f"‚ö†Ô∏è  ÏΩîÎìú Ï∑®ÏïΩÏ†ê Î∂ÑÏÑù Ïã§Ìå®: {str(e)}", style="yellow")
        return vulnerabilities

    async def _analyze_ast_vulnerabilities(
        self, tree: ast.AST, file_path: Path, content: str
    ) -> List[VulnerabilityReport]:
        """AST Í∏∞Î∞ò Ï∑®ÏïΩÏ†ê Î∂ÑÏÑù"""
        vulnerabilities = []
        lines = content.split("\n")
        for node in ast.walk(tree):
            if type(node).__name__ == "Call":
                func_name = self._get_function_name(node.func)
                if func_name in self.dangerous_functions:
                    line_content = (
                        lines[node.lineno - 1] if node.lineno <= len(lines) else ""
                    )
                    severity = (
                        ThreatLevel.CRITICAL
                        if func_name in ["eval", "exec"]
                        else ThreatLevel.HIGH
                    )
                    vulnerabilities = vulnerabilities + [
                        VulnerabilityReport(
                            vuln_id=self._generate_vuln_id(file_path, node.lineno),
                            vuln_type=VulnerabilityType.CODE_INJECTION,
                            threat_level=severity,
                            title=f"ÏúÑÌóòÌïú Ìï®Ïàò ÏÇ¨Ïö©: {func_name}",
                            description=f"Î≥¥ÏïàÏÉÅ ÏúÑÌóòÌïú Ìï®Ïàò '{func_name}'Í∞Ä ÏÇ¨Ïö©ÎêòÏóàÏäµÎãàÎã§",
                            file_path=str(file_path.relative_to(self.project_path)),
                            line_number=node.lineno,
                            code_snippet=line_content.strip(),
                            cwe_id=(
                                "CWE-94" if func_name in ["eval", "exec"] else "CWE-78"
                            ),
                            remediation=[
                                f"{func_name} Ìï®Ïàò ÏÇ¨Ïö©ÏùÑ ÌîºÌïòÍ≥† ÏïàÏ†ÑÌïú ÎåÄÏïà ÏÇ¨Ïö©",
                                "ÏûÖÎ†• Í≤ÄÏ¶ù Î∞è ÌôîÏù¥Ìä∏Î¶¨Ïä§Ìä∏ Î∞©Ïãù Ï†ÅÏö©",
                                "ÏµúÏÜå Í∂åÌïú ÏõêÏπô Ï†ÅÏö©",
                            ],
                            references=[
                                "https://owasp.org/www-project-top-ten/2017/A1_2017-Injection"
                            ],
                        )
                    ]
            if type(node).__name__ == "Str" and len(node.s) > 8:
                if any(
                    (
                        keyword in node.s.lower()
                        for keyword in ["password", "secret", "token", "key"]
                    )
                ):
                    line_content = (
                        lines[node.lineno - 1] if node.lineno <= len(lines) else ""
                    )
                    vulnerabilities = vulnerabilities + [
                        VulnerabilityReport(
                            vuln_id=self._generate_vuln_id(file_path, node.lineno),
                            vuln_type=VulnerabilityType.HARDCODED_SECRET,
                            threat_level=ThreatLevel.HIGH,
                            title="ÌïòÎìúÏΩîÎî©Îêú ÏãúÌÅ¨Î¶ø ÏùòÏã¨",
                            description="ÏΩîÎìúÏóê ÌïòÎìúÏΩîÎî©Îêú ÏãúÌÅ¨Î¶øÏù¥ Ìè¨Ìï®ÎêòÏñ¥ ÏûàÏùÑ Ïàò ÏûàÏäµÎãàÎã§",
                            file_path=str(file_path.relative_to(self.project_path)),
                            line_number=node.lineno,
                            code_snippet=line_content.strip(),
                            cwe_id="CWE-798",
                            remediation=[
                                "ÌôòÍ≤Ω Î≥ÄÏàòÎÇò Î≥¥Ïïà Ï†ÄÏû•ÏÜå ÏÇ¨Ïö©",
                                "ÏÑ§Ï†ï ÌååÏùºÏùÑ .gitignoreÏóê Ï∂îÍ∞Ä",
                                "ÏãúÌÅ¨Î¶ø Í¥ÄÎ¶¨ ÏãúÏä§ÌÖú ÎèÑÏûÖ",
                            ],
                        )
                    ]
        return vulnerabilities

    def _get_function_name(self, node: ast.AST) -> str:
        """Ìï®Ïàò Ïù¥Î¶Ñ Ï∂îÏ∂ú"""
        if type(node).__name__ == "Name":
            return node.id
        elif type(node).__name__ == "Attribute":
            if type(node.value).__name__ == "Name":
                return f"{node.value.id}.{node.attr}"
            else:
                return node.attr
        return ""

    async def _analyze_pattern_vulnerabilities(
        self, file_path: Path, content: str
    ) -> List[VulnerabilityReport]:
        """Ìå®ÌÑ¥ Í∏∞Î∞ò Ï∑®ÏïΩÏ†ê Î∂ÑÏÑù"""
        vulnerabilities = []
        lines = content.split("\n")
        for i, line in enumerate(lines, 1):
            for pattern in self.sqli_patterns:
                if re.search(pattern, line, re.IGNORECASE):
                    vulnerabilities = vulnerabilities + [
                        VulnerabilityReport(
                            vuln_id=self._generate_vuln_id(file_path, i),
                            vuln_type=VulnerabilityType.SQLI,
                            threat_level=ThreatLevel.HIGH,
                            title="SQL Ïù∏Ï†ùÏÖò Ï∑®ÏïΩÏ†ê ÏùòÏã¨",
                            description="SQL Ïù∏Ï†ùÏÖò Í≥µÍ≤©Ïóê Ï∑®ÏïΩÌï† Ïàò ÏûàÎäî ÏΩîÎìúÍ∞Ä Î∞úÍ≤¨ÎêòÏóàÏäµÎãàÎã§",
                            file_path=str(file_path.relative_to(self.project_path)),
                            line_number=i,
                            code_snippet=line.strip(),
                            cwe_id="CWE-89",
                            remediation=[
                                "Îß§Í∞úÎ≥ÄÏàòÌôîÎêú ÏøºÎ¶¨ ÏÇ¨Ïö©",
                                "ORM ÏÇ¨Ïö© Í∂åÏû•",
                                "ÏûÖÎ†• Í≤ÄÏ¶ù Î∞è Ïù¥Ïä§ÏºÄÏù¥Ìïë",
                            ],
                        )
                    ]
            for pattern in self.path_traversal_patterns:
                if re.search(pattern, line, re.IGNORECASE):
                    vulnerabilities = vulnerabilities + [
                        VulnerabilityReport(
                            vuln_id=self._generate_vuln_id(file_path, i),
                            vuln_type=VulnerabilityType.PATH_TRAVERSAL,
                            threat_level=ThreatLevel.MEDIUM,
                            title="Í≤ΩÎ°ú Ï°∞Ïûë Ï∑®ÏïΩÏ†ê ÏùòÏã¨",
                            description="Í≤ΩÎ°ú Ï°∞Ïûë Í≥µÍ≤©Ïóê Ï∑®ÏïΩÌï† Ïàò ÏûàÎäî ÏΩîÎìúÍ∞Ä Î∞úÍ≤¨ÎêòÏóàÏäµÎãàÎã§",
                            file_path=str(file_path.relative_to(self.project_path)),
                            line_number=i,
                            code_snippet=line.strip(),
                            cwe_id="CWE-22",
                            remediation=[
                                "Í≤ΩÎ°ú Ï†ïÍ∑úÌôî Î∞è Í≤ÄÏ¶ù",
                                "ÏïàÏ†ÑÌïú Í≤ΩÎ°úÎßå ÌóàÏö©ÌïòÎäî ÌôîÏù¥Ìä∏Î¶¨Ïä§Ìä∏ Î∞©Ïãù",
                                "chroot jail ÏÇ¨Ïö© Í≥†Î†§",
                            ],
                        )
                    ]
        return vulnerabilities

    async def _scan_dependency_vulnerabilities(self) -> List[VulnerabilityReport]:
        """ÏùòÏ°¥ÏÑ± Î≥¥Ïïà Í≤ÄÏÇ¨"""
        vulnerabilities = []
        try:
            requirements_file = self.project_path / "requirements.txt"
            if requirements_file.exists():
                vulnerabilities = (
                    vulnerabilities
                    + await self._check_python_dependencies(requirements_file)
                )
            pyproject_file = self.project_path / "pyproject.toml"
            if pyproject_file.exists():
                vulnerabilities = (
                    vulnerabilities
                    + await self._check_pyproject_dependencies(pyproject_file)
                )
        except Exception as e:
            if console:
                console.print(f"‚ö†Ô∏è  ÏùòÏ°¥ÏÑ± Í≤ÄÏÇ¨ Ïã§Ìå®: {str(e)}", style="yellow")
        return vulnerabilities

    async def _check_python_dependencies(
        self, requirements_file: Path
    ) -> List[VulnerabilityReport]:
        """Python ÏùòÏ°¥ÏÑ± Í≤ÄÏÇ¨"""
        vulnerabilities = []
        try:
            try:
                result = subprocess.run(
                    ["safety", "check", "-r", str(requirements_file), "--json"],
                    capture_output=True,
                    text=True,
                    timeout=30,
                )
                if result.returncode == 0:
                    try:
                        safety_data = json.loads(result.stdout)
                        for vuln in safety_data:
                            vulnerabilities = vulnerabilities + [
                                VulnerabilityReport(
                                    vuln_id=f"DEP-{vuln.get('id', 'unknown')}",
                                    vuln_type=VulnerabilityType.DEPENDENCY_VULN,
                                    threat_level=self._map_safety_severity(
                                        vuln.get("severity", "medium")
                                    ),
                                    title=f"Ï∑®ÏïΩÌïú Ìå®ÌÇ§ÏßÄ: {vuln.get('package', 'unknown')}",
                                    description=vuln.get(
                                        "advisory", "ÏïåÎ†§ÏßÑ Ï∑®ÏïΩÏ†êÏù¥ ÏûàÎäî Ìå®ÌÇ§ÏßÄÏûÖÎãàÎã§"
                                    ),
                                    file_path=str(
                                        requirements_file.relative_to(self.project_path)
                                    ),
                                    remediation=[
                                        f"Ìå®ÌÇ§ÏßÄÎ•º {vuln.get('fixed_in', 'ÏµúÏã† Î≤ÑÏ†Ñ')}ÏúºÎ°ú ÏóÖÎç∞Ïù¥Ìä∏",
                                        "ÎåÄÏïà Ìå®ÌÇ§ÏßÄ Í≤ÄÌÜ†",
                                    ],
                                )
                            ]
                    except json.JSONDecodeError:
                        pass
            except (subprocess.TimeoutExpired, FileNotFoundError):
                vulnerabilities = vulnerabilities + await self._manual_dependency_check(
                    requirements_file
                )
        except Exception as e:
            if console:
                console.print(f"‚ö†Ô∏è  Python ÏùòÏ°¥ÏÑ± Í≤ÄÏÇ¨ Ïã§Ìå®: {str(e)}", style="yellow")
        return vulnerabilities

    def _map_safety_severity(self, severity: str) -> ThreatLevel:
        """Safety ÎèÑÍµ¨ Ïã¨Í∞ÅÎèÑÎ•º ThreatLevelÎ°ú Îß§Ìïë"""
        mapping = {
            "critical": ThreatLevel.CRITICAL,
            "high": ThreatLevel.HIGH,
            "medium": ThreatLevel.MEDIUM,
            "low": ThreatLevel.LOW,
        }
        return mapping.get(severity.lower(), ThreatLevel.MEDIUM)

    async def _manual_dependency_check(
        self, requirements_file: Path
    ) -> List[VulnerabilityReport]:
        """ÏàòÎèô ÏùòÏ°¥ÏÑ± Í≤ÄÏÇ¨"""
        vulnerabilities = []
        try:
            content = requirements_file.read_text()
            known_vulnerabilities = {
                "django": ["<2.2.20", "<3.0.14", "<3.1.8"],
                "flask": ["<1.1.4"],
                "requests": ["<2.25.1"],
                "pyyaml": ["<5.4"],
                "pillow": ["<8.1.1"],
                "urllib3": ["<1.26.4"],
            }
            for line in content.split("\n"):
                line = line.strip()
                if not line or line.startswith("#"):
                    continue
                if "==" in line:
                    package_name, version = line.split("==", 1)
                    package_name = package_name.strip()
                    if package_name.lower() in known_vulnerabilities:
                        vulnerabilities = vulnerabilities + [
                            VulnerabilityReport(
                                vuln_id=f"MANUAL-{package_name}-{version}",
                                vuln_type=VulnerabilityType.DEPENDENCY_VULN,
                                threat_level=ThreatLevel.MEDIUM,
                                title=f"Ï∑®ÏïΩÌï† Ïàò ÏûàÎäî Ìå®ÌÇ§ÏßÄ: {package_name}",
                                description=f"{package_name} {version}ÏùÄ ÏïåÎ†§ÏßÑ Ï∑®ÏïΩÏ†êÏù¥ ÏûàÏùÑ Ïàò ÏûàÏäµÎãàÎã§",
                                file_path=str(
                                    requirements_file.relative_to(self.project_path)
                                ),
                                remediation=[
                                    f"{package_name} Ìå®ÌÇ§ÏßÄÎ•º ÏµúÏã† Î≤ÑÏ†ÑÏúºÎ°ú ÏóÖÎç∞Ïù¥Ìä∏",
                                    "Î≥¥Ïïà Ìå®ÏπòÍ∞Ä Ï†ÅÏö©Îêú Î≤ÑÏ†Ñ ÌôïÏù∏",
                                ],
                            )
                        ]
        except Exception as e:
            if console:
                console.print(f"‚ö†Ô∏è  ÏàòÎèô ÏùòÏ°¥ÏÑ± Í≤ÄÏÇ¨ Ïã§Ìå®: {str(e)}", style="yellow")
        return vulnerabilities

    async def _scan_configuration_security(self) -> List[VulnerabilityReport]:
        """ÏÑ§Ï†ï Î≥¥Ïïà Ï†êÍ≤Ä"""
        vulnerabilities = []
        try:
            env_files = list(self.project_path.glob(".env*"))
            for env_file in env_files:
                if env_file.is_file():
                    vulnerabilities = (
                        vulnerabilities + await self._check_env_file_security(env_file)
                    )
            config_files = [
                self.project_path / "config.py",
                self.project_path / "settings.py",
                self.project_path / "rfs.yaml",
                self.project_path / "docker-compose.yml",
            ]
            for config_file in config_files:
                if config_file.exists():
                    vulnerabilities = (
                        vulnerabilities
                        + await self._check_config_file_security(config_file)
                    )
        except Exception as e:
            if console:
                console.print(f"‚ö†Ô∏è  ÏÑ§Ï†ï Î≥¥Ïïà Ï†êÍ≤Ä Ïã§Ìå®: {str(e)}", style="yellow")
        return vulnerabilities

    async def _check_env_file_security(
        self, env_file: Path
    ) -> List[VulnerabilityReport]:
        """ÌôòÍ≤Ω Î≥ÄÏàò ÌååÏùº Î≥¥Ïïà Í≤ÄÏÇ¨"""
        vulnerabilities = []
        try:
            content = env_file.read_text()
            lines = content.split("\n")
            for i, line in enumerate(lines, 1):
                line = line.strip()
                if not line or line.startswith("#"):
                    continue
                if "DEBUG=True" in line.upper() or "DEBUG=1" in line:
                    vulnerabilities = vulnerabilities + [
                        VulnerabilityReport(
                            vuln_id=self._generate_vuln_id(env_file, i),
                            vuln_type=VulnerabilityType.INSECURE_CONFIG,
                            threat_level=ThreatLevel.HIGH,
                            title="ÌîÑÎ°úÎçïÏÖòÏóêÏÑú ÎîîÎ≤ÑÍ∑∏ Î™®Îìú ÌôúÏÑ±Ìôî",
                            description="ÎîîÎ≤ÑÍ∑∏ Î™®ÎìúÍ∞Ä ÌôúÏÑ±ÌôîÎêòÏñ¥ ÎØºÍ∞êÌïú Ï†ïÎ≥¥Í∞Ä ÎÖ∏Ï∂úÎê† Ïàò ÏûàÏäµÎãàÎã§",
                            file_path=str(env_file.relative_to(self.project_path)),
                            line_number=i,
                            code_snippet=line,
                            cwe_id="CWE-489",
                            remediation=[
                                "ÌîÑÎ°úÎçïÏÖò ÌôòÍ≤ΩÏóêÏÑúÎäî DEBUG=False ÏÑ§Ï†ï",
                                "ÌôòÍ≤ΩÎ≥Ñ ÏÑ§Ï†ï ÌååÏùº Î∂ÑÎ¶¨",
                            ],
                        )
                    ]
                if any(
                    (
                        weak in line.upper()
                        for weak in ["SECRET=123", "PASSWORD=PASSWORD", "KEY=KEY"]
                    )
                ):
                    vulnerabilities = vulnerabilities + [
                        VulnerabilityReport(
                            vuln_id=self._generate_vuln_id(env_file, i),
                            vuln_type=VulnerabilityType.WEAK_CRYPTO,
                            threat_level=ThreatLevel.CRITICAL,
                            title="ÏïΩÌïú ÏãúÌÅ¨Î¶ø/Ìå®Ïä§ÏõåÎìú ÏÇ¨Ïö©",
                            description="Í∏∞Î≥∏Í∞íÏù¥ÎÇò ÏïΩÌïú ÏãúÌÅ¨Î¶øÏù¥ ÏÇ¨Ïö©ÎêòÍ≥† ÏûàÏäµÎãàÎã§",
                            file_path=str(env_file.relative_to(self.project_path)),
                            line_number=i,
                            code_snippet=line,
                            cwe_id="CWE-798",
                            remediation=[
                                "Í∞ïÌïú ÎûúÎç§ ÏãúÌÅ¨Î¶ø ÏÉùÏÑ±",
                                "ÏãúÌÅ¨Î¶ø Í¥ÄÎ¶¨ ÎèÑÍµ¨ ÏÇ¨Ïö©",
                                "Ï†ïÍ∏∞Ï†ÅÏù∏ ÏãúÌÅ¨Î¶ø Î°úÌÖåÏù¥ÏÖò",
                            ],
                        )
                    ]
        except Exception as e:
            if console:
                console.print(
                    f"‚ö†Ô∏è  ÌôòÍ≤Ω ÌååÏùº Í≤ÄÏÇ¨ Ïã§Ìå® {env_file}: {str(e)}", style="yellow"
                )
        return vulnerabilities

    async def _scan_file_permissions(self) -> List[VulnerabilityReport]:
        """ÌååÏùº Í∂åÌïú Í≤ÄÏÇ¨"""
        vulnerabilities = []
        try:
            sensitive_files = [
                ".env",
                ".env.local",
                ".env.production",
                "secrets.json",
                "credentials.json",
                "private_key.pem",
                "*.key",
                "*.pem",
            ]
            for pattern in sensitive_files:
                files = list(self.project_path.glob(pattern))
                for file_path in files:
                    if file_path.is_file():
                        try:
                            import stat

                            file_stat = file_path.stat()
                            if file_stat.st_mode & stat.S_IROTH:
                                vulnerabilities = vulnerabilities + [
                                    VulnerabilityReport(
                                        vuln_id=f"PERM-{file_path.name}",
                                        vuln_type=VulnerabilityType.PERMISSION_ISSUE,
                                        threat_level=ThreatLevel.HIGH,
                                        title=f"ÏïàÏ†ÑÌïòÏßÄ ÏïäÏùÄ ÌååÏùº Í∂åÌïú: {file_path.name}",
                                        description="ÎØºÍ∞êÌïú ÌååÏùºÏù¥ Îã§Î•∏ ÏÇ¨Ïö©ÏûêÏóêÍ≤å ÏùΩÍ∏∞ Í∂åÌïúÏù¥ ÏûàÏäµÎãàÎã§",
                                        file_path=str(
                                            file_path.relative_to(self.project_path)
                                        ),
                                        remediation=[
                                            f"chmod 600 {file_path.name}",
                                            "ÎØºÍ∞êÌïú ÌååÏùºÏùò Ï†ëÍ∑º Í∂åÌïú Ï†úÌïú",
                                        ],
                                    )
                                ]
                        except Exception as e:
                            if console:
                                console.print(
                                    f"‚ö†Ô∏è  ÌååÏùº Í∂åÌïú ÌôïÏù∏ Ïã§Ìå® {file_path}: {str(e)}",
                                    style="yellow",
                                )
        except Exception as e:
            if console:
                console.print(f"‚ö†Ô∏è  ÌååÏùº Í∂åÌïú Í≤ÄÏÇ¨ Ïã§Ìå®: {str(e)}", style="yellow")
        return vulnerabilities

    async def _scan_hardcoded_secrets(self) -> List[VulnerabilityReport]:
        """ÌïòÎìúÏΩîÎî©Îêú ÏãúÌÅ¨Î¶ø ÌÉêÏßÄ"""
        vulnerabilities = []
        try:
            text_files = []
            for ext in [
                "*.py",
                "*.js",
                "*.ts",
                "*.yaml",
                "*.yml",
                "*.json",
                "*.txt",
                "*.md",
            ]:
                text_files = text_files + self.project_path.rglob(ext)
            for file_path in text_files:
                try:
                    content = file_path.read_text(encoding="utf-8", errors="ignore")
                    lines = content.split("\n")
                    for i, line in enumerate(lines, 1):
                        for pattern, secret_type in self.secret_patterns:
                            matches = re.finditer(pattern, line, re.IGNORECASE)
                            for match in matches:
                                vulnerabilities = vulnerabilities + [
                                    VulnerabilityReport(
                                        vuln_id=self._generate_vuln_id(file_path, i),
                                        vuln_type=VulnerabilityType.HARDCODED_SECRET,
                                        threat_level=ThreatLevel.CRITICAL,
                                        title=f"ÌïòÎìúÏΩîÎî©Îêú ÏãúÌÅ¨Î¶ø ÌÉêÏßÄ: {secret_type}",
                                        description=f"ÏΩîÎìúÏóê {secret_type}Í∞Ä ÌïòÎìúÏΩîÎî©ÎêòÏñ¥ ÏûàÏäµÎãàÎã§",
                                        file_path=str(
                                            file_path.relative_to(self.project_path)
                                        ),
                                        line_number=i,
                                        code_snippet=line.strip(),
                                        cwe_id="CWE-798",
                                        remediation=[
                                            "ÌôòÍ≤Ω Î≥ÄÏàò ÏÇ¨Ïö©",
                                            "ÏãúÌÅ¨Î¶ø Í¥ÄÎ¶¨ ÏÑúÎπÑÏä§ ÌôúÏö©",
                                            "ÏΩîÎìúÏóêÏÑú ÏãúÌÅ¨Î¶ø Ï†úÍ±∞ ÌõÑ .gitignore Ï∂îÍ∞Ä",
                                        ],
                                    )
                                ]
                except Exception as e:
                    continue
        except Exception as e:
            if console:
                console.print(f"‚ö†Ô∏è  ÏãúÌÅ¨Î¶ø ÌÉêÏßÄ Ïã§Ìå®: {str(e)}", style="yellow")
        return vulnerabilities

    def _generate_vuln_id(self, file_path: Path, line_number: int) -> str:
        """Ï∑®ÏïΩÏ†ê ID ÏÉùÏÑ±"""
        file_hash = hashlib.md5(str(file_path).encode()).hexdigest()[:8]
        return f"VULN-{file_hash}-{line_number}"

    async def _display_scan_results(self):
        """Ïä§Ï∫î Í≤∞Í≥º ÌëúÏãú"""
        if not console:
            return
        total_vulns = len(self.vulnerabilities)
        if total_vulns == 0:
            console.print(
                Panel(
                    "‚úÖ Ï∑®ÏïΩÏ†êÏù¥ Î∞úÍ≤¨ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§!\n\nüõ°Ô∏è  RFS v4 ÌîÑÎ°úÏ†ùÌä∏Ïùò Î≥¥Ïïà ÏÉÅÌÉúÍ∞Ä ÏñëÌò∏Ìï©ÎãàÎã§.",
                    title="Î≥¥Ïïà Ïä§Ï∫î ÏôÑÎ£å",
                    border_style="green",
                )
            )
            return
        severity_stats = {}
        for level in ThreatLevel:
            count = sum((1 for v in self.vulnerabilities if v.threat_level == level))
            if count > 0:
                severity_stats[level] = {level: count}
        summary_table = Table(
            title=f"Î≥¥Ïïà Ïä§Ï∫î Í≤∞Í≥º ({total_vulns}Í∞ú Ï∑®ÏïΩÏ†ê)",
            show_header=True,
            header_style="bold red",
        )
        summary_table.add_column("Ïã¨Í∞ÅÎèÑ", style="cyan", width=12)
        summary_table.add_column("Í∞úÏàò", justify="right", width=8)
        summary_table.add_column("ÎπÑÏú®", justify="right", width=10)
        summary_table.add_column("ÏÉÅÌÉú", justify="center", width=8)
        severity_colors = {
            ThreatLevel.CRITICAL: "bright_red",
            ThreatLevel.HIGH: "red",
            ThreatLevel.MEDIUM: "yellow",
            ThreatLevel.LOW: "green",
            ThreatLevel.INFO: "blue",
        }
        for level, count in severity_stats.items():
            color = severity_colors.get(level, "white")
            percentage = count / total_vulns * 100
            summary_table.add_row(
                f"[{color}]{level.value.upper()}[/{color}]",
                str(count),
                f"{percentage:.1f}%",
                (
                    "üö®"
                    if level in [ThreatLevel.CRITICAL, ThreatLevel.HIGH]
                    else "‚ö†Ô∏è" if level == ThreatLevel.MEDIUM else "‚ÑπÔ∏è"
                ),
            )
        console.print(summary_table)
        console.print("\nüéØ Ïö∞ÏÑ† ÏàòÏ†ï Í∂åÏû• Ï∑®ÏïΩÏ†ê:")
        top_vulnerabilities = self.vulnerabilities[:5]
        for i, vuln in enumerate(top_vulnerabilities, 1):
            color = severity_colors.get(vuln.threat_level, "white")
            detail_panel = Panel(
                f"**{vuln.description}**\n\nÌååÏùº: {vuln.file_path or 'N/A'}"
                + (f" (ÎùºÏù∏ {vuln.line_number})" if vuln.line_number else "")
                + "\n"
                + (f"ÏΩîÎìú: `{vuln.code_snippet}`\n\n" if vuln.code_snippet else "\n")
                + f"**ÏàòÏ†ï Î∞©Î≤ï:**\n"
                + "\n".join([f"‚Ä¢ {rec}" for rec in vuln.remediation[:2]]),
                title=f"{i}. {vuln.title} (ÏúÑÌóòÎèÑ: {vuln.risk_score}/100)",
                border_style=color,
            )
            console.print(detail_panel)
        critical_high = sum(
            (
                1
                for v in self.vulnerabilities
                if v.threat_level in [ThreatLevel.CRITICAL, ThreatLevel.HIGH]
            )
        )
        if critical_high > 0:
            console.print(
                Panel(
                    f"üö® {critical_high}Í∞úÏùò Ïã¨Í∞ÅÌïú Ï∑®ÏïΩÏ†êÏù¥ Î∞úÍ≤¨ÎêòÏóàÏäµÎãàÎã§!\n\nÏ¶âÏãú ÏàòÏ†ïÏù¥ ÌïÑÏöîÌïú Ìï≠Î™©Îì§ÏùÑ Ïö∞ÏÑ†Ï†ÅÏúºÎ°ú Ìï¥Í≤∞ÌïòÏÑ∏Ïöî.\nÏÉÅÏÑ∏Ìïú Î¶¨Ìè¨Ìä∏Îäî Î≥¥Ïïà ÌåÄÍ≥º Í≥µÏú†ÌïòÏó¨ Í≤ÄÌÜ†Î∞õÏúºÏãúÍ∏∞ Î∞îÎûçÎãàÎã§.",
                    title="Î≥¥Ïïà Í≤ΩÍ≥†",
                    border_style="bright_red",
                )
            )
        else:
            console.print(
                Panel(
                    f"‚ö†Ô∏è  {total_vulns}Í∞úÏùò Ï∑®ÏïΩÏ†êÏù¥ Î∞úÍ≤¨ÎêòÏóàÏäµÎãàÎã§.\n\nÎåÄÎ∂ÄÎ∂Ñ Ï§ëÍ∞Ñ ÎòêÎäî ÎÇÆÏùÄ ÏúÑÌóòÎèÑÏù¥ÎØÄÎ°ú Í≥ÑÌöçÏ†ÅÏúºÎ°ú ÏàòÏ†ïÌïòÏÑ∏Ïöî.\nÏ†ïÍ∏∞Ï†ÅÏù∏ Î≥¥Ïïà Ïä§Ï∫îÏùÑ ÌÜµÌï¥ Î≥¥Ïïà ÏàòÏ§ÄÏùÑ Ïú†ÏßÄÌïòÏãúÍ∏∞ Î∞îÎûçÎãàÎã§.",
                    title="Î≥¥Ïïà Ï†êÍ≤Ä ÏôÑÎ£å",
                    border_style="yellow",
                )
            )

    async def generate_security_report(
        self, output_path: Optional[str] = None
    ) -> Result[str, str]:
        """Î≥¥Ïïà Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ±"""
        try:
            if output_path is None:
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                output_path = f"security_report_{timestamp}.json"
            report = {
                "scan_info": {
                    "timestamp": datetime.now().isoformat(),
                    "project_path": str(self.project_path),
                    "total_vulnerabilities": len(self.vulnerabilities),
                },
                "summary": {
                    level.value: sum(
                        (1 for v in self.vulnerabilities if v.threat_level == level)
                    )
                    for level in ThreatLevel
                },
                "vulnerabilities": [
                    {
                        "id": vuln.vuln_id,
                        "type": vuln.vuln_type.value,
                        "threat_level": vuln.threat_level.value,
                        "title": vuln.title,
                        "description": vuln.description,
                        "file_path": vuln.file_path,
                        "line_number": vuln.line_number,
                        "code_snippet": vuln.code_snippet,
                        "cwe_id": vuln.cwe_id,
                        "cvss_score": vuln.cvss_score,
                        "risk_score": vuln.risk_score,
                        "remediation": vuln.remediation,
                        "references": vuln.references,
                        "confirmed": vuln.confirmed,
                    }
                    for vuln in self.vulnerabilities
                ],
            }
            report_file = Path(output_path)
            with open(report_file, "w", encoding="utf-8") as f:
                json.dump(report, f, indent=2, ensure_ascii=False)
            return Success(str(report_file.absolute()))
        except Exception as e:
            return Failure(f"Î≥¥Ïïà Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ± Ïã§Ìå®: {str(e)}")

    def get_vulnerability_summary(self) -> Dict[str, Any]:
        """Ï∑®ÏïΩÏ†ê ÏöîÏïΩ Ï†ïÎ≥¥ Ï°∞Ìöå"""
        if not self.vulnerabilities:
            return {"total": 0, "by_severity": {}, "by_type": {}}
        by_severity = {}
        for level in ThreatLevel:
            count = sum((1 for v in self.vulnerabilities if v.threat_level == level))
            if count > 0:
                by_severity[level.value] = {level.value: count}
        by_type = {}
        for vuln_type in VulnerabilityType:
            count = sum((1 for v in self.vulnerabilities if v.vuln_type == vuln_type))
            if count > 0:
                by_type[vuln_type.value] = {vuln_type.value: count}
        risk_scores = [v.risk_score for v in self.vulnerabilities]
        return {
            "total": len(self.vulnerabilities),
            "by_severity": by_severity,
            "by_type": by_type,
            "risk_stats": {
                "max_risk": max(risk_scores),
                "avg_risk": sum(risk_scores) / len(risk_scores),
                "high_risk_count": sum((1 for score in risk_scores if score >= 70)),
            },
            "critical_files": [
                v.file_path
                for v in self.vulnerabilities
                if v.threat_level == ThreatLevel.CRITICAL and v.file_path
            ][:5],
        }
