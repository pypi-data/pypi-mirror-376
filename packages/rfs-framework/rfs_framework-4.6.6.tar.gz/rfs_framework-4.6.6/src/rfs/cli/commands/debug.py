"""
Debug and Utility Commands (RFS v4)

ÎîîÎ≤ÑÍπÖ Î∞è Ïú†Ìã∏Î¶¨Ìã∞ Î™ÖÎ†πÏñ¥Îì§
- debug: ÎîîÎ≤ÑÍπÖ ÎèÑÍµ¨
- status: ÏãúÏä§ÌÖú ÏÉÅÌÉú ÌôïÏù∏
- health: Ìó¨Ïä§Ï≤¥ÌÅ¨
"""

import asyncio
import os
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional

import psutil

try:
    from rich.console import Console
    from rich.panel import Panel
    from rich.progress import BarColumn, Progress, SpinnerColumn, TextColumn
    from rich.syntax import Syntax
    from rich.table import Table
    from rich.tree import Tree

    RICH_AVAILABLE = True
except ImportError:
    RICH_AVAILABLE = False
from ...core.config import get_config
from ...core.result import Failure, Result, Success
from ..core import Command

if RICH_AVAILABLE:
    console = Console()
else:
    console = None


class DebugCommand(Command):
    """ÎîîÎ≤ÑÍπÖ ÎèÑÍµ¨ Î™ÖÎ†πÏñ¥"""

    name = "debug"
    description = "RFS Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò ÎîîÎ≤ÑÍπÖ ÎèÑÍµ¨"

    def __init__(self):
        super().__init__()
        self.debug_tools = {
            "trace": "Ïã§Ìñâ Ï∂îÏ†Å",
            "profile": "ÏÑ±Îä• ÌîÑÎ°úÌååÏùºÎßÅ",
            "memory": "Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ Î∂ÑÏÑù",
            "config": "ÏÑ§Ï†ï Ï†ïÎ≥¥ ÌôïÏù∏",
            "dependencies": "ÏùòÏ°¥ÏÑ± ÌôïÏù∏",
            "logs": "Î°úÍ∑∏ Î∂ÑÏÑù",
        }

    async def execute(self, args: List[str]) -> Result[str, str]:
        """ÎîîÎ≤ÑÍπÖ ÎèÑÍµ¨ Ïã§Ìñâ"""
        try:
            if not args:
                return await self._show_debug_menu()
            tool = args[0].lower()
            if tool not in self.debug_tools:
                return Failure(f"ÏßÄÏõêÌïòÏßÄ ÏïäÎäî ÎîîÎ≤ÑÍπÖ ÎèÑÍµ¨: {tool}")
            if console:
                console.print(
                    Panel(
                        f"üîç {self.debug_tools[tool]} Ïã§Ìñâ Ï§ë...",
                        title=f"ÎîîÎ≤ÑÍπÖ ÎèÑÍµ¨: {tool}",
                        border_style="yellow",
                    )
                )
            if tool == "trace":
                return await self._debug_trace(args[1:])
            else:
                match tool:
                    case "profile":
                        return await self._debug_profile(args[1:])
                    case "memory":
                        return await self._debug_memory(args[1:])
                    case "config":
                        return await self._debug_config(args[1:])
                    case "dependencies":
                        return await self._debug_dependencies(args[1:])
                    case "logs":
                        return await self._debug_logs(args[1:])
                    case _:
                        return Failure(f"ÏßÄÏõêÌïòÏßÄ ÏïäÎäî ÎîîÎ≤ÑÍπÖ ÎèÑÍµ¨: {tool}")
        except Exception as e:
            return Failure(f"ÎîîÎ≤ÑÍπÖ Ïã§Ìå®: {str(e)}")

    async def _show_debug_menu(self) -> Result[str, str]:
        """ÎîîÎ≤ÑÍπÖ ÎèÑÍµ¨ Î©îÎâ¥ ÌëúÏãú"""
        if console:
            console.print(
                Panel(
                    "üîç RFS v4 ÎîîÎ≤ÑÍπÖ ÎèÑÍµ¨", title="ÎîîÎ≤ÑÍπÖ ÎèÑÍµ¨", border_style="yellow"
                )
            )
            debug_table = Table(show_header=True, header_style="bold magenta")
            debug_table.add_column("ÎèÑÍµ¨", style="cyan", width=15)
            debug_table.add_column("ÏÑ§Î™Ö", style="white")
            debug_table.add_column("ÏÇ¨Ïö©Î≤ï", style="green")
            for tool, description in self.debug_tools.items():
                debug_table.add_row(tool, description, f"rfs debug {tool}")
            console.print(debug_table)
        return Success("ÎîîÎ≤ÑÍπÖ ÎèÑÍµ¨ Î©îÎâ¥ ÌëúÏãú ÏôÑÎ£å")

    async def _debug_trace(self, args: List[str]) -> Result[str, str]:
        """Ïã§Ìñâ Ï∂îÏ†Å"""
        try:
            target = args[0] if args else "main.py"
            if not Path(target).exists():
                return Failure(f"ÎåÄÏÉÅ ÌååÏùºÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: {target}")
            if console:
                console.print(f"üìä Ïã§Ìñâ Ï∂îÏ†Å ÏãúÏûë: {target}")
            cmd = ["python", "-m", "trace", "--trace", target]
            process = await asyncio.create_subprocess_exec(
                *cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE
            )
            stdout, stderr = await process.communicate()
            if process.returncode == 0:
                trace_output = stdout.decode()
                if console:
                    syntax = Syntax(
                        trace_output[:2000],
                        "python",
                        theme="monokai",
                        line_numbers=True,
                    )
                    console.print(Panel(syntax, title="Ïã§Ìñâ Ï∂îÏ†Å Í≤∞Í≥º"))
                else:
                    print(trace_output[:2000])
                return Success("Ïã§Ìñâ Ï∂îÏ†Å ÏôÑÎ£å")
            else:
                error_msg = stderr.decode()
                return Failure(f"Ï∂îÏ†Å Ïã§Ìñâ Ïã§Ìå®: {error_msg}")
        except Exception as e:
            return Failure(f"Ï∂îÏ†Å Ïã§Ìå®: {str(e)}")

    async def _debug_profile(self, args: List[str]) -> Result[str, str]:
        """ÏÑ±Îä• ÌîÑÎ°úÌååÏùºÎßÅ"""
        try:
            target = args[0] if args else "main.py"
            if not Path(target).exists():
                return Failure(f"ÎåÄÏÉÅ ÌååÏùºÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: {target}")
            if console:
                with Progress(
                    SpinnerColumn(),
                    TextColumn("[progress.description]{task.description}"),
                    console=console,
                ) as progress:
                    task = progress.add_task("ÏÑ±Îä• ÌîÑÎ°úÌååÏùºÎßÅ Ïã§Ìñâ Ï§ë...", total=None)
                    cmd = ["python", "-m", "cProfile", "-s", "cumtime", target]
                    process = await asyncio.create_subprocess_exec(
                        *cmd,
                        stdout=asyncio.subprocess.PIPE,
                        stderr=asyncio.subprocess.PIPE,
                    )
                    stdout, stderr = await process.communicate()
                    progress.remove_task(task)
                if process.returncode == 0:
                    profile_output = stdout.decode()
                    if console:
                        lines = profile_output.split("\n")
                        profile_table = Table(
                            title="ÏÑ±Îä• ÌîÑÎ°úÌååÏùºÎßÅ Í≤∞Í≥º", show_header=True
                        )
                        profile_table.add_column("Ìò∏Ï∂ú ÌöüÏàò", justify="right")
                        profile_table.add_column("ÎàÑÏ†Å ÏãúÍ∞Ñ", justify="right")
                        profile_table.add_column("Ìï®Ïàò")
                        for line in lines[5:15]:
                            if line.strip():
                                parts = line.split()
                                if len(parts) >= 6:
                                    profile_table.add_row(
                                        parts[0], parts[3], " ".join(parts[5:])
                                    )
                        console.print(profile_table)
                    else:
                        print(profile_output[:1000])
                    return Success("ÏÑ±Îä• ÌîÑÎ°úÌååÏùºÎßÅ ÏôÑÎ£å")
                else:
                    error_msg = stderr.decode()
                    return Failure(f"ÌîÑÎ°úÌååÏùºÎßÅ Ïã§Ìå®: {error_msg}")
        except Exception as e:
            return Failure(f"ÌîÑÎ°úÌååÏùºÎßÅ Ïã§Ìå®: {str(e)}")


class StatusCommand(Command):
    """ÏãúÏä§ÌÖú ÏÉÅÌÉú ÌôïÏù∏ Î™ÖÎ†πÏñ¥"""

    name = "status"
    description = "RFS ÏãúÏä§ÌÖú ÏÉÅÌÉú Î∞è ÌôòÍ≤Ω Ï†ïÎ≥¥ ÌôïÏù∏"

    async def execute(self, args: List[str]) -> Result[str, str]:
        """ÏãúÏä§ÌÖú ÏÉÅÌÉú ÌôïÏù∏"""
        try:
            if console:
                console.print(
                    Panel(
                        "üìä RFS v4 ÏãúÏä§ÌÖú ÏÉÅÌÉú ÌôïÏù∏",
                        title="ÏãúÏä§ÌÖú ÏÉÅÌÉú",
                        border_style="blue",
                    )
                )
            status_info = await self._collect_status_info()
            await self._display_status_info(status_info)
            return Success("ÏãúÏä§ÌÖú ÏÉÅÌÉú ÌôïÏù∏ ÏôÑÎ£å")
        except Exception as e:
            return Failure(f"ÏÉÅÌÉú ÌôïÏù∏ Ïã§Ìå®: {str(e)}")

    async def _collect_status_info(self) -> Dict[str, Any]:
        """ÏãúÏä§ÌÖú ÏÉÅÌÉú Ï†ïÎ≥¥ ÏàòÏßë"""
        status = {}
        try:
            status = {
                **status,
                "system": {
                    "platform": os.name,
                    "python_version": os.sys.version.split()[0],
                    "cwd": str(Path.cwd()),
                    "timestamp": datetime.now().isoformat(),
                },
            }
            if hasattr(psutil, "virtual_memory"):
                memory = psutil.virtual_memory()
                status = {
                    **status,
                    "resources": {
                        "cpu_percent": psutil.cpu_percent(interval=1),
                        "memory_percent": memory.percent,
                        "memory_total": f"{memory.total / 1024 ** 3:.1f}GB",
                        "memory_used": f"{memory.used / 1024 ** 3:.1f}GB",
                    },
                }
            try:
                config = get_config()
                status = {
                    **status,
                    "rfs_config": {
                        "environment": getattr(config, "environment", "Unknown"),
                        "debug": getattr(config, "debug", False),
                        "log_level": getattr(config, "log_level", "INFO"),
                    },
                }
            except Exception:
                status = {**status, "rfs_config": {"error": "RFS ÏÑ§Ï†ï Î°úÎìú Ïã§Ìå®"}}
            status = {
                **status,
                "project": {
                    "name": Path.cwd().name,
                    "main_py_exists": Path("main.py").exists(),
                    "requirements_exists": Path("requirements.txt").exists(),
                    "docker_exists": Path("Dockerfile").exists(),
                    "rfs_config_exists": Path("rfs.yaml").exists(),
                },
            }
            status = {
                **status,
                "dependencies": await self._check_dependencies(),
            }
        except Exception as e:
            status["error"] = str(e)
        return status

    async def _check_dependencies(self) -> Dict[str, Any]:
        """ÏùòÏ°¥ÏÑ± ÌôïÏù∏"""
        deps = {}
        try:
            import pkg_resources

            required_packages = ["rfs-framework", "pydantic", "rich"]
            for package in required_packages:
                try:
                    version = pkg_resources.get_distribution(package).version
                    deps[package] = {"version": version, "status": "installed"}
                except pkg_resources.DistributionNotFound:
                    deps[package] = {"version": None, "status": "missing"}

            # Docker Ï≤¥ÌÅ¨
            try:
                process = await asyncio.create_subprocess_exec(
                    "docker",
                    "--version",
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE,
                )
                stdout, _ = await process.communicate()
                if process.returncode == 0:
                    version_info = stdout.decode().strip()
                    deps["docker"] = {"version": version_info, "status": "available"}
                else:
                    deps["docker"] = {"version": None, "status": "unavailable"}
            except:
                deps["docker"] = {"version": None, "status": "unavailable"}

            # GCloud Ï≤¥ÌÅ¨
            try:
                process = await asyncio.create_subprocess_exec(
                    "gcloud",
                    "--version",
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE,
                )
                await process.communicate()
                deps["gcloud"] = {
                    "version": "installed" if process.returncode == 0 else None,
                    "status": "available" if process.returncode == 0 else "unavailable",
                }
            except:
                deps["gcloud"] = {"version": None, "status": "unavailable"}
        except Exception as e:
            deps["error"] = str(e)
        return deps

    async def _display_status_info(self, status: Dict[str, Any]) -> None:
        """ÏÉÅÌÉú Ï†ïÎ≥¥ ÌëúÏãú"""
        if not console:
            for section, data in status.items():
                print(f"\n{section.upper()}:")
                if isinstance(data, dict):
                    for key, value in data.items():
                        print(f"  {key}: {value}")
                else:
                    print(f"  {data}")
            return

        if "system" in status:
            system_table = Table(title="ÏãúÏä§ÌÖú Ï†ïÎ≥¥", show_header=False)
            system_table.add_column("Ìï≠Î™©", style="cyan")
            system_table.add_column("Í∞í", style="white")
            for key, value in status.get("system", {}).items():
                system_table.add_row(key.replace("_", " ").title(), str(value))
            console.print(system_table)

        if "resources" in status:
            resource_table = Table(title="ÏãúÏä§ÌÖú Î¶¨ÏÜåÏä§", show_header=False)
            resource_table.add_column("Î¶¨ÏÜåÏä§", style="cyan")
            resource_table.add_column("ÏÇ¨Ïö©Îüâ", style="white")
            for key, value in status.get("resources", {}).items():
                resource_table.add_row(key.replace("_", " ").title(), str(value))
            console.print(resource_table)

        if "dependencies" in status and isinstance(status.get("dependencies"), dict):
            deps_table = Table(
                title="ÏùòÏ°¥ÏÑ± ÏÉÅÌÉú", show_header=True, header_style="bold magenta"
            )
            deps_table.add_column("Ìå®ÌÇ§ÏßÄ", style="cyan")
            deps_table.add_column("Î≤ÑÏ†Ñ", style="green")
            deps_table.add_column("ÏÉÅÌÉú", style="yellow")
            for package, info in status.get("dependencies", {}).items():
                if isinstance(info, dict) and "status" in info:
                    version = info.get("version", "N/A")
                    status_text = info.get("status", "unknown")
                    if status_text in ["installed", "available"]:
                        status_style = "green"
                    elif status_text in ["missing", "unavailable"]:
                        status_style = "red"
                    else:
                        status_style = "yellow"
                    deps_table.add_row(
                        package,
                        str(version),
                        f"[{status_style}]{status_text}[/{status_style}]",
                    )
            console.print(deps_table)


class HealthCommand(Command):
    """Ìó¨Ïä§Ï≤¥ÌÅ¨ Î™ÖÎ†πÏñ¥"""

    name = "health"
    description = "RFS Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò Ìó¨Ïä§Ï≤¥ÌÅ¨"

    async def execute(self, args: List[str]) -> Result[str, str]:
        """Ìó¨Ïä§Ï≤¥ÌÅ¨ Ïã§Ìñâ"""
        try:
            options = self._parse_health_options(args)
            if console:
                console.print(
                    Panel(
                        f"üè• RFS v4 Ìó¨Ïä§Ï≤¥ÌÅ¨ Ïã§Ìñâ\n\nüéØ ÎåÄÏÉÅ: {options.get('target', 'local')}\nüîç Ï≤¥ÌÅ¨ Ìï≠Î™©: {len(self._get_health_checks())}Í∞ú\n‚ö° ÌÉÄÏûÑÏïÑÏõÉ: {options.get('timeout', 30)}Ï¥à",
                        title="Ìó¨Ïä§Ï≤¥ÌÅ¨",
                        border_style="green",
                    )
                )
            health_results = await self._run_health_checks(options)
            await self._display_health_results(health_results)
            all_passed = all(
                result["status"] == "pass" for result in health_results.values()
            )
            if all_passed:
                return Success("Î™®Îì† Ìó¨Ïä§Ï≤¥ÌÅ¨ ÌÜµÍ≥º")
            else:
                failed_checks = [
                    name
                    for name, result in health_results.items()
                    if result.get("status") != "pass"
                ]
                return Failure(f"Ìó¨Ïä§Ï≤¥ÌÅ¨ Ïã§Ìå®: {', '.join(failed_checks)}")
        except Exception as e:
            return Failure(f"Ìó¨Ïä§Ï≤¥ÌÅ¨ Ïã§Ìå®: {str(e)}")

    def _parse_health_options(self, args: List[str]) -> Dict[str, Any]:
        """Ìó¨Ïä§Ï≤¥ÌÅ¨ ÏòµÏÖò ÌååÏã±"""
        options = {"target": "local", "timeout": 30, "detailed": False}
        for i, arg in enumerate(args):
            if arg == "--target" and i + 1 < len(args):
                options["target"] = args[i + 1]
            elif arg == "--timeout" and i + 1 < len(args):
                options["timeout"] = int(args[i + 1])
            elif arg in ["--detailed", "-v"]:
                options["detailed"] = True
        return options

    def _get_health_checks(self) -> List[str]:
        """Ìó¨Ïä§Ï≤¥ÌÅ¨ Ìï≠Î™© Î™©Î°ù"""
        return [
            "python_environment",
            "rfs_configuration",
            "file_system",
            "memory_usage",
            "dependencies",
            "network_connectivity",
        ]

    async def _run_health_checks(
        self, options: Dict[str, Any]
    ) -> Dict[str, Dict[str, Any]]:
        """Ìó¨Ïä§Ï≤¥ÌÅ¨ Ïã§Ìñâ"""
        results = {}
        checks = self._get_health_checks()
        for check in checks:
            try:
                match check:
                    case "python_environment":
                        result = await self._check_python_environment()
                    case "rfs_configuration":
                        result = await self._check_rfs_configuration()
                    case "file_system":
                        result = await self._check_file_system()
                    case "memory_usage":
                        result = await self._check_memory_usage()
                    case "dependencies":
                        result = await self._check_dependencies_health()
                    case "network_connectivity":
                        result = await self._check_network_connectivity()
                    case _:
                        result = {
                            "status": "skip",
                            "message": "Unknown check",
                        }
                results[check] = result
            except Exception as e:
                results[check] = {
                    "status": "fail",
                    "message": f"Check failed: {str(e)}",
                }
        return results

    async def _check_python_environment(self) -> Dict[str, Any]:
        """Python ÌôòÍ≤Ω Ï≤¥ÌÅ¨"""
        import sys

        version = sys.version_info
        if version.major >= 3 and version.minor >= 10:
            return {
                "status": "pass",
                "message": f"Python {version.major}.{version.minor}.{version.micro}",
            }
        else:
            return {
                "status": "fail",
                "message": f"Python 3.10+ ÌïÑÏöî (ÌòÑÏû¨: {version.major}.{version.minor}.{version.micro})",
            }

    async def _display_health_results(self, results: Dict[str, Dict[str, Any]]) -> None:
        """Ìó¨Ïä§Ï≤¥ÌÅ¨ Í≤∞Í≥º ÌëúÏãú"""
        if not console:
            for check, result in results.items():
                status = result["status"].upper()
                message = result["message"]
                print(f"{check}: {status} - {message}")
            return
        health_table = Table(
            title="Ìó¨Ïä§Ï≤¥ÌÅ¨ Í≤∞Í≥º", show_header=True, header_style="bold magenta"
        )
        health_table.add_column("Ï≤¥ÌÅ¨ Ìï≠Î™©", style="cyan", width=20)
        health_table.add_column("ÏÉÅÌÉú", style="white", width=10, justify="center")
        health_table.add_column("Î©îÏãúÏßÄ", style="white")
        for check, result in results.items():
            status = result["status"]
            message = result["message"]
            if status == "pass":
                status_display = "[green]‚úÖ PASS[/green]"
            else:
                match status:
                    case "fail":
                        status_display = "[red]‚ùå FAIL[/red]"
                    case "warn":
                        status_display = "[yellow]‚ö†Ô∏è WARN[/yellow]"
                    case _:
                        status_display = "[dim]‚ûñ SKIP[/dim]"
            health_table.add_row(
                check.replace("_", " ").title(), status_display, message
            )
        console.print(health_table)
