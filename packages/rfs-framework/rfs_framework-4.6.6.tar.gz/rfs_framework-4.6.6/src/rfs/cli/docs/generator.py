"""
Documentation Generator (RFS v4)

Ï¢ÖÌï©Ï†ÅÏù∏ Î¨∏ÏÑú ÏûêÎèô ÏÉùÏÑ± ÏãúÏä§ÌÖú
- Îã§ÏñëÌïú ÌòïÏãù ÏßÄÏõê (Markdown, HTML, PDF)
- ÌÖúÌîåÎ¶ø Í∏∞Î∞ò ÏÉùÏÑ±
- ÏûêÎèô ÏΩîÎìú Î∂ÑÏÑù Î∞è Î¨∏ÏÑúÌôî
- Îã§Íµ≠Ïñ¥ ÏßÄÏõê
"""

import ast
import asyncio
import inspect
import json
import os
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional, Union

from rfs.core.registry import stateless

try:
    from rich.console import Console
    from rich.panel import Panel
    from rich.progress import BarColumn, Progress, SpinnerColumn, TextColumn
    from rich.table import Table

    RICH_AVAILABLE = True
except ImportError:
    RICH_AVAILABLE = False
from ...core.config import get_config
from ...core.result import Failure, Result, Success

if RICH_AVAILABLE:
    console = Console()
else:
    console = None


class DocFormat(Enum):
    """Î¨∏ÏÑú ÌòïÏãù"""

    MARKDOWN = "markdown"
    HTML = "html"
    PDF = "pdf"
    DOCX = "docx"
    SPHINX = "sphinx"


class DocType(Enum):
    """Î¨∏ÏÑú Ïú†Ìòï"""

    API = "api"
    USER_GUIDE = "user_guide"
    DEVELOPER_GUIDE = "developer_guide"
    ARCHITECTURE = "architecture"
    TUTORIAL = "tutorial"
    REFERENCE = "reference"
    CHANGELOG = "changelog"


@dataclass
class DocConfig:
    """Î¨∏ÏÑú ÏÉùÏÑ± ÏÑ§Ï†ï"""

    output_dir: str = "docs"
    formats: List[DocFormat] = field(default_factory=lambda: [DocFormat.MARKDOWN])
    include_private: bool = False
    include_source: bool = True
    language: str = "ko"
    theme: str = "default"
    auto_toc: bool = True
    include_examples: bool = True
    generate_index: bool = True
    project_info: Dict[str, Any] = field(default_factory=dict)
    custom_templates: Dict[str, str] = field(default_factory=dict)


class DocumentationGenerator:
    """Î¨∏ÏÑú ÏÉùÏÑ± Î©îÏù∏ ÌÅ¥ÎûòÏä§"""

    def __init__(self, config: Optional[DocConfig] = None):
        self.config = config or DocConfig()
        self.project_path = Path.cwd()
        self.output_path = Path(self.config.output_dir)
        self.templates_path = Path(__file__).parent / "templates"
        self._collect_project_info()

    def _collect_project_info(self):
        """ÌîÑÎ°úÏ†ùÌä∏ Ï†ïÎ≥¥ ÏûêÎèô ÏàòÏßë"""
        try:
            if not self.config.project_info:
                self.config.project_info = {}
            self.config.project_info.setdefault("name", self.project_path.name)
            self.config.project_info.setdefault("version", "1.0.0")
            self.config.project_info.setdefault("description", "RFS v4 ÌîÑÎ°úÏ†ùÌä∏")
            self.config.project_info.setdefault("author", "RFS Team")
            self.config.project_info.setdefault(
                "generated_at", datetime.now().isoformat()
            )
            setup_py = self.project_path / "setup.py"
            if setup_py.exists():
                self._parse_setup_py(setup_py)
            pyproject_toml = self.project_path / "pyproject.toml"
            if pyproject_toml.exists():
                self._parse_pyproject_toml(pyproject_toml)
        except Exception as e:
            if console:
                console.print(
                    f"‚ö†Ô∏è  ÌîÑÎ°úÏ†ùÌä∏ Ï†ïÎ≥¥ ÏàòÏßë Ï§ë Ïò§Î•ò: {str(e)}", style="yellow"
                )

    def _parse_setup_py(self, setup_file: Path):
        """setup.py ÌååÏã±"""
        try:
            content = setup_file.read_text(encoding="utf-8")
            tree = ast.parse(content)
            for node in ast.walk(tree):
                if (
                    type(node).__name__ == "Call"
                    and hasattr(node.func, "id")
                    and (node.func.id == "setup")
                ):
                    for keyword in node.keywords:
                        if keyword.arg in ["name", "version", "description", "author"]:
                            if type(keyword.value).__name__ == "Str":
                                self.config.project_info = {
                                    **self.config.project_info,
                                    keyword.arg: keyword.value.s,
                                }
                            elif type(keyword.value).__name__ == "Constant":
                                self.config.project_info = {
                                    **self.config.project_info,
                                    keyword.arg: keyword.value.value,
                                }
        except Exception:
            pass

    def _parse_pyproject_toml(self, toml_file: Path):
        """pyproject.toml ÌååÏã±"""
        try:
            import tomllib

            content = toml_file.read_text(encoding="utf-8")
            data = tomllib.loads(content)
            project = data.get("project", {})
            for key in ["name", "version", "description"]:
                if key in project:
                    self.config.project_info = {
                        **self.config.project_info,
                        key: project[key],
                    }
            authors = project.get("authors", [])
            if authors and (
                hasattr(authors[0], "__class__")
                and authors[0].__class__.__name__ == "dict"
            ):
                self.config.project_info = {
                    **self.config.project_info,
                    "author": authors[0].get("name", "Unknown"),
                }
        except Exception:
            pass

    async def generate_all_docs(
        self, doc_types: Optional[List[DocType]] = None
    ) -> Result[Dict[str, str], str]:
        """Î™®Îì† Î¨∏ÏÑú ÏÉùÏÑ±"""
        try:
            if doc_types is None:
                doc_types = [DocType.API, DocType.USER_GUIDE, DocType.DEVELOPER_GUIDE]
            if console:
                console.print(
                    Panel(
                        f"üìö RFS v4 Î¨∏ÏÑú ÏûêÎèô ÏÉùÏÑ± ÏãúÏûë\n\nüìÅ Ï∂úÎ†• ÎîîÎ†âÌÜ†Î¶¨: {self.output_path}\nüìÑ ÌòïÏãù: {', '.join([f.value for f in self.config.formats])}\nüåç Ïñ∏Ïñ¥: {self.config.language}\nüìã Î¨∏ÏÑú Ïú†Ìòï: {len(doc_types)}Í∞ú",
                        title="Î¨∏ÏÑú ÏÉùÏÑ±",
                        border_style="blue",
                    )
                )
            self.output_path.mkdir(parents=True, exist_ok=True)
            generated_docs = {}
            with Progress(
                SpinnerColumn(),
                TextColumn("[progress.description]{task.description}"),
                BarColumn(),
                console=console,
            ) as progress:
                for doc_type in doc_types:
                    task = progress.add_task(
                        f"{doc_type.value} Î¨∏ÏÑú ÏÉùÏÑ± Ï§ë...", total=100
                    )
                    match doc_type:
                        case DocType.API:
                            result = await self._generate_api_docs()
                        case DocType.USER_GUIDE:
                            result = await self._generate_user_guide()
                        case DocType.DEVELOPER_GUIDE:
                            result = await self._generate_developer_guide()
                        case DocType.ARCHITECTURE:
                            result = await self._generate_architecture_docs()
                        case DocType.TUTORIAL:
                            result = await self._generate_tutorial()
                        case DocType.REFERENCE:
                            result = await self._generate_reference()
                        case DocType.CHANGELOG:
                            result = await self._generate_changelog()
                        case _:
                            result = Failure(f"ÏßÄÏõêÌïòÏßÄ ÏïäÎäî Î¨∏ÏÑú Ïú†Ìòï: {doc_type}")
                    if result.is_success():
                        generated_docs[doc_type.value] = {
                            doc_type.value: result.unwrap()
                        }
                    progress = {**progress, **task}
            if self.config.generate_index:
                await self._generate_index_page(generated_docs)
            if console:
                console.print(
                    Panel(
                        f"‚úÖ Î¨∏ÏÑú ÏÉùÏÑ± ÏôÑÎ£å!\n\nüìÅ ÏÉùÏÑ±Îêú Î¨∏ÏÑú: {len(generated_docs)}Í∞ú\nüìÇ ÏúÑÏπò: {self.output_path.absolute()}\n\nüåê Î∏åÎùºÏö∞Ï†ÄÏóêÏÑú Î≥¥Í∏∞:\n  file://{(self.output_path / 'index.html').absolute()}",
                        title="Î¨∏ÏÑú ÏÉùÏÑ± ÏôÑÎ£å",
                        border_style="green",
                    )
                )
            return Success(generated_docs)
        except Exception as e:
            return Failure(f"Î¨∏ÏÑú ÏÉùÏÑ± Ïã§Ìå®: {str(e)}")

    async def _generate_api_docs(self) -> Result[str, str]:
        """API Î¨∏ÏÑú ÏÉùÏÑ±"""
        try:
            modules = await self._analyze_python_modules()
            api_content = self._render_api_template(modules)
            for format_type in self.config.formats:
                if format_type == DocFormat.MARKDOWN:
                    api_file = self.output_path / "api.md"
                    api_file.write_text(api_content, encoding="utf-8")
                elif format_type == DocFormat.HTML:
                    html_content = self._markdown_to_html(api_content)
                    api_file = self.output_path / "api.html"
                    api_file.write_text(html_content, encoding="utf-8")
            return Success(str(api_file))
        except Exception as e:
            return Failure(f"API Î¨∏ÏÑú ÏÉùÏÑ± Ïã§Ìå®: {str(e)}")

    async def _analyze_python_modules(self) -> List[Dict[str, Any]]:
        """Python Î™®Îìà Î∂ÑÏÑù"""
        modules = []
        try:
            python_files = list(self.project_path.rglob("*.py"))
            for py_file in python_files:
                if py_file.name.startswith("__"):
                    continue
                try:
                    module_info = await self._analyze_module(py_file)
                    if module_info:
                        modules = modules + [module_info]
                except Exception as e:
                    if console:
                        console.print(
                            f"‚ö†Ô∏è  Î™®Îìà Î∂ÑÏÑù Ïã§Ìå® {py_file}: {str(e)}", style="yellow"
                        )
        except Exception as e:
            if console:
                console.print(f"‚ö†Ô∏è  Î™®Îìà Î∂ÑÏÑù Ï§ë Ïò§Î•ò: {str(e)}", style="yellow")
        return modules

    async def _analyze_module(self, py_file: Path) -> Optional[Dict[str, Any]]:
        """Í∞úÎ≥Ñ Î™®Îìà Î∂ÑÏÑù"""
        try:
            content = py_file.read_text(encoding="utf-8")
            tree = ast.parse(content)
            module_info = {
                "name": py_file.stem,
                "path": str(py_file.relative_to(self.project_path)),
                "docstring": ast.get_docstring(tree),
                "classes": [],
                "functions": [],
                "imports": [],
            }
            for node in ast.walk(tree):
                if type(node).__name__ == "ClassDef":
                    class_info = {
                        "name": node.name,
                        "docstring": ast.get_docstring(node),
                        "methods": [],
                        "line_number": node.lineno,
                    }
                    for item in node.body:
                        if type(item).__name__ == "FunctionDef":
                            method_info = {
                                "name": item.name,
                                "docstring": ast.get_docstring(item),
                                "args": [arg.arg for arg in item.args.args],
                                "line_number": item.lineno,
                                "is_async": type(item).__name__ == "AsyncFunctionDef",
                            }
                            class_info["methods"] = class_info.get("methods") + [
                                method_info
                            ]
                    module_info["classes"] = module_info.get("classes") + [class_info]
                elif type(node).__name__ in ["FunctionDef", "AsyncFunctionDef"]:
                    if not any(
                        (
                            type(parent).__name__ == "ClassDef"
                            for parent in ast.walk(tree)
                            if hasattr(parent, "body")
                            and node in getattr(parent, "body", [])
                        )
                    ):
                        function_info = {
                            "name": node.name,
                            "docstring": ast.get_docstring(node),
                            "args": [arg.arg for arg in node.args.args],
                            "line_number": node.lineno,
                            "is_async": type(node).__name__ == "AsyncFunctionDef",
                        }
                        module_info["functions"] = module_info.get("functions") + [
                            function_info
                        ]
                elif type(node).__name__ in ["Import", "ImportFrom"]:
                    if type(node).__name__ == "Import":
                        for alias in node.names:
                            module_info["imports"] = module_info.get("imports") + [
                                alias.name
                            ]
                    elif node.module:
                        module_info["imports"] = module_info.get("imports") + [
                            node.module
                        ]
            return module_info
        except Exception as e:
            return None

    def _render_api_template(self, modules: List[Dict[str, Any]]) -> str:
        """API Î¨∏ÏÑú ÌÖúÌîåÎ¶ø Î†åÎçîÎßÅ"""
        content = f"# {self.config.project_info.get('name', 'Project')} API Î¨∏ÏÑú\n\n{self.config.project_info.get('description', '')}\n\n**Î≤ÑÏ†Ñ:** {self.config.project_info.get('version', '1.0.0')}  \n**ÏÉùÏÑ±Ïùº:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n---\n\n## Î™©Ï∞®\n\n"
        for module in modules:
            content = content + f"- [{module['name']}](#{module['name'].lower()})\n"
            for cls in module.get("classes"):
                content = content + f"  - [{cls['name']}](#{cls['name'].lower()})\n"
            for func in module.get("functions"):
                content = content + f"  - [{func['name']}()](#{func['name'].lower()})\n"
        content = content + "\n---\n\n"
        for module in modules:
            content = content + f"## {module['name']}\n\n"
            if module.get("docstring"):
                content = content + f"{module['docstring']}\n\n"
            content = content + f"**ÌååÏùº:** `{module['path']}`\n\n"
            if module.get("imports"):
                content = content + "**ÏùòÏ°¥ÏÑ±:**\n"
                for imp in module.get("imports"):
                    content = content + f"- `{imp}`\n"
                content = content + "\n"
            for cls in module.get("classes"):
                content = content + f"### {cls['name']}\n\n"
                if cls.get("docstring"):
                    content = content + f"{cls['docstring']}\n\n"
                if cls.get("methods"):
                    content = content + "**Î©îÏÑúÎìú:**\n\n"
                    for method in cls.get("methods"):
                        async_marker = "async " if method["is_async"] else ""
                        args_str = ", ".join(method["args"]) if method["args"] else ""
                        content = (
                            content
                            + f"#### {async_marker}`{method['name']}({args_str})`\n\n"
                        )
                        if method.get("docstring"):
                            content = content + f"{method['docstring']}\n\n"
                        else:
                            content = content + "Î¨∏ÏÑúÌôîÎêòÏßÄ ÏïäÏùÄ Î©îÏÑúÎìúÏûÖÎãàÎã§.\n\n"
            for func in module.get("functions"):
                async_marker = "async " if func["is_async"] else ""
                args_str = ", ".join(func["args"]) if func["args"] else ""
                content = (
                    content + f"### {async_marker}`{func['name']}({args_str})`\n\n"
                )
                if func.get("docstring"):
                    content = content + f"{func['docstring']}\n\n"
                else:
                    content = content + "Î¨∏ÏÑúÌôîÎêòÏßÄ ÏïäÏùÄ Ìï®ÏàòÏûÖÎãàÎã§.\n\n"
            content = content + "---\n\n"
        return content

    async def _generate_user_guide(self) -> Result[str, str]:
        """ÏÇ¨Ïö©Ïûê Í∞ÄÏù¥Îìú ÏÉùÏÑ±"""
        try:
            project_name = self.config.project_info.get("name", "Project")
            project_description = self.config.project_info.get("description", "")
            project_package = self.config.project_info.get("name", "project").lower()
            current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

            guide_content = f"""# {project_name} ÏÇ¨Ïö©Ïûê Í∞ÄÏù¥Îìú

{project_description}

## Îπ†Î•∏ ÏãúÏûë

### 1. ÏÑ§Ïπò

```bash
pip install {project_package}
```

### 2. Í∏∞Î≥∏ ÏÇ¨Ïö©Î≤ï

```python
from {project_package} import RFSConfig

# Í∏∞Î≥∏ ÏÑ§Ï†ï
config = RFSConfig()

# Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò ÏãúÏûë
app = RFSApplication(config)
await app.start()
```

### 3. ÏÑ§Ï†ï

ÌôòÍ≤Ω Î≥ÄÏàòÎ•º ÌÜµÌï¥ Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖòÏùÑ ÏÑ§Ï†ïÌï† Ïàò ÏûàÏäµÎãàÎã§:

```env
RFS_ENVIRONMENT=production
RFS_DEBUG=false
RFS_LOG_LEVEL=INFO
```

## Ï£ºÏöî Í∏∞Îä•

### Result Pattern

RFS FrameworkÎäî Ìï®ÏàòÌòï ÌîÑÎ°úÍ∑∏ÎûòÎ∞çÏùò Result Ìå®ÌÑ¥ÏùÑ ÏÇ¨Ïö©Ìï©ÎãàÎã§:

```python
from rfs import Result, Success, Failure

def divide(a: int, b: int) -> Result[float, str]:
    if b == 0:
        return Failure("0ÏúºÎ°ú ÎÇòÎàå Ïàò ÏóÜÏäµÎãàÎã§")
    return Success(a / b)

result = divide(10, 2)
if result.is_success():
    print(f"Í≤∞Í≥º: {{result.unwrap()}}")
else:
    print(f"Ïò§Î•ò: {{result.unwrap_err()}}")
```

### Cloud Run ÌÜµÌï©

Google Cloud RunÏóê ÏµúÏ†ÅÌôîÎêú Í∏∞Îä•Îì§:

```python
from rfs.cloud_run import initialize_cloud_run_services

# Cloud Run ÏÑúÎπÑÏä§ Ï¥àÍ∏∞Ìôî
await initialize_cloud_run_services(
    project_id="your-project",
    service_name="your-service"
)
```

## Í≥†Í∏â ÏÇ¨Ïö©Î≤ï

### ÏÑúÎπÑÏä§ Îì±Î°ù

```python
from rfs import stateless

@stateless
class UserService:
    async def get_user(self, user_id: str) -> Result[User, str]:
        # ÏÇ¨Ïö©Ïûê Ï°∞Ìöå Î°úÏßÅ
        pass
```

### Ïù¥Î≤§Ìä∏ ÏãúÏä§ÌÖú

```python
from rfs import get_event_bus, event_handler

@event_handler("user_created")
async def handle_user_created(event):
    print(f"ÏÉà ÏÇ¨Ïö©Ïûê ÏÉùÏÑ±Îê®: {{event.data}}")

# Ïù¥Î≤§Ìä∏ Î∞úÏÉù
await get_event_bus().publish("user_created", {{"user_id": "123"}})
```

## Î¨∏Ï†ú Ìï¥Í≤∞

### ÏùºÎ∞òÏ†ÅÏù∏ Ïò§Î•ò

1. **ÏÑ§Ï†ï Ïò§Î•ò**: `.env` ÌååÏùº ÌôïÏù∏
2. **ÏùòÏ°¥ÏÑ± Ïò§Î•ò**: `pip install -r requirements.txt` Ïã§Ìñâ
3. **Ìè¨Ìä∏ Ï∂©Îèå**: `RFS_PORT` ÌôòÍ≤Ω Î≥ÄÏàò ÏÑ§Ï†ï

### ÎîîÎ≤ÑÍπÖ

```bash
# ÎîîÎ≤ÑÍ∑∏ Î™®ÎìúÎ°ú Ïã§Ìñâ
RFS_DEBUG=true python main.py

# Î°úÍ∑∏ Î†àÎ≤® ÏÑ§Ï†ï
RFS_LOG_LEVEL=DEBUG python main.py
```

## API Ï∞∏Ï°∞

ÏûêÏÑ∏Ìïú API Î¨∏ÏÑúÎäî [API Î¨∏ÏÑú](api.md)Î•º Ï∞∏Ï°∞ÌïòÏÑ∏Ïöî.

---

ÏÉùÏÑ±Ïùº: {current_time}
"""
            guide_file = self.output_path / "user-guide.md"
            guide_file.write_text(guide_content, encoding="utf-8")
            if DocFormat.HTML in self.config.formats:
                html_content = self._markdown_to_html(guide_content)
                html_file = self.output_path / "user-guide.html"
                html_file.write_text(html_content, encoding="utf-8")
            return Success(str(guide_file))
        except Exception as e:
            return Failure(f"ÏÇ¨Ïö©Ïûê Í∞ÄÏù¥Îìú ÏÉùÏÑ± Ïã§Ìå®: {str(e)}")

    async def _generate_developer_guide(self) -> Result[str, str]:
        """Í∞úÎ∞úÏûê Í∞ÄÏù¥Îìú ÏÉùÏÑ±"""
        try:
            # ÌîÑÎ°úÏ†ùÌä∏ Ï†ïÎ≥¥ Ï∂îÏ∂ú
            project_name = self.config.project_info.get("name", "Project")
            project_package = self.config.project_info.get("name", "project").lower()
            current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

            # Í∞úÎ∞úÏûê Í∞ÄÏù¥Îìú ÌÖúÌîåÎ¶ø
            dev_guide_content = f"""# {project_name} Í∞úÎ∞úÏûê Í∞ÄÏù¥Îìú

Ïù¥ Î¨∏ÏÑúÎäî {project_name} ÌîÑÎ°úÏ†ùÌä∏Ïùò Í∞úÎ∞úÏóê Ï∞∏Ïó¨ÌïòÎäî Í∞úÎ∞úÏûêÎì§ÏùÑ ÏúÑÌïú Í∞ÄÏù¥ÎìúÏûÖÎãàÎã§.

## Í∞úÎ∞ú ÌôòÍ≤Ω ÏÑ§Ï†ï

### ÌïÑÏàò ÏöîÍµ¨ÏÇ¨Ìï≠

- Python 3.10+
- Docker
- Google Cloud SDK (Cloud Run ÏÇ¨Ïö© Ïãú)

### Í∞úÎ∞ú ÌôòÍ≤Ω Íµ¨Ï∂ï

```bash
# Ï†ÄÏû•ÏÜå ÌÅ¥Î°†
git clone <repository-url>
cd {project_package}

# Í∞ÄÏÉÅ ÌôòÍ≤Ω ÏÉùÏÑ±
python -m venv venv
source venv/bin/activate  # Windows: venv\\Scripts\\activate

# ÏùòÏ°¥ÏÑ± ÏÑ§Ïπò
pip install -r requirements.txt
pip install -r requirements-dev.txt

# Í∞úÎ∞ú ÏÑúÎ≤Ñ Ïã§Ìñâ
python main.py
```

## ÌîÑÎ°úÏ†ùÌä∏ Íµ¨Ï°∞

```
{project_name}/
‚îú‚îÄ‚îÄ {project_package}/
‚îÇ   ‚îú‚îÄ‚îÄ core/           # ÌïµÏã¨ Î™®Îìà
‚îÇ   ‚îú‚îÄ‚îÄ cloud_run/      # Cloud Run Ï†ÑÏö© Í∏∞Îä•
‚îÇ   ‚îú‚îÄ‚îÄ cli/           # CLI ÎèÑÍµ¨
‚îÇ   ‚îî‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ tests/             # ÌÖåÏä§Ìä∏ ÏΩîÎìú
‚îú‚îÄ‚îÄ docs/              # Î¨∏ÏÑú
‚îú‚îÄ‚îÄ requirements.txt   # ÏùòÏ°¥ÏÑ±
‚îî‚îÄ‚îÄ main.py           # ÏßÑÏûÖÏ†ê
```

## Í∞úÎ∞ú Í∞ÄÏù¥ÎìúÎùºÏù∏

### ÏΩîÎî© Ïä§ÌÉÄÏùº

- **Ìè¨Îß§ÌÑ∞**: Black
- **Î¶∞ÌÑ∞**: Ruff
- **ÌÉÄÏûÖ Ï≤¥ÌÅ¨**: MyPy
- **Ï£ºÏÑù**: ÌïúÍµ≠Ïñ¥ ÏÇ¨Ïö©

```python
def calculate_score(user_id: str, metrics: Dict[str, float]) -> Result[float, str]:
    \"\"\"
    ÏÇ¨Ïö©Ïûê Ï†êÏàò Í≥ÑÏÇ∞
    
    Args:
        user_id: ÏÇ¨Ïö©Ïûê ID
        metrics: Î©îÌä∏Î¶≠ Îç∞Ïù¥ÌÑ∞
        
    Returns:
        Result[float, str]: Í≥ÑÏÇ∞Îêú Ï†êÏàò ÎòêÎäî Ïò§Î•ò Î©îÏãúÏßÄ
    \"\"\"
    if not user_id:
        return Failure("ÏÇ¨Ïö©Ïûê IDÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§")
    
    # Ï†êÏàò Í≥ÑÏÇ∞ Î°úÏßÅ
    score = sum(metrics.values()) / len(metrics)
    return Success(score)
```

### Git ÏõåÌÅ¨ÌîåÎ°úÏö∞

1. **Î∏åÎûúÏπò ÏÉùÏÑ±**: `feature/Í∏∞Îä•Î™Ö` ÎòêÎäî `bugfix/Ïù¥ÏäàÎ≤àÌò∏`
2. **Ïª§Î∞ã Î©îÏãúÏßÄ**: `feat: Í∏∞Îä• Ï∂îÍ∞Ä` ÌòïÏãù
3. **Pull Request**: ÏΩîÎìú Î¶¨Î∑∞ ÌõÑ Î≥ëÌï©
4. **ÌÖåÏä§Ìä∏**: Î™®Îì† ÌÖåÏä§Ìä∏ ÌÜµÍ≥º ÌïÑÏàò

### ÌÖåÏä§Ìä∏ ÏûëÏÑ±

```python
import pytest
from rfs import Result, Success, Failure

@stateless
class TestUserService:
    @pytest.mark.asyncio
    async def test_get_user_success(self):
        # Given
        user_service = UserService()
        user_id = "test_user"
        
        # When
        result = await user_service.get_user(user_id)
        
        # Then
        assert result.is_success()
        user = result.unwrap()
        assert user.id == user_id
```

## Î∞∞Ìè¨ Í∞ÄÏù¥Îìú

### Î°úÏª¨ ÌÖåÏä§Ìä∏

```bash
# Îã®ÏúÑ ÌÖåÏä§Ìä∏
pytest tests/

# ÌÜµÌï© ÌÖåÏä§Ìä∏  
pytest tests/integration/

# ÏΩîÎìú ÌíàÏßà Í≤ÄÏÇ¨
ruff check .
black --check .
mypy .
```

### Cloud Run Î∞∞Ìè¨

```bash
# Docker ÎπåÎìú
docker build -t gcr.io/project-id/app:latest .

# Ïù¥ÎØ∏ÏßÄ Ìë∏Ïãú
docker push gcr.io/project-id/app:latest

# Cloud Run Î∞∞Ìè¨
gcloud run deploy app \\
  --image gcr.io/project-id/app:latest \\
  --region asia-northeast3 \\
  --allow-unauthenticated
```

## ÏïÑÌÇ§ÌÖçÏ≤ò

### ÌïµÏã¨ ÏõêÏπô

1. **Ìï®ÏàòÌòï ÌîÑÎ°úÍ∑∏ÎûòÎ∞ç**: Result Ìå®ÌÑ¥ ÏÇ¨Ïö©
2. **ÏùòÏ°¥ÏÑ± Ï£ºÏûÖ**: stateless Îç∞ÏΩîÎ†àÏù¥ÌÑ∞ ÌôúÏö©
3. **ÎπÑÎèôÍ∏∞ Ï≤òÎ¶¨**: async/await Ìå®ÌÑ¥
4. **ÌÉÄÏûÖ ÏïàÏ†ÑÏÑ±**: Í∞ïÌïú ÌÉÄÏûÖ ÌûåÌä∏

### Î™®Îìà Íµ¨Ï°∞

- `core/`: ÌïµÏã¨ Í∏∞Îä• (Result, Config, Services)
- `cloud_run/`: Cloud Run Ï†ÑÏö© Í∏∞Îä•
- `cli/`: Î™ÖÎ†πÌñâ ÎèÑÍµ¨
- `reactive/`: Î¶¨Ïï°Ìã∞Î∏å Ïä§Ìä∏Î¶º
- `events/`: Ïù¥Î≤§Ìä∏ ÏãúÏä§ÌÖú

## Í∏∞Ïó¨ Î∞©Î≤ï

1. **Ïù¥Ïäà ÌôïÏù∏**: GitHub IssuesÏóêÏÑú ÏûëÏóÖÌï† Ìï≠Î™© ÏÑ†ÌÉù
2. **Î∏åÎûúÏπò ÏÉùÏÑ±**: Í∏∞Îä•Î≥Ñ Î∏åÎûúÏπò ÏÉùÏÑ±
3. **Í∞úÎ∞ú**: Í∞ÄÏù¥ÎìúÎùºÏù∏Ïóê Îî∞Îùº ÏΩîÎìú ÏûëÏÑ±
4. **ÌÖåÏä§Ìä∏**: Ï∂©Î∂ÑÌïú ÌÖåÏä§Ìä∏ ÏûëÏÑ±
5. **Pull Request**: ÏΩîÎìú Î¶¨Î∑∞ ÏöîÏ≤≠

## Î¨∏Ï†ú Ìï¥Í≤∞

### Í∞úÎ∞ú ÌôòÍ≤Ω Î¨∏Ï†ú

- Python Î≤ÑÏ†Ñ ÌôïÏù∏: `python --version`
- ÏùòÏ°¥ÏÑ± Ïû¨ÏÑ§Ïπò: `pip install -r requirements.txt --force-reinstall`
- Í∞ÄÏÉÅ ÌôòÍ≤Ω Ïû¨ÏÉùÏÑ±: `rm -rf venv && python -m venv venv`

### ÌÖåÏä§Ìä∏ Ïã§Ìå®

- Í∞úÎ≥Ñ ÌÖåÏä§Ìä∏ Ïã§Ìñâ: `pytest tests/test_specific.py -v`
- ÌÖåÏä§Ìä∏ ÎîîÎ≤ÑÍπÖ: `pytest --pdb`
- Ïª§Î≤ÑÎ¶¨ÏßÄ ÌôïÏù∏: `pytest --cov=.`

---

ÏÉùÏÑ±Ïùº: {current_time}
"""
            dev_guide_file = self.output_path / "developer-guide.md"
            dev_guide_file.write_text(dev_guide_content, encoding="utf-8")
            return Success(str(dev_guide_file))
        except Exception as e:
            return Failure(f"Í∞úÎ∞úÏûê Í∞ÄÏù¥Îìú ÏÉùÏÑ± Ïã§Ìå®: {str(e)}")

    async def _generate_index_page(self, generated_docs: Dict[str, str]) -> None:
        """Ïù∏Îç±Ïä§ ÌéòÏù¥ÏßÄ ÏÉùÏÑ±"""
        try:
            index_content = f"# {self.config.project_info.get('name', 'Project')} Î¨∏ÏÑú\n\n{self.config.project_info.get('description', '')}\n\n## Î¨∏ÏÑú Î™©Î°ù\n\n"
            for doc_type, doc_path in generated_docs.items():
                doc_name = {
                    "api": "API Ï∞∏Ï°∞",
                    "user_guide": "ÏÇ¨Ïö©Ïûê Í∞ÄÏù¥Îìú",
                    "developer_guide": "Í∞úÎ∞úÏûê Í∞ÄÏù¥Îìú",
                    "architecture": "ÏïÑÌÇ§ÌÖçÏ≤ò Î¨∏ÏÑú",
                    "tutorial": "ÌäúÌÜ†Î¶¨Ïñº",
                    "reference": "Î†àÌçºÎü∞Ïä§",
                }.get(doc_type, doc_type.title())
                filename = Path(doc_path).name
                index_content = index_content + f"- [{doc_name}]({filename})\n"
            index_content = (
                index_content
                + f"\n\n## ÌîÑÎ°úÏ†ùÌä∏ Ï†ïÎ≥¥\n\n- **Î≤ÑÏ†Ñ**: {self.config.project_info.get('version', '1.0.0')}\n- **ÏûëÏÑ±Ïûê**: {self.config.project_info.get('author', 'Unknown')}\n- **ÏÉùÏÑ±Ïùº**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n---\n\nÏù¥ Î¨∏ÏÑúÎäî RFS v4 Î¨∏ÏÑú ÏÉùÏÑ±Í∏∞Î°ú ÏûêÎèô ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§.\n"
            )
            index_file = self.output_path / "index.md"
            index_file.write_text(index_content, encoding="utf-8")
            if DocFormat.HTML in self.config.formats:
                html_content = self._markdown_to_html(index_content)
                html_file = self.output_path / "index.html"
                html_file.write_text(html_content, encoding="utf-8")
        except Exception as e:
            if console:
                console.print(f"‚ö†Ô∏è  Ïù∏Îç±Ïä§ ÌéòÏù¥ÏßÄ ÏÉùÏÑ± Ïã§Ìå®: {str(e)}", style="yellow")

    def _markdown_to_html(self, markdown_content: str) -> str:
        """MarkdownÏùÑ HTMLÎ°ú Î≥ÄÌôò"""
        try:
            html_template = f"""<!DOCTYPE html>\n<html lang="{self.config.language}">\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>{self.config.project_info.get('name', 'Documentation')}</title>\n    <style>\n        body {{ font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; \n               line-height: 1.6; color: #333; max-width: 800px; margin: 0 auto; padding: 20px; }}\n        h1, h2, h3 {{ color: #2563eb; }}\n        code {{ background: #f1f5f9; padding: 2px 4px; border-radius: 4px; }}\n        pre {{ background: #f8fafc; padding: 16px; border-radius: 8px; overflow-x: auto; }}\n        blockquote {{ border-left: 4px solid #e2e8f0; margin: 0; padding: 0 16px; }}\n    </style>\n</head>\n<body>\n    <div id="content">\n        {self._simple_markdown_to_html(markdown_content)}\n    </div>\n</body>\n</html>"""
            return html_template
        except Exception:
            return f"<html><body><pre>{markdown_content}</pre></body></html>"

    def _simple_markdown_to_html(self, text: str) -> str:
        """Í∞ÑÎã®Ìïú Markdown -> HTML Î≥ÄÌôò"""
        lines = text.split("\n")
        html_lines = []
        for line in lines:
            line = line.strip()
            if not line:
                html_lines = html_lines + ["<br>"]
            elif line.startswith("# "):
                html_lines = html_lines + [f"<h1>{line[2:]}</h1>"]
            elif line.startswith("## "):
                html_lines = html_lines + [f"<h2>{line[3:]}</h2>"]
            elif line.startswith("### "):
                html_lines = html_lines + [f"<h3>{line[4:]}</h3>"]
            elif line.startswith("- "):
                html_lines = html_lines + [f"<li>{line[2:]}</li>"]
            elif line.startswith("```"):
                if line.endswith("```"):
                    html_lines = html_lines + ["<code>"]
                else:
                    html_lines = html_lines + ["<pre><code>"]
            else:
                html_lines = html_lines + [f"<p>{line}</p>"]
        return "\n".join(html_lines)

    async def get_documentation_status(self) -> Dict[str, Any]:
        """Î¨∏ÏÑú ÏÉùÏÑ± ÏÉÅÌÉú Ï°∞Ìöå"""
        try:
            status = {
                "output_directory": str(self.output_path.absolute()),
                "formats": [f.value for f in self.config.formats],
                "project_info": self.config.project_info,
                "generated_files": [],
            }
            if self.output_path.exists():
                for file in self.output_path.glob("*"):
                    if file.is_file():
                        status["generated_files"] = status.get(
                            "generated_files", []
                        ) + [
                            {
                                "name": file.name,
                                "size": file.stat().st_size,
                                "modified": datetime.fromtimestamp(
                                    file.stat().st_mtime
                                ).isoformat(),
                            }
                        ]
            return status
        except Exception as e:
            return {"error": str(e)}
