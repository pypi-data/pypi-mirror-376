Metadata-Version: 2.4
Name: holobit-sdk
Version: 1.0.9
Summary: SDK para arquitectura hologr√°fica avanzada
Home-page: https://github.com/Alphonsus411/holobit_SDK
Author: Adolfo Gonz√°lez Hern√°ndez
Author-email: Adolfo Gonz√°lez Hern√°ndez <adolfogonzal@gmail.com>
License: MIT
Requires-Python: >=3.10
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: numpy
Requires-Dist: matplotlib
Provides-Extra: qiskit
Requires-Dist: qiskit; extra == "qiskit"
Provides-Extra: pennylane
Requires-Dist: pennylane; extra == "pennylane"
Provides-Extra: aws
Requires-Dist: boto3; extra == "aws"
Provides-Extra: azure
Requires-Dist: azure-identity; extra == "azure"
Provides-Extra: gcp
Requires-Dist: google-cloud-compute; extra == "gcp"
Dynamic: author
Dynamic: home-page
Dynamic: license-file
Dynamic: requires-python


# Holobit SDK - Documentaci√≥n Oficial

## üìå Introducci√≥n
El **Holobit SDK** es un kit de desarrollo dise√±ado para la transpilaci√≥n y ejecuci√≥n de c√≥digo hologr√°fico cu√°ntico. Su arquitectura multinivel permite trabajar con diferentes niveles de abstracci√≥n, optimizando el rendimiento en m√∫ltiples arquitecturas de hardware.

## üîπ Caracter√≠sticas Principales
- **Transpilador Cu√°ntico Hologr√°fico**: Convierte c√≥digo HoloLang en c√≥digo m√°quina optimizado para arquitecturas x86, ARM y RISC-V.
- **Backends C/C++, Rust y Go**: Traducen programas HoloLang a c√≥digo cl√°sico en C, C++, Rust o Go, permitiendo un flujo tradicional de compilaci√≥n.
- **Optimizaci√≥n Avanzada**: Reduce instrucciones redundantes y reutiliza registros para maximizar la eficiencia.
- **Ejecuci√≥n Multinivel**: Soporte para bajo, medio y alto nivel en la programaci√≥n hologr√°fica.
- **Compatibilidad con M√∫ltiples Arquitecturas**: x86, ARM y RISC-V.
- **Integraci√≥n con frameworks cu√°nticos**: Qiskit, PennyLane, Cirq, AWS Braket y QuTiP.

## üì• Instalaci√≥n
Para instalar el SDK Holobit, sigue los siguientes pasos:

### üîπ Requisitos Previos
- **Python >=3.10** (versi√≥n m√≠nima recomendada)
- **pip** actualizado
- **Git (opcional, pero recomendado)**

### üîπ Instalaci√≥n desde GitHub
```bash
# Clonar el repositorio
git clone https://github.com/usuario/holobit_sdk.git
cd holobit_sdk

# Instalar dependencias
pip install -r requirements_optional.txt
# Para tareas de desarrollo instala tambi√©n las dependencias de 
# linting y cobertura
pip install -r requirements_dev.txt
```

## üöÄ Uso del SDK
### üîπ Transpilaci√≥n de C√≥digo HoloLang
Para transpilar un archivo de c√≥digo hologr√°fico:
```bash
holobit-transpiler --input archivo.holo --arch x86
```
Tambi√©n puedes ejecutarlo con el m√≥dulo de Python:
```bash
python -m holobit_sdk.transpiler.machine_code_transpiler --input archivo.holo --arch x86
```
Esto generar√° un archivo con el c√≥digo m√°quina optimizado para la arquitectura especificada.

### üîπ Ejemplo de Uso en C√≥digo
```python
from transpiler.machine_code_transpiler import MachineCodeTranspiler

transpiler = MachineCodeTranspiler("x86")
instruccion = "ADD H1 H2"
codigo_maquina = transpiler.transpile(instruccion)
print(codigo_maquina)  # ADD H1, H2 ; Registro reutilizado
```

Puedes encontrar m√°s demostraciones en el directorio `examples/`.

### üîπ Integraci√≥n con Cirq, Braket y QuTiP
Los holobits pueden ejecutarse en diferentes frameworks cu√°nticos mediante adaptadores.

```python
from holobit_sdk.quantum_integration import CirqAdapter, BraketAdapter, QutipAdapter

adapter = CirqAdapter()  # Tambi√©n BraketAdapter o QutipAdapter
circuito = adapter.holobit_to_native(holobit)
resultado = adapter.execute(circuito)
```

Cada adaptador convierte el ``Holobit`` a la representaci√≥n nativa del backend y devuelve el estado resultante tras la ejecuci√≥n.

## üåê Servicio Web de Compilaci√≥n y Ejecuci√≥n
El SDK incluye un servicio REST basado en FastAPI para compilar y ejecutar Holobits mediante los backends definidos en `holobit_sdk.cloud`.

### Configuraci√≥n
- `HOLOBIT_PORT`: puerto del servidor (por defecto 8000).
- `HOLOBIT_BACKEND`: backend a utilizar (`aws`, `azure` o `gcp`).
- `HOLOBIT_USER` y `HOLOBIT_PASSWORD_HASH`: usuario y hash `bcrypt` de la contrase√±a.

### Proveedores de secretos
Los backends `AWSBackend` y `AzureBackend` pueden recibir un objeto que
implemente la interfaz `CredentialsProvider` para obtener credenciales desde
servicios externos como *AWS Secrets Manager* o *Azure Key Vault*.

```python
from holobit_sdk.cloud import AWSBackend, CredentialsProvider

class SecretsManagerProvider(CredentialsProvider):
    def get_credentials(self) -> dict[str, str]:
        return {
            "AWS_ACCESS_KEY_ID": "...",
            "AWS_SECRET_ACCESS_KEY": "...",
        }

backend = AWSBackend(provider=SecretsManagerProvider())
```

Si el proveedor no responde o devuelve credenciales incompletas se registrar√°
un error y se lanzar√° `EnvironmentError`.

### Ejecuci√≥n
```bash
export HOLOBIT_BACKEND=aws
export HOLOBIT_USER=usuario
export HOLOBIT_PASSWORD_HASH=$(python - <<'PY'
import bcrypt
print(bcrypt.hashpw(b'secreto', bcrypt.gensalt()).decode())
PY
)
python -m holobit_sdk.api.service
```
Los endpoints disponibles son:
- `POST /compile` con el campo `code` que devuelve `job_id`.
- `POST /execute` con `job_id` que devuelve el resultado.
  El identificador `job_id` acepta hasta 256 caracteres.

### üîê HTTPS opcional
Para cifrar la comunicaci√≥n HTTP puedes generar un certificado y una clave
privada. Por ejemplo, con OpenSSL:

```bash
openssl req -x509 -nodes -newkey rsa:4096 -keyout holobit.key -out holobit.crt -days 365 -subj '/CN=localhost'
```

Antes de iniciar el servicio exporta las rutas de ambos archivos:

```bash
export HOLOBIT_TLS_CERT=holobit.crt
export HOLOBIT_TLS_KEY=holobit.key
python -m holobit_sdk.api.service
```

Si los certificados no est√°n definidos o faltan archivos, el servidor mostrar√°
una advertencia y deber√° desplegarse detr√°s de un proxy HTTPS.

Consulta `examples/clients` para ver ejemplos de clientes en JavaScript y Go.


## üîå Servicio gRPC
Adem√°s del servicio REST, el SDK ofrece un servicio gRPC definido en `api/holobit.proto` con los m√©todos `Compile` y `Execute`.

Para arrancarlo:
```bash
python -m holobit_sdk.api.grpc_service
```
El puerto se puede configurar con la variable `HOLOBIT_PORT` (por defecto 50051).

### üîê TLS opcional
Para cifrar la comunicaci√≥n es necesario generar un certificado y una clave
privada. Por ejemplo, con OpenSSL:

```bash
openssl req -x509 -nodes -newkey rsa:4096 -keyout holobit.key -out holobit.crt -days 365 -subj '/CN=localhost'
```

Antes de iniciar el servicio exporta las rutas de ambos archivos:

```bash
export HOLOBIT_TLS_CERT=holobit.crt
export HOLOBIT_TLS_KEY=holobit.key
python -m holobit_sdk.api.grpc_service
```

Si no se definen estas variables el servidor arrancar√° sin TLS, dejando la
comunicaci√≥n sin cifrar y expuesta a intercepciones; √∫salo solo para
desarrollo.

### üîë Autenticaci√≥n por token
El servidor exige un token compartido para cada llamada gRPC. Genera un valor
aleatorio y exp√≥rtalo antes de iniciar el servicio:

```bash
python - <<'PY'
import secrets; print(secrets.token_hex(32))
PY
export HOLOBIT_GRPC_TOKEN=el_valor_generado
python -m holobit_sdk.api.grpc_service
```

Los clientes autorizados deben incluir el token en la metadata con la clave
`x-holobit-token`:

```python
with grpc.insecure_channel("localhost:50051") as channel:
    stub = holobit_pb2_grpc.HolobitServiceStub(channel)
    metadata = [("x-holobit-token", os.environ["HOLOBIT_GRPC_TOKEN"])]
    stub.Compile(holobit_pb2.CodeRequest(code="..."), metadata=metadata)
```

Las solicitudes sin token o con un valor incorrecto ser√°n rechazadas con el
estado `UNAUTHENTICATED`.

Los clientes en otros lenguajes pueden generarse compilando el archivo `.proto` correspondiente. Por ejemplo, para Python:
```bash
python -m grpc_tools.protoc -I api --python_out=. --grpc_python_out=. api/holobit.proto
```
En C++, Java, Go u otros lenguajes basta con ejecutar `protoc` con el plugin gRPC adecuado y apuntar al mismo archivo `holobit.proto`.


### üîπ Flujo HoloLang ‚Üí C/C++/Rust/Go ‚Üí ensamblador
Adem√°s del c√≥digo m√°quina directo, el compilador permite generar c√≥digo C, C++, Rust o Go a partir de un programa HoloLang, manteniendo un flujo cl√°sico de compilaci√≥n:
```python
from holobit_sdk.multi_level.high_level.compiler import HoloLangCompiler

compiler = HoloLangCompiler("rust")  # tambi√©n "go", "c" o "cpp"
programa = "IMPRIMIR A"
codigo = compiler.compilar_y_ejecutar(programa)
print(codigo)
```
El resultado puede compilarse con `gcc`/`clang`, `rustc` o `go build` para producir ensamblador u objetos binarios.

### üîπ Ejecuci√≥n de HoloLang desde la l√≠nea de comandos
Puedes ejecutar c√≥digo HoloLang directamente con el comando `hololang`:
```bash
hololang -c "CREAR H1 (0.1, 0.2, 0.3)" -c "IMPRIMIR H1"
```
O bien pasar un archivo con varias instrucciones y especificar el backend deseado:
```bash
hololang --file programa.holo --arch rust
```
Esto mostrar√° por pantalla el resultado de cada l√≠nea procesada.

### üîπ M√°quina Virtual del Ensamblador
El m√≥dulo `assembler.virtual_machine` permite ejecutar instrucciones hologr√°ficas en un entorno controlado.
```python
from assembler.virtual_machine import AssemblerVM

vm = AssemblerVM()
programa = ["CREAR Q1 (0.1, 0.2, 0.3)", "CREAR Q2 (0.4, 0.5, 0.6)", "CREAR H1 {Q1, Q2}", "ROT H1 z 90"]
vm.run_program(programa)
```
Las instrucciones del ASIIC pueden escribirse con cualquier combinaci√≥n de may√∫sculas y min√∫sculas. Por ejemplo, `rotar`, `Rotar` y `ROTAR` se interpretan de la misma manera.
#### üß© Macros y alias
El parser incluye un preprocesador que reconoce directivas `#macro` y `#endmacro` para definir plantillas reutilizables:
```asm
#macro CREAR_ROT nombre x y z
CREAR {nombre} ({x}, {y}, {z})
ROTAR {nombre} z 90
#endmacro

CREAR_ROT H1 0.1 0.2 0.3
```
Adem√°s, la m√°quina virtual carga alias al iniciar; por ejemplo `ROTAR` es un alias de `ROT`.
Tambi√©n se incluyen alias como `MEASURE` ‚Üí `MEDIR`, `ENTRELAZAR` ‚Üí `ENTANGLE` y `SUPERPOSICION` ‚Üí `SUPERPOS`.
Las macros pueden eliminarse en tiempo de ejecuci√≥n mediante `assembler.macros.remove_macro("CREAR_ROT")`.
### üîπ Instrucciones cu√°nticas esenciales
Las √∫ltimas versiones del lenguaje incluyen operaciones de nivel cu√°ntico que
pueden combinarse con macros y con la m√°quina virtual:

- **SUPERPOS** *(alias: `SUPERPOSICION`)*: coloca un Holobit o qubit en superposici√≥n.
  ```asm
  CREAR Q1 (0.1, 0.2, 0.3)
  SUPERPOS Q1
  ```
- **MEDIR** *(alias: `MEASURE`)*: colapsa el estado y almacena el resultado en `parser.measurements`.
  ```asm
  MEDIR Q1
  ```
- **ENTANGLE** *(alias: `ENTRELAZAR`)*: entrelaza dos registros, propagando el colapso de uno sobre el otro.
  ```asm
  ENTANGLE Q1 Q2
  ```
- **DECOHERENCIA**: simula la p√©rdida de coherencia devolviendo un estado cl√°sico aleatorio.
  ```asm
  DECOHERENCIA Q1
  ```

### üîπ Manejo de grupos
Los Holobits pueden organizarse en grupos l√≥gicos para operar sobre varios
elementos simult√°neamente:

```asm
CREAR H1 {Q1, Q2}
CREAR H2 {Q3, Q4}
GRUPO G1 {H1, H2}
```

### üîπ Persistencia del estado del Holocron
Es posible guardar y restaurar el conjunto completo de holobits y grupos:

```holo
GUARDAR_ESTADO inicial
# ... realizar operaciones ...
RESTABLECER_ESTADO inicial
```

Estas instrucciones utilizan internamente ``Holocron.save_state`` y
``Holocron.restore_state`` para serializar y recuperar el contenido.

### üîπ Estructuras de control
El ensamblador incorpora instrucciones de alto nivel para controlar el flujo:

- `SI` / `SINO` / `FIN`
- `MIENTRAS` / `FIN`
- `PARA` / `FIN`
- `CASO` / `CUANDO` / `OTRO` / `FINCASO`

```asm
MEDIR H1
SI H1
    ROT H1 z 90
SINO
    ROT H1 z 180
FIN

PARA 3
    ROT H1 x 30
FIN

CASO H1
    CUANDO 0
        ROT H1 y 45
    CUANDO 1
        ROT H1 y 90
    OTRO
        ROT H1 y 180
FINCASO
```

En HoloLang tambi√©n pueden emplearse llaves para definir bloques con
condicionales y estructuras de casos:

```holo
SI condicion {
    INSTRUCCION_A
} SINO {
    INSTRUCCION_B
}

CASO expresion {
    CUANDO 1 {
        ACCION_1
    }
    CUANDO 2 {
        ACCION_2
    }
    OTRO {
        ACCION_DEFECTO
    }
} FINCASO
```

### üîπ Simulaci√≥n de Holobits
El simulador `HologramSimulator` permite mover y rotar Holobits paso a paso,
y visualizar cada estado en 3D.
```python
from holobit_sdk.quantum_holocron.core.hologram_simulator import HologramSimulator
sim = HologramSimulator()
pasos = [{"traslacion": (0.1, 0, 0), "rotacion": ("z", 15)}]
sim.animate(holobit, pasos)
```
### üîπ Interacciones b√°sicas
El m√≥dulo `holobit_sdk.core.interactions` ofrece funciones sencillas para
modificar el estado de los Holobits:

- `confinar_quarks(holobit, limite)`: limita la posici√≥n de cada quark al
  rango ``[-limite, limite]``.
- `cambiar_spin(holobit, nuevo_spin)`: ajusta el valor del *spin* del Holobit.
- `sincronizar_spin(holobits)`: iguala el *spin* de un grupo de Holobits al
  promedio del conjunto.

```python
from holobit_sdk.core import interactions

interactions.confinar_quarks(holobit, limite=0.5)
interactions.cambiar_spin(holobit, 1.0)
```
## üî¨ Arquitectura Interna del SDK
El SDK Holobit est√° estructurado en varios niveles:
1. **Nivel Bajo**: Manejo directo de registros y memoria hologr√°fica.
2. **Nivel Medio**: Procesamiento cu√°ntico hologr√°fico.
3. **Nivel Alto**: Lenguaje de programaci√≥n HoloLang y compilador asociado.

## üìñ Referencia T√©cnica
- **M√≥dulo `transpiler`**: Contiene el transpilador de c√≥digo hologr√°fico a c√≥digo m√°quina.
- **M√≥dulo `execution`**: Maneja la ejecuci√≥n de c√≥digo transpilado en arquitecturas objetivo.
- **M√≥dulo `debugger`**: Herramientas de depuraci√≥n y an√°lisis de c√≥digo transpilado.

## üìÑ Ejemplos de C√≥digo
Los ejemplos del SDK se encuentran en el directorio `examples/` y pueden
ejecutarse directamente con Python. Por ejemplo:
```bash
python examples/holobit_demo.py
python examples/hololang_compiler.py
python examples/hologram_simulation.py
python examples/new_instructions_demo.py
```
Cada script muestra una funcionalidad concreta del SDK. Tambi√©n puedes
utilizar el transpilador de forma manual:
```bash
holobit-transpiler --input ejemplo.holo --arch x86
```
O bien con el m√≥dulo de Python:
```bash
python -m holobit_sdk.transpiler.machine_code_transpiler --input ejemplo.holo --arch x86
```

### Expresiones ampliadas con `SIQ`
La instrucci√≥n `SIQ` permite evaluar los resultados de medici√≥n mediante
expresiones complejas combinando operadores aritm√©ticos y l√≥gicos.
Adem√°s de comparaciones simples entre un grupo y un valor, ahora es
posible evaluar **expresiones completas** utilizando los resultados de
medici√≥n disponibles:

```hololang
SIQ (G1 + G2) > 1 {
    CREAR A (1)
} ELSEQ {
    CREAR B (1)
}
```
Los operadores admitidos incluyen `==`, `!=`, `<`, `>`, `<=` y `>=`, as√≠
como operaciones aritm√©ticas dentro de la expresi√≥n. Asimismo, `SIQ`
soporta combinaciones l√≥gicas mediante `AND`, `OR` y `NOT`, e incluso
agrupar subexpresiones con par√©ntesis para un control detallado.

### DESENTANGLE
La instrucci√≥n `DESENTANGLE` revierte el entrelazamiento entre dos
Holobits, restaurando su independencia y evitando colapsos propagados.
Es especialmente √∫til tras mediciones o manipulaciones intensivas.

```hololang
ENTANGLE Q1 Q2
DESENTANGLE Q1 Q2
```

### Operaciones adicionales con `CANALIZAR`
`CANALIZAR` abre un flujo de control sobre uno o varios Holobits donde se
habilitan operaciones avanzadas como `AMPLIFICAR`, `FILTRAR` y
`REFRACTAR`, las cuales no est√°n disponibles fuera de este contexto.

```hololang
CANALIZAR H1 {
    AMPLIFICAR H1 2;
    FILTRAR H1 z>0;
}
```

### Sintaxis para secuencias de operaciones
Varias instrucciones pueden encadenarse en una sola l√≠nea utilizando el
separador `;`. Esto facilita describir **secuencias de operaciones** que
el int√©rprete ejecutar√° de izquierda a derecha.

```hololang
CREAR Q1 (0.1,0.2,0.3); ROTAR Q1 z 90; MEDIR Q1
```

### Ejemplo combinado seg√∫n el Holocron Cu√°ntico
El siguiente fragmento muestra c√≥mo integrar estas caracter√≠sticas para
mantener la coherencia indicada por el **Holocron Cu√°ntico**:

```hololang
CREAR Q1 (0.1,0.2,0.3); CREAR Q2 (0.4,0.5,0.6)
ENTANGLE Q1 Q2
CANALIZAR {Q1,Q2} {
    AMPLIFICAR Q1 2;
    FILTRAR Q2 x>0;
}
SIQ (MEDIR Q1 + MEDIR Q2) >= 1 AND NOT(MEDIR Q1 == 0) {
    DESENTANGLE Q1 Q2;
    CREAR H1 {Q1, Q2};
} ELSEQ {
    ROTAR Q1 y 45;
}
```

## üåø Fractales Hologr√°ficos

### Concepto, jerarqu√≠as de densidad y reglas morfom√©tricas
Un **fractal hologr√°fico** describe la distribuci√≥n jer√°rquica de densidades dentro de un *Holocron*. Cada nivel genera subniveles con una densidad proporcional que sigue reglas morfom√©tricas, permitiendo explorar la estructura cu√°ntica con una escala autosimilar.

### Uso desde Python
```python
from holobit_sdk.quantum_holocron.core.holocron import Holocron
from holobit_sdk.quantum_holocron.fractal import Fractal
from holobit_sdk.core.holobit import Holobit
from holobit_sdk.core.quark import Quark
from holobit_sdk.visualization.fractal_plot import visualizar_fractal

def _crear_holocron():
    holo = Holocron()
    for i in range(10):
        q = [Quark(0, 0, 0) for _ in range(6)]
        aq = [Quark(0, 0, 0) for _ in range(6)]
        holo.add_holobit(f"hb{i}", Holobit(q, aq, spin=i))
    return holo

holo = _crear_holocron()
fractal = Fractal(holo)
fractal.hierarquia_superior = 20
fractal.generar()
fig, axes = visualizar_fractal(lambda **_: list(fractal.densidades.values()))
```

### Uso desde Hololang
```hololang
CREAR_FRACTAL F1 (densidad_max=20)
GRAFICAR_FRACTAL F1
```
### Sintaxis de las nuevas instrucciones
El SDK incorpora instrucciones espec√≠ficas para trabajar con fractales multidimensionales:

- `CREAR_FRACTAL <id> (densidad_max=<N>, dimensiones=<D>)`: define un fractal con densidad m√°xima `N` y `D` dimensiones.
- `SIMULAR_FRACTAL <id> pasos=<P>`: ejecuta `P` iteraciones sobre el fractal existente.
- `GRAFICAR_FRACTAL <id> modo=<modo>`: muestra el fractal en modo `2D`, `3D` o `animado`.

Ejemplo completo:
```hololang
CREAR_FRACTAL F1 (densidad_max=20, dimensiones=4)
SIMULAR_FRACTAL F1 pasos=10
GRAFICAR_FRACTAL F1 modo=animado
```
## üìù Notas sobre archivos binarios
Los documentos de arquitectura se mantienen en PDF, pero debido a que los archivos binarios dificultan las revisiones, se evita editarlos directamente en el repositorio. Las actualizaciones deben registrarse en formatos de texto o im√°genes vectoriales, generando los PDFs fuera del control de versiones.

## üì¶ Despliegue y Distribuci√≥n
El SDK Holobit ser√° empaquetado y distribuido a trav√©s de **GitHub Releases** y **PyPI**.

### üîπ Construcci√≥n del Paquete
```bash
python setup.py sdist bdist_wheel
```

### üîπ Publicaci√≥n en PyPI
```bash
pip install twine

# Subir el paquete
python -m twine upload dist/*
```

## ‚ûï A√±adir nuevos backends cu√°nticos
Para integrar un nuevo backend cu√°ntico en el SDK:
1. Crea una clase en ``holobit_sdk/quantum_integration`` que herede de ``QuantumAdapter``.
2. Implementa el m√©todo ``holobit_to_native`` para traducir un ``Holobit`` al formato del backend.
3. Implementa ``execute`` para ejecutar la representaci√≥n nativa y devolver su estado.
4. A√±ade pruebas correspondientes en ``holobit_sdk/quantum_integration/tests``.

## ‚òÅÔ∏è Backends en la Nube
El SDK incluye conectores simples para ejecutar trabajos Holobit en servicios de **AWS**, **Azure** y **Google Cloud Platform**.

### Instalaci√≥n de dependencias opcionales
Para cada proveedor instala el extra correspondiente:
```bash
# AWS
pip install .[aws]
# Azure
pip install .[azure]
# GCP
pip install .[gcp]
```

### Variables de entorno requeridas
- **AWS**: `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`
- **Azure**: `AZURE_CLIENT_ID`, `AZURE_TENANT_ID`, `AZURE_CLIENT_SECRET`, `AZURE_SUBSCRIPTION_ID`
- **GCP**: `GOOGLE_APPLICATION_CREDENTIALS` (ruta al archivo de credenciales)

Ejemplo de uso con AWS:
```python
from holobit_sdk.cloud.aws import CloudBackend
backend = CloudBackend()
job_id = backend.submit_job({"payload": "..."})
backend.execute_job(job_id)
```

## üß™ Pruebas
Para ejecutar las pruebas unitarias del proyecto debes instalar las dependencias opcionales.
La suite completa requiere la librer√≠a `qiskit`, incluida en este archivo, para ejecutar las pruebas de integraci√≥n cu√°ntica:
```bash
pip install -r requirements_optional.txt
```
Si adem√°s deseas comprobar la cobertura de c√≥digo instala las dependencias de desarrollo y ejecuta `coverage`:
```bash
pip install -r requirements_dev.txt
```
Luego ejecuta `flake8` para verificar el estilo y `coverage run` junto con `pytest`:
```bash
flake8
coverage run -m pytest
```
Este repositorio cuenta con un flujo de **Integraci√≥n Continua** en GitHub Actions que instala estas dependencias y ejecuta las pruebas en cada *push* y *pull request*.

## ‚ôªÔ∏è Notas de migraci√≥n
Para quienes actualicen desde versiones anteriores de **Hololang**:

- Las instrucciones `SUPERPOS`, `MEDIR` y `ENTANGLE` sustituyen a las antiguas `SUP`, `MEASURE` y `ENTRELACE`.
- La gesti√≥n de grupos se realiza con `GRUPO` en lugar de las primitivas heredadas `SET`.
- Las estructuras de control `SI`/`SINO`/`FIN` y `MIENTRAS`/`FIN` reemplazan a `IF`/`ELSE`/`END`.
- Las macros deben declararse mediante `#macro` y `#endmacro`; la sintaxis `DEFINE` ya no est√° soportada.

## üõ† Mantenimiento y Contribuci√≥n
Si deseas contribuir al SDK Holobit, puedes hacer un **fork** del repositorio y enviar un **pull request** con tus mejoras.

## üìß Contacto y Soporte
Para cualquier consulta, reportes de errores o contribuciones, puedes contactarnos en **adolfogonzal@gmail.com** o a trav√©s del repositorio en **GitHub**.

---

üìå **Holobit SDK - Computaci√≥n Cu√°ntica Hologr√°fica para el Futuro** üöÄ


