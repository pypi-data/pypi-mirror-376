from pathlib import Path
import tempfile, glob
from minecraft_datapack_language.mdl_parser import MDLParser
from minecraft_datapack_language.mdl_compiler import MDLCompiler

mdl_src = r"""
pack "betterworldedit" "Generated by MDL CLI" 82;
namespace "betterworldedit";

// =============================
// Variables
// =============================

// Selection state per-player
var num bwe_pos1_x<@a> = 0;
var num bwe_pos1_y<@a> = 0;
var num bwe_pos1_z<@a> = 0;
var num bwe_pos2_x<@a> = 0;
var num bwe_pos2_y<@a> = 0;
var num bwe_pos2_z<@a> = 0;
var num bwe_pos1_set<@a> = 0;
var num bwe_pos2_set<@a> = 0;

// Derived bounds/dimensions per-player
var num bwe_min_x<@a> = 0;
var num bwe_min_y<@a> = 0;
var num bwe_min_z<@a> = 0;
var num bwe_max_x<@a> = 0;
var num bwe_max_y<@a> = 0;
var num bwe_max_z<@a> = 0;
var num bwe_dim_x<@a> = 0;
var num bwe_dim_y<@a> = 0;
var num bwe_dim_z<@a> = 0;
var num bwe_volume<@a> = 0;

// Config per-player
var num bwe_max_fill<@a> = 30000; // safe default under vanilla fill cap

// Scratch variables (per-player) used in helpers/loops
var num _slice_h<@a> = 0;
var num _base<@a> = 0;
var num _slices<@a> = 0;
var num _y_start<@a> = 0;
var num _y_end<@a> = 0;
var num _xs<@a> = 0;
var num _xe<@a> = 0;
var num _zs<@a> = 0;
var num _ze<@a> = 0;
var num _tile_x<@a> = 0;
var num _tile_z<@a> = 0;
var num _area_limit<@a> = 0;
var num _temp<@a> = 0;

// Selector item usage tracking (two-tool system via custom_data: bwe_selector_1 / bwe_selector_2)
var num bwe_stat_selector<@a> = 0;      // current brush use stat (mirrors objective)
var num bwe_stat_selector_2<@a> = 0;    // mirror for clarity/debug (same value as above)
var num bwe_stat_prev_1<@a> = 0;        // last seen stat when using Pos1 tool
var num bwe_stat_prev_2<@a> = 0;        // last seen stat when using Pos2 tool

// =============================
// Main / Init
// =============================

function betterworldedit:main {
    say "BetterWorldEdit - Commands:";
    say " - /function betterworldedit:pos1 - set position 1 (your current block)";
    say " - /function betterworldedit:pos2 - set position 2 (your current block)";
    say " - /function betterworldedit:info - show selection info";
    say " - /function betterworldedit:set_stone - fill selection with stone (chunked)";
    say " - /function betterworldedit:give_selector - get selector tools (pos1 & pos2)";
    say " - exec betterworldedit:fill_selection '{block:\"minecraft:oak_planks\"}' - fill with any block";
}

function betterworldedit:init {
    say "BetterWorldEdit initialized. Run /function betterworldedit:main";
    // Scoreboard objectives
    $!raw
    scoreboard objectives add bwe_use_selector minecraft.used:minecraft.brush

    scoreboard objectives add bwe_pos1_x dummy
    scoreboard objectives add bwe_pos1_y dummy
    scoreboard objectives add bwe_pos1_z dummy
    scoreboard objectives add bwe_pos2_x dummy
    scoreboard objectives add bwe_pos2_y dummy
    scoreboard objectives add bwe_pos2_z dummy
    scoreboard objectives add bwe_pos1_set dummy
    scoreboard objectives add bwe_pos2_set dummy

    scoreboard objectives add bwe_min_x dummy
    scoreboard objectives add bwe_min_y dummy
    scoreboard objectives add bwe_min_z dummy
    scoreboard objectives add bwe_max_x dummy
    scoreboard objectives add bwe_max_y dummy
    scoreboard objectives add bwe_max_z dummy
    scoreboard objectives add bwe_dim_x dummy
    scoreboard objectives add bwe_dim_y dummy
    scoreboard objectives add bwe_dim_z dummy
    scoreboard objectives add bwe_volume dummy

    scoreboard objectives add bwe_max_fill dummy

    scoreboard objectives add _slice_h dummy
    scoreboard objectives add _base dummy
    scoreboard objectives add _slices dummy
    scoreboard objectives add _y_start dummy
    scoreboard objectives add _y_end dummy
    scoreboard objectives add _xs dummy
    scoreboard objectives add _xe dummy
    scoreboard objectives add _zs dummy
    scoreboard objectives add _ze dummy
    scoreboard objectives add _tile_x dummy
    scoreboard objectives add _tile_z dummy
    scoreboard objectives add _area_limit dummy
    scoreboard objectives add _temp dummy

    scoreboard objectives add bwe_stat_selector dummy
    scoreboard objectives add bwe_stat_selector_2 dummy
    scoreboard objectives add bwe_stat_prev_1 dummy
    scoreboard objectives add bwe_stat_prev_2 dummy
    raw!$
}

// Run on load
on_load betterworldedit:init;

// =============================
// Position capture helpers
// =============================

function betterworldedit:pos1 {
    // Capture player's current block coordinates into pos1
    $!raw
    execute store result score @s bwe_pos1_x run data get entity @s Pos[0] 1
    execute store result score @s bwe_pos1_y run data get entity @s Pos[1] 1
    execute store result score @s bwe_pos1_z run data get entity @s Pos[2] 1
    # Off-by-one fix: if feet are in air, choose block below
    execute if block ~ ~ ~ #minecraft:air run scoreboard players remove @s bwe_pos1_y 1
    raw!$
    bwe_pos1_set<@s> = 1;
    $!raw
    tellraw @s [{"text":"Set pos1 to ("},{"score":{"name":"@s","objective":"bwe_pos1_x"}},{"text":", "},{"score":{"name":"@s","objective":"bwe_pos1_y"}},{"text":", "},{"score":{"name":"@s","objective":"bwe_pos1_z"}},{"text":")"}]
    raw!$
}

function betterworldedit:pos2 {
    // Capture player's current block coordinates into pos2
    $!raw
    execute store result score @s bwe_pos2_x run data get entity @s Pos[0] 1
    execute store result score @s bwe_pos2_y run data get entity @s Pos[1] 1
    execute store result score @s bwe_pos2_z run data get entity @s Pos[2] 1
    # Off-by-one fix: if feet are in air, choose block below
    execute if block ~ ~ ~ #minecraft:air run scoreboard players remove @s bwe_pos2_y 1
    raw!$
    bwe_pos2_set<@s> = 1;
    $!raw
    tellraw @s [{"text":"Set pos2 to ("},{"score":{"name":"@s","objective":"bwe_pos2_x"}},{"text":", "},{"score":{"name":"@s","objective":"bwe_pos2_y"}},{"text":", "},{"score":{"name":"@s","objective":"bwe_pos2_z"}},{"text":")"}]
    raw!$
}

// =============================
// Bounds, dimensions, and info
// =============================

function betterworldedit:_compute_bounds {
    // Mirror missing positions so dims stay valid
    if $bwe_pos1_set<@s>$ == 0 {
        bwe_pos1_x<@s> = $bwe_pos2_x<@s>$;
        bwe_pos1_y<@s> = $bwe_pos2_y<@s>$;
        bwe_pos1_z<@s> = $bwe_pos2_z<@s>$;
    }
    if $bwe_pos2_set<@s>$ == 0 {
        bwe_pos2_x<@s> = $bwe_pos1_x<@s>$;
        bwe_pos2_y<@s> = $bwe_pos1_y<@s>$;
        bwe_pos2_z<@s> = $bwe_pos1_z<@s>$;
    }

    // X bounds
    if $bwe_pos1_x<@s>$ <= $bwe_pos2_x<@s>$ {
        bwe_min_x<@s> = $bwe_pos1_x<@s>$;
        bwe_max_x<@s> = $bwe_pos2_x<@s>$;
    } else {
        bwe_min_x<@s> = $bwe_pos2_x<@s>$;
        bwe_max_x<@s> = $bwe_pos1_x<@s>$;
    }
    // Y bounds
    if $bwe_pos1_y<@s>$ <= $bwe_pos2_y<@s>$ {
        bwe_min_y<@s> = $bwe_pos1_y<@s>$;
        bwe_max_y<@s> = $bwe_pos2_y<@s>$;
    } else {
        bwe_min_y<@s> = $bwe_pos2_y<@s>$;
        bwe_max_y<@s> = $bwe_pos1_y<@s>$;
    }
    // Z bounds
    if $bwe_pos1_z<@s>$ <= $bwe_pos2_z<@s>$ {
        bwe_min_z<@s> = $bwe_pos1_z<@s>$;
        bwe_max_z<@s> = $bwe_pos2_z<@s>$;
    } else {
        bwe_min_z<@s> = $bwe_pos2_z<@s>$;
        bwe_max_z<@s> = $bwe_pos1_z<@s>$;
    }

    // Dimensions (inclusive)
    $!raw
    scoreboard players operation @s bwe_dim_x = @s bwe_max_x
    scoreboard players operation @s bwe_dim_x -= @s bwe_min_x
    scoreboard players add @s bwe_dim_x 1

    scoreboard players operation @s bwe_dim_y = @s bwe_max_y
    scoreboard players operation @s bwe_dim_y -= @s bwe_min_y
    scoreboard players add @s bwe_dim_y 1

    scoreboard players operation @s bwe_dim_z = @s bwe_max_z
    scoreboard players operation @s bwe_dim_z -= @s bwe_min_z
    scoreboard players add @s bwe_dim_z 1
    raw!$

    // Volume
    $!raw
    scoreboard players operation @s _temp = @s bwe_dim_x
    scoreboard players operation @s _temp *= @s bwe_dim_y
    scoreboard players operation @s bwe_volume = @s _temp
    scoreboard players operation @s bwe_volume *= @s bwe_dim_z
    raw!$
}

function betterworldedit:info {
    exec betterworldedit:_compute_bounds;
    say "Pos1: ($bwe_pos1_x<@s>$, $bwe_pos1_y<@s>$, $bwe_pos1_z<@s>$)";
    say "Pos2: ($bwe_pos2_x<@s>$, $bwe_pos2_y<@s>$, $bwe_pos2_z<@s>$)";
    say "Bounds min: ($bwe_min_x<@s>$, $bwe_min_y<@s>$, $bwe_min_z<@s>$) max: ($bwe_max_x<@s>$, $bwe_max_y<@s>$, $bwe_max_z<@s>$)";
    say "Dims: $bwe_dim_x<@s>$ x $bwe_dim_y<@s>$ x $bwe_dim_z<@s>$ = $bwe_volume<@s>$";
}

// =============================
// Ensure & Tick
// =============================

function betterworldedit:_ensure_scores_for_player {
    $!raw
    # Flags & positions
    scoreboard players add @s bwe_pos1_set 0
    scoreboard players add @s bwe_pos2_set 0
    scoreboard players add @s bwe_pos1_x 0
    scoreboard players add @s bwe_pos1_y 0
    scoreboard players add @s bwe_pos1_z 0
    scoreboard players add @s bwe_pos2_x 0
    scoreboard players add @s bwe_pos2_y 0
    scoreboard players add @s bwe_pos2_z 0

    # Derived
    scoreboard players add @s bwe_min_x 0
    scoreboard players add @s bwe_min_y 0
    scoreboard players add @s bwe_min_z 0
    scoreboard players add @s bwe_max_x 0
    scoreboard players add @s bwe_max_y 0
    scoreboard players add @s bwe_max_z 0
    scoreboard players add @s bwe_dim_x 0
    scoreboard players add @s bwe_dim_y 0
    scoreboard players add @s bwe_dim_z 0
    scoreboard players add @s bwe_volume 0

    # Config (set default once)
    scoreboard players add @s bwe_max_fill 0
    execute unless score @s bwe_max_fill matches 1.. run scoreboard players set @s bwe_max_fill 30000

    # Scratch
    scoreboard players add @s _slice_h 0
    scoreboard players add @s _base 0
    scoreboard players add @s _slices 0
    scoreboard players add @s _y_start 0
    scoreboard players add @s _y_end 0
    scoreboard players add @s _xs 0
    scoreboard players add @s _xe 0
    scoreboard players add @s _zs 0
    scoreboard players add @s _ze 0
    scoreboard players add @s _tile_x 0
    scoreboard players add @s _tile_z 0
    scoreboard players add @s _area_limit 0
    scoreboard players add @s _temp 0

    # Selector stats
    scoreboard players add @s bwe_stat_selector 0
    scoreboard players add @s bwe_stat_selector_2 0
    scoreboard players add @s bwe_stat_prev_1 0
    scoreboard players add @s bwe_stat_prev_2 0
    raw!$
}

function betterworldedit:main_tick {
    exec betterworldedit:_ensure_scores_for_player<@a>;
    exec betterworldedit:update_selector<@a>;
}

on_tick betterworldedit:main_tick;

// =============================
// Chunked fill
// =============================

function betterworldedit:_fill_slice_macro {
    $fill $(x1) $(y1) $(z1) $(x2) $(y2) $(z2) $(block)
}

function betterworldedit:_prepare_fill_ctx {
    $!raw
    # Reset compound
    data remove storage betterworldedit:ctx fill
    data modify storage betterworldedit:ctx fill set value {}
    # Coords from scoreboard
    execute store result storage betterworldedit:ctx fill.x1 int 1 run scoreboard players get @s _xs
    execute store result storage betterworldedit:ctx fill.y1 int 1 run scoreboard players get @s _y_start
    execute store result storage betterworldedit:ctx fill.z1 int 1 run scoreboard players get @s _zs
    execute store result storage betterworldedit:ctx fill.x2 int 1 run scoreboard players get @s _xe
    execute store result storage betterworldedit:ctx fill.y2 int 1 run scoreboard players get @s _y_end
    execute store result storage betterworldedit:ctx fill.z2 int 1 run scoreboard players get @s _ze
    # Block id from request
    data modify storage betterworldedit:ctx fill.block set from storage betterworldedit:ctx req.block
    raw!$
}

function betterworldedit:set_stone {
    exec betterworldedit:_compute_bounds;
    $!raw
    execute unless data storage betterworldedit:ctx req.block run data modify storage betterworldedit:ctx req.block set value "minecraft:stone"
    raw!$
    if $bwe_volume<@s>$ == 0 {
        say "No selection set! Use pos1/pos2 first.";
    } else {
        $!raw
        tellraw @s [{"text":"Filling selection with "},{"storage":"betterworldedit:ctx","nbt":"req.block"},{"text":"... ("},{"score":{"name":"@s","objective":"bwe_dim_x"}},{"text":"x"},{"score":{"name":"@s","objective":"bwe_dim_y"}},{"text":"x"},{"score":{"name":"@s","objective":"bwe_dim_z"}},{"text":" = "},{"score":{"name":"@s","objective":"bwe_volume"}},{"text":"")"}]
        raw!$

        // Single fill if within limit
        if $bwe_volume<@s>$ <= $bwe_max_fill<@s>$ {
            $!raw
            scoreboard players operation @s _y_start = @s bwe_min_y
            scoreboard players operation @s _y_end = @s bwe_max_y
            scoreboard players operation @s _xs = @s bwe_min_x
            scoreboard players operation @s _xe = @s bwe_max_x
            scoreboard players operation @s _zs = @s bwe_min_z
            scoreboard players operation @s _ze = @s bwe_max_z
            raw!$
            exec betterworldedit:_prepare_fill_ctx;
            exec betterworldedit:_fill_slice_macro with storage betterworldedit:ctx fill;
            say "Done (single fill).";
        } else {
            // Chunked: compute slice height so slice_area * slice_h <= max_fill
            _base<@s> = $bwe_dim_x<@s>$ * $bwe_dim_z<@s>$;
            _slice_h<@s> = $bwe_max_fill<@s>$ / $_base<@s>$;
            if $_slice_h<@s>$ < 1 { _slice_h<@s> = 1; }
            if $_slice_h<@s>$ > $bwe_dim_y<@s>$ { _slice_h<@s> = $bwe_dim_y<@s>$; }

            _y_start<@s> = $bwe_min_y<@s>$ + 0;
            _y_end<@s> = 0;
            _slices<@s> = 0;

            while $_y_start<@s>$ <= $bwe_max_y<@s>$ {
                _y_end<@s> = $_y_start<@s>$ + $_slice_h<@s>$ - 1;
                if $_y_end<@s>$ > $bwe_max_y<@s>$ { _y_end<@s> = $bwe_max_y<@s>$; }

                // Determine tile sizes along X/Z to respect area_limit per slice
                _area_limit<@s> = $bwe_max_fill<@s>$ / $_slice_h<@s>$;
                if $_area_limit<@s>$ < 1 { _area_limit<@s> = 1; }

                _tile_x<@s> = $_area_limit<@s>$ / $bwe_dim_z<@s>$;
                if $_tile_x<@s>$ < 1 { _tile_x<@s> = 1; }
                if $_tile_x<@s>$ > $bwe_dim_x<@s>$ { _tile_x<@s> = $bwe_dim_x<@s>$; }

                _tile_z<@s> = $_area_limit<@s>$ / $_tile_x<@s>$;
                if $_tile_z<@s>$ < 1 { _tile_z<@s> = 1; }
                if $_tile_z<@s>$ > $bwe_dim_z<@s>$ { _tile_z<@s> = $bwe_dim_z<@s>$; }

                _xs<@s> = $bwe_min_x<@s>$ + 0;
                while $_xs<@s>$ <= $bwe_max_x<@s>$ {
                    _xe<@s> = $_xs<@s>$ + $_tile_x<@s>$ - 1;
                    if $_xe<@s>$ > $bwe_max_x<@s>$ { _xe<@s> = $bwe_max_x<@s>$; }

                    _zs<@s> = $bwe_min_z<@s>$ + 0;
                    while $_zs<@s>$ <= $bwe_max_z<@s>$ {
                        _ze<@s> = $_zs<@s>$ + $_tile_z<@s>$ - 1;
                        if $_ze<@s>$ > $bwe_max_z<@s>$ { _ze<@s> = $bwe_max_z<@s>$; }

                        exec betterworldedit:_prepare_fill_ctx;
                        exec betterworldedit:_fill_slice_macro with storage betterworldedit:ctx fill;

                        _slices<@s> = $_slices<@s>$ + 1;
                        say "Filled #$_slices<@s>$: x $_xs<@s>$..$_xe<@s>$, y $_y_start<@s>$..$_y_end<@s>$, z $_zs<@s>$..$_ze<@s>$";

                        _zs<@s> = $_ze<@s>$ + 1;
                    }
                    _xs<@s> = $_xe<@s>$ + 1;
                }
                _y_start<@s> = $_y_end<@s>$ + 1;
            }
            say "Done ($_slices<@s>$ sub-fills).";
        }
    }
}

// Public macro: set requested block (string) and run chunked fill over current selection
// Usage examples:
//   exec betterworldedit:fill_selection '{block:"minecraft:oak_planks"}';
//   exec betterworldedit:fill_selection with storage betterworldedit:req mypath.to.compound;
function betterworldedit:fill_selection {
    $!raw
    data remove storage betterworldedit:ctx req
    data modify storage betterworldedit:ctx req set value {}
    data modify storage betterworldedit:ctx req.block set value "$(block)"
    raw!$
    exec betterworldedit:set_stone;
}

// =============================
// Selector tools
// =============================

function betterworldedit:give_selector {
    $!raw
    give @s minecraft:brush[item_name={"bold":true,"color":"dark_blue","italic":true,"text":"BWE Selector (Pos1)"},lore=[{"text":"Right-click: set pos1","color":"gray","italic":false}],custom_data={bwe_selector_1:1b}] 1
    give @s minecraft:brush[item_name={"bold":true,"color":"gold","italic":true,"text":"BWE Selector (Pos2)"},lore=[{"text":"Right-click: set pos2","color":"gray","italic":false}],custom_data={bwe_selector_2:1b}] 1
    raw!$
    say "Gave you both BWE Selector tools (pos1 and pos2).";
}

function betterworldedit:update_selector {
    // Update tags based on currently held selector tool
    $!raw
    tag @s remove bwe_holding_pos1
    tag @s remove bwe_holding_pos2
    execute if entity @s[nbt={SelectedItem:{components:{"minecraft:custom_data":{bwe_selector_1:1b}}}}] run tag @s add bwe_holding_pos1
    execute if entity @s[nbt={SelectedItem:{components:{"minecraft:custom_data":{bwe_selector_2:1b}}}}] run tag @s add bwe_holding_pos2
    raw!$

    // On brush use, run the appropriate function for whoever holds that tool, then reset the stat
    $!raw
    execute as @s[tag=bwe_holding_pos1,scores={bwe_use_selector=1..}] run function betterworldedit:pos1
    execute as @s[tag=bwe_holding_pos2,scores={bwe_use_selector=1..}] run function betterworldedit:pos2
    scoreboard players reset @s[scores={bwe_use_selector=1..}] bwe_use_selector
    raw!$
}
"""

p = MDLParser()
ast = p.parse(mdl_src)

td = tempfile.TemporaryDirectory()
out = Path(td.name)
MDLCompiler().compile(ast, str(out))
func_dir = out / 'data' / 'betterworldedit' / 'function'

print('== set_stone.mcfunction ==\n')
print((func_dir/'set_stone.mcfunction').read_text())

for name in sorted(func_dir.glob('set_stone__else_*.mcfunction')):
    print(f"\n== {name.name} ==\n")
    print(name.read_text())

for name in sorted(func_dir.glob('set_stone__while_*.mcfunction')):
    print(f"\n== {name.name} ==\n")
    print(name.read_text())
