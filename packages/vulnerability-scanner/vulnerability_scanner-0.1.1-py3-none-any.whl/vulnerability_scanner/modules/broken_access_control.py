import ast
from pathlib import Path


class BrokenAccessControlScanner(ast.NodeVisitor):
    def __init__(self, file_path: Path):
        self.file_path = file_path
        self.issues = []

    def add_issue(self, node, issue_type, message, severity="Medium",
                  explanation=None, remediation=None):
        self.issues.append({
            "type": issue_type,
            "message": message,
            "line": getattr(node, "lineno", 0),
            "file": str(self.file_path),
            "severity": severity,
            "owasp_category": "A01:2021 – Broken Access Control",
            "explanation": explanation or "This code pattern may allow unauthorized users to access or manipulate resources.",
            "remediation": remediation or "Enforce proper authorization checks and avoid hardcoding sensitive roles/IDs."
        })

    def visit_Assign(self, node):
        # Detect hardcoded roles in assignments
        if isinstance(node.value, ast.Constant) and isinstance(node.value.value, str):
            if node.value.value.lower() in {"admin", "root", "superuser"}:
                self.add_issue(
                    node,
                    "Hardcoded Role",
                    f"Hardcoded role '{node.value.value}' found.",
                    severity="High",
                    explanation="Hardcoding roles makes it easy for attackers to guess and abuse elevated privileges.",
                    remediation="Use a centralized role/permissions system instead of hardcoding values."
                )
        self.generic_visit(node)

    def visit_Compare(self, node):
        # Detect hardcoded role checks
        if any(
            isinstance(comp, ast.Constant) and isinstance(comp.value, str)
            and comp.value.lower() in {"admin", "root", "superuser"}
            for comp in node.comparators
        ):
            self.add_issue(
                node,
                "Hardcoded Role Check",
                "Comparison with hardcoded role found.",
                severity="Medium",
                explanation="Directly comparing roles with hardcoded values can lead to bypasses if roles are manipulated.",
                remediation="Use a proper authorization library or role-based access control (RBAC)."
            )
        self.generic_visit(node)

    def visit_Call(self, node):
        # --- Flask / PyMongo style BAC flaws ---
        if isinstance(node.func, ast.Attribute):
            # Direct use of request.args.get / request.form.get / request.json.get
            if isinstance(node.func.value, ast.Attribute) and isinstance(node.func.value.value, ast.Name):
                if node.func.value.value.id == "request" and node.func.value.attr in {"args", "form", "json"}:
                    if node.func.attr == "get":
                        self.add_issue(
                            node,
                            "Possible IDOR",
                            f"Direct use of request.{node.func.value.attr}.get() in query or logic.",
                            severity="Medium",
                            explanation="This allows user-supplied input to directly control resource access (IDOR).",
                            remediation="Validate the user’s identity and ensure ownership checks before accessing resources."
                        )

        # MongoDB queries with request.*
        if isinstance(node.func, ast.Attribute) and node.func.attr in {"find", "find_one", "delete_one", "update_one"}:
            for arg in node.args + [kw.value for kw in node.keywords]:
                if isinstance(arg, ast.Dict):
                    for v in arg.values:
                        if isinstance(v, ast.Call) and isinstance(v.func, ast.Attribute):
                            if isinstance(v.func.value, ast.Attribute) and isinstance(v.func.value.value, ast.Name):
                                if v.func.value.value.id == "request" and v.func.value.attr in {"args", "form", "json"}:
                                    self.add_issue(
                                        node,
                                        "Possible IDOR",
                                        f"Direct request.{v.func.value.attr}.get() used in Mongo query.",
                                        severity="Medium",
                                        explanation="Unvalidated request input is being used to query objects, allowing attackers to fetch or modify others’ data.",
                                        remediation="Always enforce user-specific filters (e.g., query with both user_id and resource_id)."
                                    )
        self.generic_visit(node)

    def visit_FunctionDef(self, node):
        # Detect Flask route parameters that may be sensitive
        for arg in node.args.args:
            if arg.arg.lower() in {"user", "userid", "username", "id"}:
                self.add_issue(
                    node,
                    "Possible IDOR",
                    f"Route parameter '{arg.arg}' may allow Insecure Direct Object Reference.",
                    severity="Medium",
                    explanation="Using route parameters directly for object access can let attackers guess IDs and access others’ data.",
                    remediation="Validate ownership by checking that the resource belongs to the authenticated user."
                )
        self.generic_visit(node)


def scan_file(file_path: Path):
    try:
        with open(file_path, "r", encoding="utf-8") as f:
            tree = ast.parse(f.read(), filename=str(file_path))
        scanner = BrokenAccessControlScanner(file_path)
        scanner.visit(tree)
        return scanner.issues

    except SyntaxError as e:
        return [{
            "type": "Syntax Error",
            "message": str(e),
            "line": e.lineno,
            "file": str(file_path),
            "severity": "Low",
            "owasp_category": "N/A",
            "explanation": "This file contains invalid Python syntax and could not be parsed.",
            "remediation": "Fix the syntax error before running security scans."
        }]
    except Exception as e:
        return [{
            "type": "Scanning Error",
            "message": str(e),
            "line": 0,
            "file": str(file_path),
            "severity": "Low",
            "owasp_category": "N/A",
            "explanation": "An unexpected error occurred during scanning.",
            "remediation": "Check file encoding or scanner compatibility."
        }]
