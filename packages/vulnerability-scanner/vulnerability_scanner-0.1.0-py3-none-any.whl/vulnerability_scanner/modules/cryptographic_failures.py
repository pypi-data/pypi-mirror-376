import ast
from pathlib import Path

# Weak hashing algorithms
WEAK_HASH_ALGORITHMS = {"md5", "sha1"}

# Weak cipher algorithms (optional but useful)
WEAK_CIPHERS = {"DES", "DES3", "TripleDES", "Blowfish", "RC2", "RC4"}

# Insecure cipher modes
WEAK_MODES = {"ECB", "MODE_ECB"}  # cover Crypto and cryptography naming

# Secret / key variable names (expanded for JWT + Flask)
SECRET_VAR_NAMES = {
    "password", "secret", "key", "api_key", "token", "passwd",
    "iv", "salt", "nonce", "jwt_secret", "jwt_key", "secret_key", "secretkey"
}


class CryptographicFailuresScanner(ast.NodeVisitor):
    def __init__(self, file_path: Path):
        self.file_path = file_path
        self.issues = []
        self._imports = {}

    def add_issue(self, node, issue_type, message, severity="Medium",
                  explanation=None, remediation=None):
        self.issues.append({
            "type": issue_type,
            "message": message,
            "line": getattr(node, "lineno", 0),
            "file": str(self.file_path),
            "severity": severity,
            "owasp_category": "A02:2021 â€“ Cryptographic Failures",
            "explanation": explanation or "This code uses weak or insecure cryptographic practices.",
            "remediation": remediation or "Replace with secure algorithms, modes, and secret management best practices."
        })

    # ---------- helpers ----------
    def _name_from_assign_target(self, target) -> str:
        if isinstance(target, ast.Name):
            return target.id
        if isinstance(target, ast.Attribute):
            return target.attr
        if isinstance(target, ast.Subscript):
            s = target.slice
            if isinstance(s, ast.Constant) and isinstance(s.value, str):
                return s.value
            if hasattr(ast, "Index") and isinstance(s, ast.Index) and isinstance(s.value, ast.Constant):
                return s.value.value
        return ""

    def _is_imported_as(self, name: str, real: str) -> bool:
        return name in self._imports and self._imports[name] == real

    # ---------- visitors ----------
    def visit_Import(self, node):
        for alias in node.names:
            self._imports[alias.asname or alias.name] = alias.name
        self.generic_visit(node)

    def visit_ImportFrom(self, node):
        for alias in node.names:
            self._imports[alias.asname or alias.name] = f"{node.module}.{alias.name}"
        self.generic_visit(node)

    def visit_Call(self, node):
        # ---- Weak hashing (hashlib.md5 / sha1) ----
        called_function_name = None

        if isinstance(node.func, ast.Name):
            if node.func.id in self._imports:
                full_name = self._imports[node.func.id]
                if full_name.startswith("hashlib."):
                    called_function_name = full_name.split(".")[-1]

        elif isinstance(node.func, ast.Attribute):
            value = node.func.value
            if isinstance(value, ast.Name) and value.id in self._imports:
                if self._imports[value.id] == "hashlib":
                    called_function_name = node.func.attr

        if called_function_name and called_function_name in WEAK_HASH_ALGORITHMS:
            self.add_issue(
                node,
                "Weak Hashing Algorithm",
                f"Use of weak hashing algorithm '{called_function_name}' found.",
                severity="High",
                explanation=f"Algorithms like {called_function_name.upper()} are cryptographically broken and can be brute-forced or collided easily.",
                remediation="Use strong hashing algorithms such as SHA-256, SHA-3, or password-specific algorithms like bcrypt/Argon2."
            )

        # ---- Weak cipher algorithms / insecure modes ----
        if isinstance(node.func, ast.Attribute):
            if node.func.attr in WEAK_CIPHERS:
                self.add_issue(
                    node,
                    "Weak Cipher Algorithm",
                    f"Use of weak cipher '{node.func.attr}' found.",
                    severity="High",
                    explanation=f"The cipher {node.func.attr} is outdated and vulnerable to cryptanalysis.",
                    remediation="Use modern ciphers such as AES-256 or ChaCha20."
                )
            if node.func.attr in WEAK_MODES:
                self.add_issue(
                    node,
                    "Insecure Cipher Mode",
                    f"Use of insecure cipher mode '{node.func.attr}' found.",
                    severity="High",
                    explanation="ECB mode encrypts identical blocks into identical ciphertext, leaking patterns.",
                    remediation="Use secure modes like CBC with random IVs, or authenticated modes such as GCM or ChaCha20-Poly1305."
                )

        # Also scan call arguments for insecure modes
        for arg in list(node.args) + [kw.value for kw in node.keywords]:
            if isinstance(arg, ast.Attribute) and arg.attr in WEAK_MODES:
                self.add_issue(
                    node,
                    "Insecure Cipher Mode",
                    f"Use of insecure cipher mode '{arg.attr}' found.",
                    severity="High",
                    explanation="Using ECB mode leaks structural patterns in encrypted data.",
                    remediation="Use authenticated encryption modes (e.g., AES-GCM)."
                )

        # ---- Insecure randomness ----
        if isinstance(node.func, ast.Attribute):
            if isinstance(node.func.value, ast.Name):
                base = node.func.value.id
                if self._is_imported_as(base, "random") or base == "random":
                    if node.func.attr in {"random", "randint", "randrange", "choice", "choices"}:
                        self.add_issue(
                            node,
                            "Insecure Randomness",
                            f"Use of random.{node.func.attr}() for security-sensitive values.",
                            severity="Medium",
                            explanation="Python's random module is not cryptographically secure and predictable under attack.",
                            remediation="Use secrets or os.urandom() for cryptographic randomness."
                        )

        # ---- Hardcoded JWT secrets ----
        is_jwt_call = False
        if isinstance(node.func, ast.Attribute) and isinstance(node.func.value, ast.Name):
            base = node.func.value.id
            if base == "jwt" or self._is_imported_as(base, "jwt") or self._is_imported_as(base, "PyJWT"):
                is_jwt_call = node.func.attr in {"encode", "decode"}

        if is_jwt_call:
            for idx, arg in enumerate(node.args):
                if isinstance(arg, ast.Constant) and isinstance(arg.value, str) and idx == 1:
                    self.add_issue(
                        node,
                        "Hardcoded JWT Secret",
                        f"Hardcoded JWT secret '{arg.value}' passed to jwt.{node.func.attr}().",
                        severity="Critical",
                        explanation="Hardcoding JWT secrets exposes authentication to theft if code is leaked.",
                        remediation="Store JWT secrets in environment variables or a secure vault (e.g., AWS Secrets Manager)."
                    )
            for kw in node.keywords:
                if kw.arg in {"key", "secret"} and isinstance(kw.value, ast.Constant) and isinstance(kw.value.value, str):
                    self.add_issue(
                        node,
                        "Hardcoded JWT Secret",
                        f"Hardcoded JWT secret '{kw.value.value}' passed via '{kw.arg}'.",
                        severity="Critical",
                        explanation="Embedding JWT keys in code allows attackers to forge tokens if the repo is leaked.",
                        remediation="Use configuration files or environment variables to inject secrets securely."
                    )

        self.generic_visit(node)

    def visit_Assign(self, node):
        # ---- Hardcoded secrets / keys ----
        for target in node.targets:
            var_name = self._name_from_assign_target(target)
            if not var_name:
                continue
            if var_name.lower() in SECRET_VAR_NAMES:
                if isinstance(node.value, ast.Constant) and isinstance(node.value.value, (str, bytes, int)):
                    self.add_issue(
                        node,
                        "Hardcoded Secret",
                        f"Hardcoded secret/key '{var_name}' found.",
                        severity="Critical",
                        explanation=f"Storing sensitive secrets (like {var_name}) in source code risks accidental leaks in version control.",
                        remediation="Move secrets to environment variables, config files, or secret managers."
                    )
                    if "jwt" in var_name.lower():
                        self.add_issue(
                            node,
                            "Hardcoded JWT Secret",
                            f"Hardcoded JWT secret set via '{var_name}'.",
                            severity="Critical",
                            explanation="Hardcoding JWT keys puts token signing/verification at risk if code is leaked.",
                            remediation="Store JWT keys securely in an environment variable or vault."
                        )
        self.generic_visit(node)


def scan_file(file_path: Path):
    try:
        content = file_path.read_text(encoding="utf-8")
        tree = ast.parse(content, filename=str(file_path))
        scanner = CryptographicFailuresScanner(file_path)
        scanner.visit(tree)
        return scanner.issues

    except SyntaxError as e:
        return [{
            "type": "Syntax Error",
            "message": str(e),
            "line": e.lineno,
            "file": str(file_path),
            "severity": "Low",
            "owasp_category": "N/A",
            "explanation": "This file contains invalid Python syntax and could not be parsed.",
            "remediation": "Fix syntax errors before running security scans."
        }]
    except Exception as e:
        return [{
            "type": "Scanning Error",
            "message": str(e),
            "line": 0,
            "file": str(file_path),
            "severity": "Low",
            "owasp_category": "N/A",
            "explanation": "An unexpected error occurred during cryptographic scanning.",
            "remediation": "Check file encoding or scanner compatibility."
        }]
