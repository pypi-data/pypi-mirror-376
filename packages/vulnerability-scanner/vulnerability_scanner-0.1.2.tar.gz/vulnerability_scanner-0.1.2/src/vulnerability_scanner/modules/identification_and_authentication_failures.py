import ast
from pathlib import Path

# Common password variable names
PASSWORD_VAR_NAMES = {"password", "passwd", "pass", "secret"}

class AuthenticationScanner(ast.NodeVisitor):
    def __init__(self, file_path: Path):
        self.file_path = file_path
        self.issues = []
        self._imports = {}  # alias -> module path

    def add_issue(self, node, issue_type, message, severity="Medium",
                  explanation=None, remediation=None):
        self.issues.append({
            "type": issue_type,
            "message": message,
            "line": getattr(node, "lineno", 0),
            "file": str(self.file_path),
            "severity": severity,
            "owasp_category": "A07:2021 â€“ Identification and Authentication Failures",
            "explanation": (explanation or
                            "This code pattern may lead to authentication or session management vulnerabilities."),
            "remediation": (remediation or
                            "Implement strong authentication and session management controls.")
        })

    # ---------- helpers ----------
    @staticmethod
    def _is_str_constant(node):
        return isinstance(node, ast.Constant) and isinstance(node.value, str)

    def _is_user_input(self, node):
        """
        Heuristic: detect Django/Flask request-sourced values.
        - request.POST.get('password') / request.GET.get('password')
        - request.POST['password'] / request.GET['password']
        - request.form.get(...) / request.args.get(...)
        """
        # request.POST['x'] or request.GET['x']
        if isinstance(node, ast.Subscript) and isinstance(node.value, ast.Attribute):
            base = node.value
            if isinstance(base.value, ast.Name) and base.value.id == "request":
                if base.attr in {"POST", "GET"}:
                    return True

        # request.POST.get('x'), request.GET.get('x'), request.form.get(...), request.args.get(...)
        if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):
            recv = node.func.value
            if isinstance(recv, ast.Attribute) and isinstance(recv.value, ast.Name) and recv.value.id == "request":
                if recv.attr in {"POST", "GET", "form", "args", "json"} and node.func.attr == "get":
                    return True

        return False

    def _is_password_kw(self, kw: ast.keyword):
        return kw.arg and kw.arg.lower() in PASSWORD_VAR_NAMES

    def _call_qualname(self, node: ast.Call):
        """Return best-effort 'module.func' or 'obj.method' string."""
        if isinstance(node.func, ast.Attribute):
            # something.method
            if isinstance(node.func.value, ast.Name):
                return f"{node.func.value.id}.{node.func.attr}"
            if isinstance(node.func.value, ast.Attribute):
                # obj.manager.create -> Attribute(Attribute(Name, 'objects'), 'create')
                parts = []
                cur = node.func
                while isinstance(cur, ast.Attribute):
                    parts.append(cur.attr)
                    cur = cur.value
                if isinstance(cur, ast.Name):
                    parts.append(cur.id)
                return ".".join(reversed(parts))
        elif isinstance(node.func, ast.Name):
            return node.func.id
        return ""

    # ---------- imports ----------
    def visit_Import(self, node):
        for alias in node.names:
            self._imports[alias.asname or alias.name] = alias.name
        self.generic_visit(node)

    def visit_ImportFrom(self, node):
        base = node.module or ""
        for alias in node.names:
            self._imports[alias.asname or alias.name] = f"{base}.{alias.name}" if base else alias.name
        self.generic_visit(node)

    # ---------- assignments ----------
    def visit_Assign(self, node):
        # Hardcoded passwords (generic)
        for target in node.targets:
            var_name = ""
            if isinstance(target, ast.Name):
                var_name = target.id
            elif isinstance(target, ast.Attribute):
                var_name = target.attr

            if var_name.lower() in PASSWORD_VAR_NAMES and self._is_str_constant(node.value):
                self.add_issue(
                    node,
                    "Hardcoded Password",
                    f"Hardcoded password '{var_name}' found.",
                    severity="Critical",
                    explanation="Hardcoding passwords or secrets in source code makes them easy to discover and abuse.",
                    remediation="Use environment variables or a secrets manager. Do not commit secrets to source control."
                )

        # Django: settings.AUTH_PASSWORD_VALIDATORS weakness
        for target in node.targets:
            if isinstance(target, ast.Name) and target.id == "AUTH_PASSWORD_VALIDATORS":
                if isinstance(node.value, ast.List):
                    length = len(node.value.elts)
                    if length == 0:
                        self.add_issue(
                            node,
                            "Weak Password Policy (Django)",
                            "AUTH_PASSWORD_VALIDATORS is empty; passwords may be trivial.",
                            severity="High",
                            remediation="Configure Django AUTH_PASSWORD_VALIDATORS with a reasonable set "
                                        "(UserAttributeSimilarityValidator, MinimumLengthValidator, "
                                        "CommonPasswordValidator, NumericPasswordValidator, etc.)."
                        )
                    elif length < 2:
                        self.add_issue(
                            node,
                            "Potentially Weak Password Policy (Django)",
                            f"Only {length} validator(s) configured in AUTH_PASSWORD_VALIDATORS.",
                            severity="Medium",
                            remediation="Add additional validators (length, common-password, numeric, similarity)."
                        )

        # Django: direct attribute assignment to .password (plaintext)
        for target in node.targets:
            if isinstance(target, ast.Attribute) and target.attr.lower() in PASSWORD_VAR_NAMES:
                # If value is a plain string or a raw variable, it's likely not hashed
                if self._is_str_constant(node.value) or isinstance(node.value, (ast.Name, ast.JoinedStr, ast.BinOp)):
                    self.add_issue(
                        node,
                        "Plaintext Password Assignment",
                        "Password is being stored/assigned directly in the code. This likely means it is stored in plaintext.",
                        severity="High",
                        remediation="Never store passwords in plaintext. Use a secure password hashing function "
                                    "such as bcrypt, Argon2, or PBKDF2 before saving to the database."
                    )

        self.generic_visit(node)

    # ---------- comparisons ----------
    def visit_Compare(self, node):
        # Weak password length checks (generic)
        if isinstance(node.left, ast.Call) and isinstance(node.left.func, ast.Name) and node.left.func.id == "len":
            if node.left.args and isinstance(node.left.args[0], ast.Name) and node.left.args[0].id.lower() in PASSWORD_VAR_NAMES:
                for op, comp in zip(node.ops, node.comparators):
                    if isinstance(op, (ast.Lt, ast.LtE)) and isinstance(comp, ast.Constant) and isinstance(comp.value, int):
                        if comp.value < 8:
                            self.add_issue(
                                node,
                                "Weak Password Policy",
                                f"Weak password length check: length < {comp.value}. Should be at least 8-12.",
                                severity="Medium",
                                remediation="Require 12+ chars and add complexity/common-password checks."
                            )

        # Django/Generic: plaintext password equality check (==)
        # Example: if user.password == request.POST.get('password'):
        names_or_attrs = []

        def collect_names(n):
            if isinstance(n, ast.Name):
                names_or_attrs.append(n.id.lower())
            elif isinstance(n, ast.Attribute):
                names_or_attrs.append(n.attr.lower())

        collect_names(node.left)
        for comp in node.comparators:
            collect_names(comp)

        if any(n in PASSWORD_VAR_NAMES for n in names_or_attrs):
            # if any side looks like user input, flag it
            left_user = self._is_user_input(node.left)
            right_user = any(self._is_user_input(c) for c in node.comparators)
            if left_user or right_user:
                if any(isinstance(op, ast.Eq) for op in node.ops):
                    self.add_issue(
                        node,
                        "Insecure Password Comparison",
                        "Directly comparing a stored password to user input (likely plaintext).",
                        severity="High",
                        remediation="Use Django auth: authenticate() or check_password()/set_password(). "
                                    "Never store or compare plaintext passwords."
                    )

        self.generic_visit(node)

    # ---------- function defs (CSRF) ----------
    def visit_FunctionDef(self, node):
        # Flask POST route missing CSRF (keep your original behavior)
        is_post_route = False
        for decorator in node.decorator_list:
            if isinstance(decorator, ast.Call) and isinstance(decorator.func, ast.Attribute):
                if decorator.func.attr == "route":
                    for keyword in decorator.keywords:
                        if keyword.arg == "methods" and isinstance(keyword.value, (ast.List, ast.Tuple)):
                            for method in keyword.value.elts:
                                if isinstance(method, ast.Constant) and isinstance(method.value, str) and method.value.upper() == "POST":
                                    is_post_route = True

        if is_post_route:
            has_csrf = False
            for decorator in node.decorator_list:
                if isinstance(decorator, ast.Name) and "csrf" in decorator.id.lower():
                    has_csrf = True
                if isinstance(decorator, ast.Attribute) and "csrf" in decorator.attr.lower():
                    has_csrf = True
            if not has_csrf:
                self.add_issue(
                    node,
                    "Missing CSRF Protection",
                    "A route that accepts POST requests appears to be missing CSRF protection.",
                    severity="High",
                    remediation="Use a CSRF protection library (e.g., Flask-WTF) with CSRF tokens."
                )

        # Django-specific: @csrf_exempt on any view
        for decorator in node.decorator_list:
            # @csrf_exempt  OR  @django.views.decorators.csrf.csrf_exempt
            if isinstance(decorator, ast.Name) and decorator.id == "csrf_exempt":
                self.add_issue(
                    node,
                    "CSRF Exempt (Django)",
                    "View is marked @csrf_exempt.",
                    severity="High",
                    remediation="Remove @csrf_exempt or restrict it; rely on CsrfViewMiddleware/ensure_csrf_cookie."
                )
            if isinstance(decorator, ast.Attribute) and decorator.attr == "csrf_exempt":
                self.add_issue(
                    node,
                    "CSRF Exempt (Django)",
                    "View is marked @csrf_exempt.",
                    severity="High",
                    remediation="Remove @csrf_exempt or restrict it; rely on CsrfViewMiddleware/ensure_csrf_cookie."
                )

        self.generic_visit(node)

    # ---------- calls (ORM create with password, hashing helpers) ----------
    def visit_Call(self, node):
        qname = self._call_qualname(node)

        # Django ORM create/update with plaintext password:
        #   User.objects.create(username=..., password=...)
        #   Model.objects.update_or_create(..., defaults={'password': '...'})
        if qname.endswith(".create") or qname.endswith(".create_user") or qname.endswith(".update_or_create"):
            # direct password kw
            for kw in node.keywords or []:
                if self._is_password_kw(kw):
                    if self._is_str_constant(kw.value) or isinstance(kw.value, (ast.Name, ast.JoinedStr, ast.BinOp)):
                        self.add_issue(
                            node,
                            "Plaintext Password in ORM Create (Django)",
                            "Passing a raw password to ORM .create(); use set_password()/make_password().",
                            severity="High",
                            remediation="Hash the password via set_password() or make_password() before saving."
                        )
                # defaults={ 'password': ... }
                if kw.arg == "defaults" and isinstance(kw.value, (ast.Dict,)):
                    for k_node, v_node in zip(kw.value.keys, kw.value.values):
                        if isinstance(k_node, ast.Constant) and isinstance(k_node.value, str) and k_node.value.lower() in PASSWORD_VAR_NAMES:
                            if self._is_str_constant(v_node) or isinstance(v_node, (ast.Name, ast.JoinedStr, ast.BinOp)):
                                self.add_issue(
                                    node,
                                    "Plaintext Password in ORM defaults (Django)",
                                    "Setting 'password' in defaults likely stores plaintext.",
                                    severity="High",
                                    remediation="Use set_password() after instance creation, or pre-hash with make_password()."
                                )

        # (Optional soft check) using make_password is OK; no issue added.
        self.generic_visit(node)


def scan_file(file_path: Path):
    try:
        with open(file_path, "r", encoding="utf-8") as f:
            tree = ast.parse(f.read(), filename=str(file_path))
        scanner = AuthenticationScanner(file_path)
        scanner.visit(tree)
        return scanner.issues

    except SyntaxError as e:
        return [{
            "type": "Syntax Error",
            "message": str(e),
            "line": e.lineno,
            "file": str(file_path),
            "severity": "Low",
            "owasp_category": "N/A",
            "explanation": "This file contains invalid Python syntax and could not be parsed.",
            "remediation": "Fix the syntax error before running security scans."
        }]
    except Exception as e:
        return [{
            "type": "Scanning Error",
            "message": str(e),
            "line": 0,
            "file": str(file_path),
            "severity": "Low",
            "owasp_category": "N/A",
            "explanation": "An unexpected error occurred during scanning.",
            "remediation": "Check file encoding or scanner compatibility."
        }]
