import ast
import re
from pathlib import Path


class SSRFScanner(ast.NodeVisitor):
    def __init__(self, file_path: Path):
        self.file_path = file_path
        self.issues = []
        self._imports = {}

    def add_issue(self, node, issue_type, message, severity="High",
                  explanation=None,
                  remediation=None):
        self.issues.append({
            "type": issue_type,
            "message": message,
            "line": getattr(node, "lineno", 0),
            "file": str(self.file_path),
            "severity": severity,
            "owasp_category": "A10:2021 – Server-Side Request Forgery (SSRF)",
            "explanation": explanation or "This code pattern may allow an attacker to induce the application to make requests to an unintended location.",
            "remediation": remediation or "Validate and sanitize all user-supplied input used in URLs for server-side requests. Use a whitelist of allowed domains and protocols."
        })

    def visit_Import(self, node):
        for alias in node.names:
            self._imports[alias.asname or alias.name] = alias.name
        self.generic_visit(node)

    def visit_ImportFrom(self, node):
        for alias in node.names:
            self._imports[alias.asname or alias.name] = f"{node.module}.{alias.name}"
        self.generic_visit(node)

    def visit_Call(self, node):
        # Detect calls to popular request libraries
        request_functions = {
            "requests": ["get", "post", "put", "delete", "request"],
            "urllib": ["urlopen"],
            "httpx": ["get", "post", "put", "delete", "request"],
            "aiohttp": ["get", "post", "put", "delete"]
        }

        func_name = ""
        if isinstance(node.func, ast.Attribute):
            if isinstance(node.func.value, ast.Name):
                lib_name = self._imports.get(node.func.value.id)
                if lib_name in request_functions and node.func.attr in request_functions[lib_name]:
                    func_name = f"{lib_name}.{node.func.attr}"

        if func_name:
            # Check if the URL is constructed from user-controlled data
            if node.args:
                url_arg = node.args[0]
                if self._is_user_controlled(url_arg):
                    self.add_issue(
                        node,
                        "Potential SSRF",
                        f"Potential SSRF vulnerability in call to `{func_name}`. The URL is constructed from user-controlled data.",
                        severity="High",
                        explanation="The application is making a server-side request to a URL that is at least partially controlled by the user. This can be exploited by an attacker to make requests to internal services or other arbitrary domains.",
                        remediation="Do not use user-supplied input directly in URLs for server-side requests. If you must, use a strict whitelist of allowed domains and protocols. Also, ensure that the response from the request is not returned to the user."
                    )
        self.generic_visit(node)

    def _is_user_controlled(self, node):
        if isinstance(node, ast.BinOp) and isinstance(node.op, ast.Add):
            return self._is_user_controlled(node.left) or self._is_user_controlled(node.right)
        if isinstance(node, ast.JoinedStr):
            return any(self._is_user_controlled(v) for v in node.values)
        if isinstance(node, ast.FormattedValue):
            return self._is_user_controlled(node.value)
        if isinstance(node, ast.Call):
            if isinstance(node.func, ast.Attribute):
                if isinstance(node.func.value, ast.Attribute) and isinstance(node.func.value.value, ast.Name):
                    if node.func.value.value.id == "request" and node.func.value.attr in {"args", "form", "json", "data"}:
                        return True
        if isinstance(node, ast.Name):
            # This is a simple check, a more advanced analysis would track data flow
            if "url" in node.id.lower() or "uri" in node.id.lower():
                return True
        return False


def regex_fallback(code: str, file_path: Path):
    """Fallback regex scan to catch simple SSRF patterns."""
    issues = []
    patterns = [
        (r"requests\.get\((.*request\.args\.get.*)", "Potential SSRF", "Potential SSRF vulnerability using `requests.get` with `request.args.get`."),
        (r"requests\.post\((.*request\.form\.get.*)", "Potential SSRF", "Potential SSRF vulnerability using `requests.post` with `request.form.get`."),
        (r"urllib\.request\.urlopen\((.*request\.args\.get.*)", "Potential SSRF", "Potential SSRF vulnerability using `urllib.request.urlopen` with `request.args.get`."),
    ]

    for pattern, issue_type, message in patterns:
        for match in re.finditer(pattern, code):
            line = code.count('\n', 0, match.start()) + 1
            issues.append({
                "type": issue_type,
                "message": message,
                "line": line,
                "file": str(file_path),
                "severity": "High",
                "owasp_category": "A10:2021 – Server-Side Request Forgery (SSRF)",
                "explanation": "The application is making a server-side request to a URL that is at least partially controlled by the user. This can be exploited by an attacker to make requests to internal services or other arbitrary domains.",
                "remediation": "Do not use user-supplied input directly in URLs for server-side requests. If you must, use a strict whitelist of allowed domains and protocols. Also, ensure that the response from the request is not returned to the user."
            })
    return issues


def scan_file(file_path: Path):
    try:
        with open(file_path, "r", encoding="utf-8") as f:
            code = f.read()
            tree = ast.parse(code, filename=str(file_path))
        scanner = SSRFScanner(file_path)
        scanner.visit(tree)
        issues = scanner.issues
        issues.extend(regex_fallback(code, file_path))
        return issues

    except SyntaxError as e:
        return [{
            "type": "Syntax Error",
            "message": str(e),
            "line": e.lineno,
            "file": str(file_path),
            "severity": "Low",
            "owasp_category": "N/A",
            "explanation": "This file contains invalid Python syntax and could not be parsed.",
            "remediation": "Fix the syntax error before running security scans."
        }]
    except Exception as e:
        return [{
            "type": "Scanning Error",
            "message": str(e),
            "line": 0,
            "file": str(file_path),
            "severity": "Low",
            "owasp_category": "N/A",
            "explanation": "An unexpected error occurred during scanning.",
            "remediation": "Check file encoding or scanner compatibility."
        }]