import ast
from pathlib import Path


class SoftwareAndDataIntegrityScanner(ast.NodeVisitor):
    def __init__(self, file_path: Path):
        self.file_path = file_path
        self.issues = []

    def add_issue(self, node, issue_type, message, severity="High",
                  explanation=None, remediation=None):
        self.issues.append({
            "type": issue_type,
            "message": message,
            "line": getattr(node, "lineno", 0),
            "file": str(self.file_path),
            "severity": severity,
            "owasp_category": "A08:2021 â€“ Software and Data Integrity Failures",
            "explanation": explanation or "This pattern can compromise integrity by allowing malicious input to alter program behavior.",
            "remediation": remediation or "Avoid insecure deserialization and untrusted code execution. Use safe libraries and validate integrity."
        })

    def visit_Call(self, node):
        if isinstance(node.func, ast.Attribute) and isinstance(node.func.value, ast.Name):
            module = node.func.value.id
            func = node.func.attr

            # Insecure deserialization calls
            dangerous_deserialization = {
                ("pickle", "load"), ("pickle", "loads"),
                ("cPickle", "load"), ("cPickle", "loads"),
                ("dill", "load"), ("dill", "loads"),
                ("marshal", "load"), ("marshal", "loads"),
                ("jsonpickle", "decode"),
                ("shelve", "open"),
            }
            if (module, func) in dangerous_deserialization:
                self.add_issue(
                    node,
                    "Unsafe Deserialization",
                    f"Use of {module}.{func}() may allow insecure object injection.",
                    severity="Critical",
                    explanation=f"{module}.{func} can deserialize arbitrary objects and compromise integrity.",
                    remediation="Avoid unsafe deserialization. Use JSON or other safe formats."
                )

            # Unsafe YAML
            if module == "yaml" and func == "load":
                self.add_issue(
                    node,
                    "Unsafe YAML Load",
                    "Use of yaml.load() without SafeLoader may allow arbitrary object construction.",
                    severity="High",
                    explanation="yaml.load without SafeLoader can construct attacker-controlled objects.",
                    remediation="Use yaml.safe_load() for untrusted YAML."
                )

            # Unsafe archive extraction
            if module == "tarfile" and func == "extractall":
                self.add_issue(
                    node,
                    "Unsafe Archive Extraction",
                    "Use of tarfile.extractall() may allow path traversal and overwrite critical files.",
                    severity="High",
                    remediation="Validate file paths before extracting or use safe alternatives."
                )

            if module == "zipfile" and func == "extractall":
                self.add_issue(
                    node,
                    "Unsafe Archive Extraction",
                    "Use of zipfile.extractall() may allow path traversal and overwrite critical files.",
                    severity="High",
                    remediation="Manually validate file paths before extracting."
                )

            # Django / Flask signing loads
            if module in {"signing", "itsdangerous"} and func == "loads":
                self.add_issue(
                    node,
                    "Potential Integrity Bypass",
                    f"Use of {module}.loads() may allow tampering if keys/signatures are weak.",
                    severity="Medium",
                    remediation="Ensure strong keys and signature verification."
                )

        # Direct function calls
        elif isinstance(node.func, ast.Name):
            if node.func.id in {"exec"}:
                self.add_issue(
                    node,
                    "Dynamic Code Execution",
                    "Use of exec() on external input can break integrity guarantees.",
                    severity="Critical",
                    remediation="Avoid exec. Use safe configuration loading."
                )

        self.generic_visit(node)


def scan_file(file_path: Path):
    try:
        with open(file_path, "r", encoding="utf-8") as f:
            tree = ast.parse(f.read(), filename=str(file_path))
        scanner = SoftwareAndDataIntegrityScanner(file_path)
        scanner.visit(tree)
        return scanner.issues

    except SyntaxError as e:
        return [{
            "type": "Syntax Error",
            "message": str(e),
            "line": e.lineno,
            "file": str(file_path),
            "severity": "Low",
            "owasp_category": "N/A",
            "explanation": "Invalid Python syntax.",
            "remediation": "Fix syntax before scanning."
        }]
    except Exception as e:
        return [{
            "type": "Scanning Error",
            "message": str(e),
            "line": 0,
            "file": str(file_path),
            "severity": "Low",
            "owasp_category": "N/A",
            "explanation": "Unexpected error during scanning.",
            "remediation": "Check file encoding or scanner compatibility."
        }]
