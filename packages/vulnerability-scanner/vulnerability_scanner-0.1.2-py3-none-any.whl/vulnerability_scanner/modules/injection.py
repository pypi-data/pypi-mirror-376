import ast
import re
from pathlib import Path


class InjectionScanner(ast.NodeVisitor):
    def __init__(self, file_path: Path):
        self.file_path = file_path
        self.issues = []

    def add_issue(self, node, issue_type, message, severity="High",
                  explanation=None, remediation=None):
        self.issues.append({
            "type": issue_type,
            "message": message,
            "line": getattr(node, "lineno", 0),
            "file": str(self.file_path),
            "severity": severity,
            "owasp_category": "A03:2021 – Injection",
            "explanation": explanation or "This code may be vulnerable to injection attacks.",
            "remediation": remediation or "Use parameterized queries, sanitization, or safe APIs to prevent injection."
        })

    def visit_Call(self, node):
        # --- Command injection risks ---
        if isinstance(node.func, ast.Attribute) and isinstance(node.func.value, ast.Name):
            if node.func.value.id == "os" and node.func.attr in {"system", "popen"}:
                self.add_issue(
                    node,
                    "Command Injection Risk",
                    f"Use of os.{node.func.attr} may allow command injection.",
                    severity="High",
                    explanation="Passing untrusted input to os.system or os.popen can allow attackers to execute arbitrary system commands.",
                    remediation="Use the subprocess module with list arguments (e.g., subprocess.run([...])) instead of string-based commands."
                )

        # Case: imported directly -> system("ls")
        if isinstance(node.func, ast.Name) and node.func.id in {"system", "popen"}:
            self.add_issue(
                node,
                "Command Injection Risk",
                f"Use of `{node.func.id}` may allow command injection.",
                severity="High",
                explanation="Direct use of system commands without sanitization lets attackers inject shell commands.",
                remediation="Prefer subprocess.run with explicit arguments, and never pass raw user input."
            )

        # --- Dangerous builtins (eval/exec) ---
        if isinstance(node.func, ast.Name) and node.func.id in {"eval", "exec"}:
            self.add_issue(
                node,
                "Code Injection Risk",
                f"Use of dangerous builtin `{node.func.id}` detected.",
                severity="Critical",
                explanation=f"The function `{node.func.id}` executes arbitrary strings as Python code, enabling attackers to run arbitrary code.",
                remediation="Avoid eval/exec entirely. Use safe alternatives such as ast.literal_eval for parsing, or explicit function mappings."
            )

        # --- ORM raw queries ---
        if isinstance(node.func, ast.Attribute) and node.func.attr == "raw":
            self.add_issue(
                node,
                "SQL Injection Risk",
                "Possible SQL injection via Django ORM `.raw()`.",
                severity="High",
                explanation="Django’s `.raw()` executes raw SQL directly. If combined with user input, it allows SQL injection.",
                remediation="Use Django’s ORM query methods with parameterized queries instead of `.raw()`."
            )

        # --- Cursor.execute with dynamic SQL ---
        if isinstance(node.func, ast.Attribute) and node.func.attr == "execute":
            if node.args:
                arg = node.args[0]
                if isinstance(arg, (ast.JoinedStr, ast.BinOp, ast.Name)):
                    self.add_issue(
                        node,
                        "SQL Injection Risk",
                        "Possible SQL injection: dynamic SQL passed into execute().",
                        severity="High",
                        explanation="Building SQL queries dynamically using f-strings, concatenation, or variables allows attackers to inject SQL.",
                        remediation="Use parameterized queries (placeholders like %s or ?) instead of string concatenation."
                    )

        self.generic_visit(node)


def regex_fallback(code: str, file_path: Path):
    """Fallback regex scan to catch raw SQL patterns AST misses."""
    issues = []
    patterns = [
        (r"\.execute\([^)]*\%", "SQL Injection Risk",
         "Possible SQL injection via % formatting in execute().",
         "Using `%` string formatting in SQL queries allows untrusted data to modify query structure.",
         "Use parameterized queries with placeholders instead of string formatting."),
        (r"\.execute\([^)]*\+", "SQL Injection Risk",
         "Possible SQL injection via string concatenation in execute().",
         "Concatenating strings to build queries allows attackers to inject malicious SQL.",
         "Always use parameterized queries or ORM query builders."),
        (r"\.raw\(", "SQL Injection Risk",
         "Possible SQL injection via Django ORM `.raw()`.",
         "Raw queries bypass ORM protections and allow injection if user input is included.",
         "Use ORM filter/queryset methods with parameters.")
    ]

    for pattern, issue_type, message, explanation, remediation in patterns:
        for match in re.finditer(pattern, code):
            line = code.count("\n", 0, match.start()) + 1
            issues.append({
                "type": issue_type,
                "message": message,
                "line": line,
                "file": str(file_path),
                "severity": "High",
                "owasp_category": "A03:2021 – Injection",
                "explanation": explanation,
                "remediation": remediation
            })

    return issues


def scan_file(file_path: Path):
    """Scans a file for injection vulnerabilities."""
    try:
        code = file_path.read_text(encoding="utf-8")
        tree = ast.parse(code, filename=str(file_path))
        scanner = InjectionScanner(file_path)
        scanner.visit(tree)

        # Collect all issues
        issues = scanner.issues + regex_fallback(code, file_path)
        return issues

    except SyntaxError as e:
        return [{
            "type": "Syntax Error",
            "message": str(e),
            "line": e.lineno,
            "file": str(file_path),
            "severity": "Low",
            "owasp_category": "N/A",
            "explanation": "This file contains invalid Python syntax and could not be parsed.",
            "remediation": "Fix syntax errors before running injection scanning."
        }]
    except Exception as e:
        return [{
            "type": "Scanning Error",
            "message": str(e),
            "line": 0,
            "file": str(file_path),
            "severity": "Low",
            "owasp_category": "N/A",
            "explanation": "Unexpected error occurred during injection scanning.",
            "remediation": "Check file encoding or scanner compatibility."
        }]
