import json
from pathlib import Path
import typer
from rich import print_json
from rich.table import Table
from rich.console import Console
from collections import defaultdict
from enum import Enum

from vulnerability_scanner.modules.broken_access_control import scan_file as scan_bac
from vulnerability_scanner.modules.cryptographic_failures import scan_file as scan_crypto
from vulnerability_scanner.modules.injection import scan_file as scan_injection
from vulnerability_scanner.modules.insecure_design import scan_file as scan_insecure_design
from vulnerability_scanner.modules.security_misconfiguration import scan_file as scan_sm
from vulnerability_scanner.modules.vulnerable_and_outdated_components import scan_file as scan_vaoc
from vulnerability_scanner.modules.identification_and_authentication_failures import scan_file as scan_authn
from vulnerability_scanner.modules.software_and_data_integrity_failures import scan_file as scan_sdi
from vulnerability_scanner.modules.ssrf import scan_file as scan_ssrf
from vulnerability_scanner.modules.semgrep_scanner import scan_file as scan_semgrep

app = typer.Typer(help="Run one or more vulnerability scanners.", add_completion=False)


SCANNERS = {
    "broken_access_control": scan_bac,
    "cryptographic_failures": scan_crypto,
    "injection": scan_injection,
    "insecure_design": scan_insecure_design,
    "security_misconfiguration": scan_sm,
    "vulnerable_and_outdated_components": scan_vaoc,
    "identification_and_authentication_failures": scan_authn,
    "software_and_data_integrity_failures": scan_sdi,
    "ssrf": scan_ssrf,
}

ALIASES = {
    "bac": "broken_access_control",
    "crypto": "cryptographic_failures",
    "injection": "injection",
    "insecd": "insecure_design",
    "sm": "security_misconfiguration",
    "vaoc": "vulnerable_and_outdated_components",
    "authn": "identification_and_authentication_failures",
    "sdi": "software_and_data_integrity_failures",
    "ssrf": "ssrf",
}


class Severity(str, Enum):
    low = "low"
    medium = "medium"
    high = "high"
    critical = "critical"


@app.callback(invoke_without_command=True)
def scan(
    scanners: str = typer.Option(
        None,
        "--scanners",
        "-s",
        help="Comma-separated list of scanners to run (e.g. bac,crypto) or 'all'.",
    ),
    semgrep: bool = typer.Option(
        False,
        "--semgrep",
        help="Run Semgrep as an external add-on scanner."
    ),
    path: Path = typer.Option(
        Path("."), "--path", "-p", help="File or directory to scan (defaults to current dir)."
    ),
    output: str = typer.Option(None, help="Optional JSON output file."),
    verbose: bool = typer.Option(
        False,
        "--verbose",
        "-v",
        help="Enable verbose output to show each file being processed."
    ),
    fail_on_severity: Severity = typer.Option(
        None,
        "--fail-on-severity",
        help="Exit with a non-zero code if vulnerabilities of a certain severity are found.",
        case_sensitive=False,
    ),
):
    """Run one or more vulnerability scanners."""
    if not scanners and not semgrep:
        typer.secho("Error: You must provide either --scanners or --semgrep.", fg=typer.colors.RED)
        raise typer.Exit(1)

    if scanners and semgrep:
        typer.secho("Error: You can only provide one of --scanners or --semgrep.", fg=typer.colors.RED)
        raise typer.Exit(1)

    console = Console()
    results_by_scanner = {}
    selected_scanners = []

    if semgrep:
        selected_scanners = ["semgrep"]
        if verbose:
            console.print(f"[yellow][VERBOSE][/yellow] Running Semgrep on {path}")
        results_by_scanner["semgrep"] = scan_semgrep(path)

    if scanners:
        if scanners.lower() == "all":
            selected_scanners = list(SCANNERS.keys())
        else:
            for name in scanners.split(","):
                name = name.strip()
                if name in ALIASES:
                    name = ALIASES[name]
                if name not in SCANNERS:
                    typer.secho(f"Error: Scanner '{name}' not found.", fg=typer.colors.RED)
                    raise typer.Exit(1)
                selected_scanners.append(name)

        for scanner_name in selected_scanners:
            scanner_func = SCANNERS[scanner_name]
            issues_for_scanner = []
            files_to_scan = []

            if scanner_name == "vulnerable_and_outdated_components":
                dependency_files = ["requirements.txt", "pyproject.toml", "poetry.lock", "Pipfile.lock"]
                if path.is_file() and path.name in dependency_files:
                    files_to_scan.append(path)
                elif path.is_dir():
                    for file_name in dependency_files:
                        file_path = path / file_name
                        if file_path.is_file():
                            files_to_scan.append(file_path)
            elif path.is_file():
                files_to_scan.append(path)
            elif path.is_dir():
                files_to_scan.extend(path.rglob("*.py"))

            for file_to_scan in files_to_scan:
                if verbose:
                    console.print(f"[yellow][VERBOSE][/yellow] [{scanner_name}] Scanning {file_to_scan}")
                issues_for_scanner.extend(scanner_func(file_to_scan))

            results_by_scanner[scanner_name] = issues_for_scanner

    # Group by file and deduplicate for final output
    final_results = {}
    for scanner_name, issues in results_by_scanner.items():
        grouped_by_file = defaultdict(list)
        for issue in issues:
            grouped_by_file[issue["file"]].append(issue)

        scanner_results_grouped = []
        for file_path, issue_list in grouped_by_file.items():
            seen = set()
            unique_issues = []
            for issue in issue_list:
                key = (issue.get("type"), issue.get("message"), issue.get("line"))
                if key not in seen:
                    seen.add(key)
                    issue_copy = issue.copy()
                    if "file" in issue_copy:
                        del issue_copy["file"]
                    unique_issues.append(issue_copy)

            if unique_issues:
                scanner_results_grouped.append({
                    "file": file_path,
                    "issues": unique_issues,
                })
        final_results[scanner_name] = scanner_results_grouped

    # Show table summary
    table = Table(title="All Scanners Summary")
    table.add_column("Scanner", style="cyan", no_wrap=True)
    table.add_column("Issues Found", justify="right", style="magenta")

    for scanner_name in selected_scanners:
        issue_count = sum(len(f["issues"]) for f in final_results.get(scanner_name, []))
        table.add_row(scanner_name.replace("_", " ").title(), str(issue_count))

    console.print(table)

    # Save or print JSON
    if output:
        with open(output, "w", encoding="utf-8") as f:
            json.dump(final_results, f, indent=4)
        typer.secho(f"Results saved to {output}", fg=typer.colors.GREEN)
    else:
        print_json(data=final_results)

    if fail_on_severity:
        SEVERITY_LEVELS = {"low": 1, "medium": 2, "high": 3, "critical": 4}
        threshold_level = SEVERITY_LEVELS[fail_on_severity.value]
        vulnerability_found = False

        for scanner_name, results in final_results.items():
            for file_result in results:
                for issue in file_result["issues"]:
                    issue_severity_str = issue.get("severity", "low").lower()
                    issue_level = SEVERITY_LEVELS.get(issue_severity_str, 1)
                    if issue_level >= threshold_level:
                        vulnerability_found = True
                        break
                if vulnerability_found:
                    break
            if vulnerability_found:
                break

        if vulnerability_found:
            typer.secho(
                f"Exiting with non-zero code because vulnerabilities with severity {fail_on_severity.value} or higher were found.",
                fg=typer.colors.RED,
            )
            raise typer.Exit(1)


def main():
    app()

if __name__ == "__main__":
    main()
